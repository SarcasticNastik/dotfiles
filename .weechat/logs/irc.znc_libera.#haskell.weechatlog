2021-07-17 15:01:21	-->	amanr (~therojjha@20.204.87.0) has joined #haskell
2021-07-17 15:01:21	--	Topic for #haskell is "https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org | Paste code/errors: https://paste.tomsmeding.com | tunes.org-style logging should be coming soon | Logs: https://ircbrowse.tomsmeding.com/browse/lchaskell"
2021-07-17 15:01:21	--	Topic set by geekosaur (~geekosaur@xmonad/geekosaur) on Mon, 14 Jun 2021 05:16:14
2021-07-17 15:01:22	--	Channel #haskell: 694 nicks (1 op, 0 voices, 693 normals)
2021-07-17 15:01:23	--	Channel created on Sun, 25 Apr 2021 01:04:39
2021-07-17 15:02:14	<--	_xor (~xor@74.215.232.67) has quit (Quit: brb)
2021-07-17 15:02:28	-->	aplainzetakind (~johndoe@captainludd.powered.by.lunarbnc.net) has joined #haskell
2021-07-17 15:03:10	<--	Codaraxis (~Codaraxis@user/codaraxis) has quit (Remote host closed the connection)
2021-07-17 15:03:34	-->	Codaraxis (~Codaraxis@user/codaraxis) has joined #haskell
2021-07-17 15:12:26	-->	_xor (~xor@74.215.232.67) has joined #haskell
2021-07-17 15:17:18	-->	oxide (~lambda@user/oxide) has joined #haskell
2021-07-17 15:20:23	-->	burnsidesLlama (~burnsides@dhcp168-011.wadham.ox.ac.uk) has joined #haskell
2021-07-17 15:23:10	<--	_xor (~xor@74.215.232.67) has quit (Quit: WeeChat 3.2)
2021-07-17 15:23:24	<--	merijn (~merijn@83-160-49-249.ip.xs4all.nl) has quit (Ping timeout: 265 seconds)
2021-07-17 15:24:15	-->	lavaman (~lavaman@98.38.249.169) has joined #haskell
2021-07-17 15:24:51	<--	burnsidesLlama (~burnsides@dhcp168-011.wadham.ox.ac.uk) has quit (Ping timeout: 265 seconds)
2021-07-17 15:27:44	-->	acidjnk (~acidjnk@p200300d0c72b9530b41c89c6d6c03a30.dip0.t-ipconnect.de) has joined #haskell
2021-07-17 15:28:47	<--	lavaman (~lavaman@98.38.249.169) has quit (Ping timeout: 258 seconds)
2021-07-17 15:29:17	<--	Maxdamantus (~Maxdamant@user/maxdamantus) has quit (Ping timeout: 255 seconds)
2021-07-17 15:34:06	<--	slycelote (~slycelote@user/slycelote) has quit (Read error: Connection reset by peer)
2021-07-17 15:34:18	-->	slycelote (~slycelote@user/slycelote) has joined #haskell
2021-07-17 15:35:07	-->	_xor (~xor@74.215.232.67) has joined #haskell
2021-07-17 15:38:35	<--	fef (~thedawn@user/thedawn) has quit (Ping timeout: 244 seconds)
2021-07-17 15:43:30	-->	fef (~thedawn@user/thedawn) has joined #haskell
2021-07-17 15:44:55	<--	gehmehgeh (~user@user/gehmehgeh) has quit (Quit: Leaving)
2021-07-17 15:49:06	<--	chomwitt (~Pitsikoko@athedsl-32487.home.otenet.gr) has quit (Ping timeout: 258 seconds)
2021-07-17 15:50:08	<--	zaquest (~notzaques@5.128.210.178) has quit (Remote host closed the connection)
2021-07-17 15:53:17	arkanoid	the Error monad link is broken https://wiki.haskell.org/Errormonad.html
2021-07-17 15:53:17	-->	zaquest (~notzaques@5.128.210.178) has joined #haskell
2021-07-17 15:53:34	-->	burnsidesLlama (~burnsides@dhcp168-011.wadham.ox.ac.uk) has joined #haskell
2021-07-17 15:58:54	-->	DNH (~DNH@2a02:8108:1100:16d8:6178:3a47:8c71:dd89) has joined #haskell
2021-07-17 15:59:15	<--	burnsidesLlama (~burnsides@dhcp168-011.wadham.ox.ac.uk) has quit (Ping timeout: 255 seconds)
2021-07-17 15:59:41	-->	eggplantade (~Eggplanta@108-201-191-115.lightspeed.sntcca.sbcglobal.net) has joined #haskell
2021-07-17 16:00:59	<--	qbt (~edun@user/edun) has quit (Ping timeout: 258 seconds)
2021-07-17 16:04:12	<--	eggplantade (~Eggplanta@108-201-191-115.lightspeed.sntcca.sbcglobal.net) has quit (Ping timeout: 255 seconds)
2021-07-17 16:04:54	<--	mikoto-chan (~mikoto-ch@ip-213-49-189-31.dsl.scarlet.be) has quit (Read error: No route to host)
2021-07-17 16:08:52	-->	mikoto-chan (~mikoto-ch@ip-213-49-189-31.dsl.scarlet.be) has joined #haskell
2021-07-17 16:12:55	<--	Voxelman (~Voxelman@185.254.75.32) has quit (Read error: Connection reset by peer)
2021-07-17 16:13:37	<--	mrus (~mrus@2001:19f0:5:3fd4:5400:3ff:fe48:1820) has quit (Ping timeout: 246 seconds)
2021-07-17 16:14:16	-->	kuribas (~user@ptr-25vy0i9ash1yu2tubi9.18120a2.ip6.access.telenet.be) has joined #haskell
2021-07-17 16:15:22	kuribas	How does haskell compare to other functional languages?  Looking a bit at SML and OCaml, it seems that haskell has far more libraries, and is more practical for real world projects (other than compilers etc).
2021-07-17 16:16:31	kuribas	Of course scala and clojure are also popular, but I don't consider clojure a real functional language, it's more a lisp derivative.  And Scala is mostly multiparadigm, and also complex and overengineerd.
2021-07-17 16:17:48	arahael	kuribas: I use haskell for most of my private hobby/side projects.  It's awesule, but I've used F# and Swift, which are somewhat OCaml-inspired.
2021-07-17 16:18:25	arahael	kuribas: The biggest most profound difference with Haskell is that it's *lazy*, and has a really really good type system, but in practice that it's lazy makes a big difference to how you use haskell.
2021-07-17 16:18:52	<--	Vajb (~Vajb@hag-jnsbng11-58c3a1-224.dhcp.inet.fi) has quit (Ping timeout: 246 seconds)
2021-07-17 16:18:54	kuribas	arahael: how much libraries are there for F#?  Or does it just use the C# ecosystem?
2021-07-17 16:19:05	arahael	F# is just another .NET language, really, yeah.
2021-07-17 16:19:17	arahael	As is C#. :)
2021-07-17 16:19:20	kuribas	doesn't that mean that most libraries aren't really made for FP?
2021-07-17 16:19:27	-->	Vajb (~Vajb@2001:999:62:1d53:26b1:6c9b:c1ed:9c01) has joined #haskell
2021-07-17 16:20:00	arahael	Kinda.  The way F# copes with nulls is interesting. (It assumes there aren't any).
2021-07-17 16:20:41	kuribas	then how do you test if a function returns null?
2021-07-17 16:21:33	arahael	kuribas: That's a trap, yeah.  In earlier versions, you'd check for it explicitly, and the compiler lets you. But then, the compiler *elides* that check because it thinks better.
2021-07-17 16:21:44	arahael	Hopefully they've changed that now.
2021-07-17 16:23:33	arahael	Looks like they've changed it - suggesting instead to use pattern matching.  Far better: https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/values/null-values
2021-07-17 16:23:59	arahael	But anyway, one difference is that Haskell is lazy, so your functions must not have side effects.
2021-07-17 16:24:30	arahael	And since that practice is so strictly encouraged (otherwise you risk loosing your sanity), that has a flow-on effect to all of haskell's libraries, too.
2021-07-17 16:25:34	DigitalKiwi	haskell is non-strict
2021-07-17 16:25:52	DigitalKiwi	https://wiki.haskell.org/Lazy_vs._non-strict
2021-07-17 16:26:01	arahael	Yeah - more accurate - thanks for that.
2021-07-17 16:26:34	DigitalKiwi	speaking only for myself haskell programmers are lazy ;)
2021-07-17 16:28:05	arahael	Hmm. :)
2021-07-17 16:31:36	DigitalKiwi	and obsesssed with bottoms
2021-07-17 16:32:01	 *	DigitalKiwi drops mic
2021-07-17 16:33:21	Rembane	I like lazy bottoms and I cannot lie.
2021-07-17 16:33:45	-->	anandprabhu (~anandprab@94.202.243.198) has joined #haskell
2021-07-17 16:34:04	-->	wei2912 (~wei2912@112.199.250.21) has joined #haskell
2021-07-17 16:35:00	<--	mikoto-chan (~mikoto-ch@ip-213-49-189-31.dsl.scarlet.be) has quit (Ping timeout: 268 seconds)
2021-07-17 16:35:07	 *	arahael suddenly realises why bottom is drawn like _|_
2021-07-17 16:35:21	<--	enemeth79 (sid309041@id-309041.tooting.irccloud.com) has quit (Quit: Connection closed for inactivity)
2021-07-17 16:35:45	-->	mikoto-chan (~mikoto-ch@ip-213-49-189-31.dsl.scarlet.be) has joined #haskell
2021-07-17 16:36:04	DigitalKiwi	dibblego twitter avatar lolol
2021-07-17 16:38:21	kuribas	arahael: so haskell is the only language that doesn't let you get away coding imperative OO in it?
2021-07-17 16:39:07	kuribas	Although imperative style is still quite possible in haskell.  OO on the other hand is pretty hard.
2021-07-17 16:39:35	dibblego	DigitalKiwi: that's BUMFISH
2021-07-17 16:39:42	<--	Brianmancer (~Neuromanc@user/briandamag) has quit (Ping timeout: 258 seconds)
2021-07-17 16:40:02	DigitalKiwi	is that a new operator
2021-07-17 16:40:17	<--	mikoto-chan (~mikoto-ch@ip-213-49-189-31.dsl.scarlet.be) has quit (Read error: No route to host)
2021-07-17 16:41:41	dibblego	no, it's a pre-landing checklist
2021-07-17 16:43:08	arahael	Heh.
2021-07-17 16:43:36	arahael	kuribas: If it's subtyping you're referring to, no, I don't think haskell has that.
2021-07-17 16:43:58	arahael	kuribas: It does have classes and instances, though, but they behave quite differently.
2021-07-17 16:44:06	kuribas	And that's a good thing...
2021-07-17 16:44:25	 *	arahael thinks so.
2021-07-17 16:44:37	DigitalKiwi	https://www.parsonsmatt.org/2017/02/17/object_oriented_programming_in_haskell.html
2021-07-17 16:44:57	-->	mikoto-chan (~mikoto-ch@ip-213-49-189-31.dsl.scarlet.be) has joined #haskell
2021-07-17 16:46:39	-->	ubert (~Thunderbi@p2e5a50e5.dip0.t-ipconnect.de) has joined #haskell
2021-07-17 16:46:43	DigitalKiwi	https://hackage.haskell.org/package/hoop
2021-07-17 16:46:56	DigitalKiwi	cue bot "haskell can do that!"
2021-07-17 16:52:23	dibblego	DigitalKiwi: https://flightscope.gitlab.io/aircraft/checklist/eurofox.pdf page 1, top-right
2021-07-17 16:53:55	-->	Pickchea (~private@user/pickchea) has joined #haskell
2021-07-17 16:55:30	<--	peterhil (~peterhil@dsl-hkibng32-54f849-252.dhcp.inet.fi) has quit (Ping timeout: 255 seconds)
2021-07-17 16:56:22	-->	peterhil (~peterhil@dsl-hkibng32-54f849-252.dhcp.inet.fi) has joined #haskell
2021-07-17 16:56:44	-->	enemeth79 (uid309041@id-309041.tooting.irccloud.com) has joined #haskell
2021-07-17 16:57:32	-->	hegstal (~hegstal@2a02:c7f:7604:8a00:3e00:8986:ae6e:2aac) has joined #haskell
2021-07-17 17:08:49	<--	Ouroborosie (~pjetcetal@128-71-13-182.broadband.corbina.ru) has quit (Remote host closed the connection)
2021-07-17 17:11:00	<--	Vajb (~Vajb@2001:999:62:1d53:26b1:6c9b:c1ed:9c01) has quit (Read error: Connection reset by peer)
2021-07-17 17:11:55	-->	Vajb (~Vajb@hag-jnsbng11-58c3a1-224.dhcp.inet.fi) has joined #haskell
2021-07-17 17:13:35	<--	anandprabhu (~anandprab@94.202.243.198) has quit (Quit: Leaving)
2021-07-17 17:13:39	<--	MidAutumnMoon9 (~MidAutumn@user/midautumnmoon) has quit (Quit: Leaving for a break - theLounge)
2021-07-17 17:13:54	-->	MidAutumnMoon9 (~MidAutumn@user/midautumnmoon) has joined #haskell
2021-07-17 17:16:19	<--	Vajb (~Vajb@hag-jnsbng11-58c3a1-224.dhcp.inet.fi) has quit (Ping timeout: 268 seconds)
2021-07-17 17:16:53	-->	Vajb (~Vajb@2001:999:62:1d53:26b1:6c9b:c1ed:9c01) has joined #haskell
2021-07-17 17:19:08	-->	merijn (~merijn@83-160-49-249.ip.xs4all.nl) has joined #haskell
2021-07-17 17:21:36	<--	Gurkenglas (~Gurkengla@dslb-002-203-144-156.002.203.pools.vodafone-ip.de) has quit (Ping timeout: 255 seconds)
2021-07-17 17:21:43	<--	hexfive (~eric@50.35.83.177) has quit (Quit: WeeChat 3.0)
2021-07-17 17:25:21	-->	jippiedoe (~david@2a02-a44c-e14e-1-d983-46dc-7f08-a171.fixed6.kpn.net) has joined #haskell
2021-07-17 17:28:55	kuribas	I've been accused of being a haskell lanuage zealot.  But actually I am interested in other languages (logic, FP, dependently typed, etc...).  It just doesn't seem to be useful to push for other languages that I know less...
2021-07-17 17:29:13	-->	Ouroborosie (~pjetcetal@128-71-13-182.broadband.corbina.ru) has joined #haskell
2021-07-17 17:29:21	kuribas	I could recommend F# instead of haskell, but I don't know it that well, so there is less benefit IMO...
2021-07-17 17:30:07	-->	favonia (~favonia@user/favonia) has joined #haskell
2021-07-17 17:31:40	<--	Vajb (~Vajb@2001:999:62:1d53:26b1:6c9b:c1ed:9c01) has quit (Read error: Connection reset by peer)
2021-07-17 17:32:29	-->	Vajb (~Vajb@hag-jnsbng11-58c3a1-224.dhcp.inet.fi) has joined #haskell
2021-07-17 17:33:16	<--	gentauro (~gentauro@user/gentauro) has quit (Read error: Connection reset by peer)
2021-07-17 17:33:49	-->	gentauro (~gentauro@user/gentauro) has joined #haskell
2021-07-17 17:34:48	kuribas	Every time I come with rational arguments, I get a reply like "But I don't like types, they get in the way".  Or "programming languages don't matter, business logic does".  Or "I don't care it's more robust, we want to move fast and solve bugs as we go".
2021-07-17 17:41:30	<--	favonia (~favonia@user/favonia) has quit (Ping timeout: 240 seconds)
2021-07-17 17:41:41	-->	Kaiepi (~Kaiepi@nwcsnbsc03w-47-54-173-93.dhcp-dynamic.fibreop.nb.bellaliant.net) has joined #haskell
2021-07-17 17:41:50	<--	_xor (~xor@74.215.232.67) has quit (Quit: WeeChat 3.2)
2021-07-17 17:44:02	-->	favonia (~favonia@user/favonia) has joined #haskell
2021-07-17 17:45:10	<--	fef (~thedawn@user/thedawn) has quit (Ping timeout: 244 seconds)
2021-07-17 17:45:54	-->	_xor (~xor@74.215.232.67) has joined #haskell
2021-07-17 17:46:02	-->	mnrmnaugh (~mnrmnaugh@pool-96-252-87-182.bstnma.fios.verizon.net) has joined #haskell
2021-07-17 17:48:06	dibblego	get used to it
2021-07-17 17:48:47	tom__	kuribas: I feel your pain
2021-07-17 17:48:53	-->	Guest77 (~Guest77@2402:e280:2117:297:e041:4ae1:dd3c:1f08) has joined #haskell
2021-07-17 17:49:43	tom__	"Types get in the way" then spends three hours NULL chasing
2021-07-17 17:50:50	kuribas	tom__: exactly!  I spend far more time thinking about types in clojure than in haskell.
2021-07-17 17:51:11	maerwald	types can get in the way, especially since haskell lacks structural typing
2021-07-17 17:51:35	tom__	haha sometimes you want types to get in the way
2021-07-17 17:51:51	maerwald	I know of at least one Haskell dev who now works full-time with typescript and doesn't regret it
2021-07-17 17:52:09	maerwald	I probably wouldn't, but it's a valid position
2021-07-17 17:52:50	-->	peterhil_ (~peterhil@dsl-hkibng32-54f849-252.dhcp.inet.fi) has joined #haskell
2021-07-17 17:52:55	tom__	Clojure to me is just javascript with some immutability
2021-07-17 17:52:58	-->	burnsidesLlama (~burnsides@dhcp168-011.wadham.ox.ac.uk) has joined #haskell
2021-07-17 17:53:06	<--	merijn (~merijn@83-160-49-249.ip.xs4all.nl) has quit (Ping timeout: 255 seconds)
2021-07-17 17:53:22	kuribas	maerwald: I find that often, it just amounts to having a bit more boilerplate.  Or having duplicate type definitions.
2021-07-17 17:53:40	maerwald	it can be a *lot* of boilerplate
2021-07-17 17:54:00	maerwald	and prohibits you of expressing certain relationships between data
2021-07-17 17:54:20	tom__	Haskell, Rust and Julia - desert island stack
2021-07-17 17:54:37	tom__	Havent tried the latter two :D
2021-07-17 17:54:58	maerwald	class based solutions don't work well when you need an *actual* data type for serialisation
2021-07-17 17:55:38	-->	brian_da_mage (~Neuromanc@user/briandamag) has joined #haskell
2021-07-17 17:55:45	maerwald	typescript is surprisingly simple and powerful on these matters... certainly less elegant and unsound in a few places, but that's the tradeoff the make
2021-07-17 17:55:47	<--	peterhil (~peterhil@dsl-hkibng32-54f849-252.dhcp.inet.fi) has quit (Ping timeout: 268 seconds)
2021-07-17 17:56:11	kuribas	tom__: rust is only my "to learn list" :)
2021-07-17 17:56:42	kuribas	maerwald: you can be less elegant and unsound in haskell too...
2021-07-17 17:57:02	maerwald	kuribas: yeah, but that usually involves MORE complexity, not less
2021-07-17 17:57:10	maerwald	so the opposite of typescript
2021-07-17 17:57:16	<--	thelounge9230681 (~thelounge@cpe-75-85-161-60.san.res.rr.com) has quit (Remote host closed the connection)
2021-07-17 17:57:22	tom__	You can be and then people who don't understand what a theoretical model is say that it must mean Haskell is pointless
2021-07-17 17:58:12	kuribas	maerwald: I don't agree
2021-07-17 17:58:47	maerwald	well, you *can* do some forms of structural typing/subtyping, but it all ends in esoteric libraries
2021-07-17 17:59:00	kuribas	maerwald: so don't do it.
2021-07-17 17:59:03	maerwald	while you get all that in TS for free without complexity
2021-07-17 17:59:45	maerwald	well, I'm not commenting on which language is better, I'm just commenting on "types can get in the way", because they can
2021-07-17 17:59:55	kuribas	maerwald: plenty of ways to get around that: 1) partially applied functions (the Endo trick), create a new type with some of the fields.  3) just make the fields all Maybe.
2021-07-17 18:00:56	kuribas	maerwald: there is a difference between "the types sometimes get in the way", and "the types always get in the way", the latter is what they seem to be implying.
2021-07-17 18:01:02	maerwald	1) difficult for serialisation, Show instances, debugging, ... 2) boilerplate, 3) unexpressive, because now you have two cases of `Maybe`
2021-07-17 18:01:40	-->	eggplantade (~Eggplanta@108-201-191-115.lightspeed.sntcca.sbcglobal.net) has joined #haskell
2021-07-17 18:02:03	kuribas	You don't need two cases of Maybe
2021-07-17 18:02:44	kuribas	and 4) just put default values.
2021-07-17 18:03:32	maerwald	1. there's no such value, because the computation doesn't return one for the given input, 2. there's no such value, because the computation can *never* return one
2021-07-17 18:03:45	maerwald	now you also have to wonder: 3. there's a value, but there shouldn't be one
2021-07-17 18:03:47	maerwald	oops
2021-07-17 18:03:47	kuribas	IMO, the more you want correctness, the more you are restricted in what you write.  It has nothing to do with types (directly).
2021-07-17 18:04:28	kuribas	maerwald: if you grab to clojure, you don't care anyway...
2021-07-17 18:04:48	maerwald	default values.. what's my default account balance? :p
2021-07-17 18:04:54	dibblego	like I said, get used to it
2021-07-17 18:05:03	<--	awth13 (~user@user/awth13) has quit (Remote host closed the connection)
2021-07-17 18:05:20	tom__	^ yes and get used to makeNegative = (*) -1
2021-07-17 18:05:49	kuribas	Which is my point, haskell can be a nice unsafe language to.  Just make a big sum type, and partial functions over it (don't forget to add error messages though...).
2021-07-17 18:06:17	<--	eggplantade (~Eggplanta@108-201-191-115.lightspeed.sntcca.sbcglobal.net) has quit (Ping timeout: 265 seconds)
2021-07-17 18:06:21	maerwald	well, with structural typing you don't need to be partial
2021-07-17 18:06:25	int-e	Or unsafeCoerce everything and program untyped lambda calculus? :)
2021-07-17 18:06:36	<--	acidjnk (~acidjnk@p200300d0c72b9530b41c89c6d6c03a30.dip0.t-ipconnect.de) has quit (Ping timeout: 255 seconds)
2021-07-17 18:06:48	arahael	kuribas: Mind you, Clojure seems to offer alternative methods to allow you to type ocrrect code.  In particular, Clojure seems to have a fantastic runtime repl.
2021-07-17 18:07:16	arahael	kuribas: Such that you're running the live program and debugging it and replacing functions on the fly.
2021-07-17 18:07:26	int-e	I like types, they prevent some of the more embarrassing programming errors from being run as code.
2021-07-17 18:07:44	tom__	Revenge is forcing them to write a web app in the Lean proof assistant fully verified.
2021-07-17 18:07:49	tom__	It has IO.
2021-07-17 18:08:13	<--	krz3si (~quassel@185.217.117.220) has quit (Ping timeout: 265 seconds)
2021-07-17 18:08:25	maerwald	right... clojure: forget a closing  bracket, code still compiles, but doesn't compute prime numbers... instead it compiles to a chess engine
2021-07-17 18:08:42	tom__	haha
2021-07-17 18:08:46	maerwald	type safe? Yeah maybe. But.
2021-07-17 18:08:48	kuribas	arahael: I think you never actually used clojure?
2021-07-17 18:08:57	<--	zeenk (~zeenk@2a02:2f04:a106:9600:82fb:aed9:ca9:38d3) has quit (Quit: Konversation terminated!)
2021-07-17 18:09:03	int-e	tom__: That's deep in "overdoing it" territory. At least if the specification is anything more elaborate than "something in, something out", and even that may be tricky if you interpret it as a promise to fulfil request in finite time.
2021-07-17 18:09:18	-->	yoctocell (~user@h87-96-130-155.cust.a3fiber.se) has joined #haskell
2021-07-17 18:09:26	kuribas	arahael: it's a very mediocre runtime IMO, compared to java.  Error messages are nearly incomprehensible.  Tracing is nice though...
2021-07-17 18:09:39	tom__	int-e: Yeah pointless torture :)
2021-07-17 18:09:50	maerwald	the only upside of clojure is interactive development
2021-07-17 18:09:55	-->	aman (~aman@user/aman) has joined #haskell
2021-07-17 18:10:08	tom__	The haskell compiler feels pretty interactive
2021-07-17 18:10:29	maerwald	if HLS works, maybe
2021-07-17 18:10:37	arahael	kuribas: Seemed to be effective enough.
2021-07-17 18:10:53	arahael	But no, I haven't personally used it.
2021-07-17 18:11:00	maerwald	but on the other hand: usually not. Compile times are too slow
2021-07-17 18:11:12	kuribas	arahael: clojurists just have a different idea of "correct code".
2021-07-17 18:11:15	arahael	I personally quite like ghcid.
2021-07-17 18:11:27	arahael	kuribas: Indeed, but I think it's the process of discovery that they like.
2021-07-17 18:11:57	arahael	kuribas: In haskell, we seem to prefer to test functions in isolation. Clojure people seem to prefer to test functions in the live system.
2021-07-17 18:12:00	maerwald	if you're working on 300+ modules and your Type module has a whitespace change, you're gonna need to restart cabal a few times, because your machine OOMed due to TH
2021-07-17 18:12:18	tom__	Which library is recommended for sampling probability distributions?
2021-07-17 18:12:42	arahael	maerwald: The amount of memory Haskell uses is crazy high.  Sadly, I find it way faster than Swift. :/
2021-07-17 18:14:32	-->	machinedgod (~machinedg@24.105.81.50) has joined #haskell
2021-07-17 18:15:46	kuribas	arahael: lispers will boast about how easy it is to hot patch live systems.  They don't tell you that it becomes very hard to see who changed what and when.
2021-07-17 18:16:03	<--	favonia (~favonia@user/favonia) has quit (Ping timeout: 255 seconds)
2021-07-17 18:16:05	kuribas	arahael: so you'll end up with CI/CD anyway.  
2021-07-17 18:16:32	-->	favonia (~favonia@user/favonia) has joined #haskell
2021-07-17 18:16:34	kuribas	However a theoretically, a "live" programming environment with integrated version control could be nice.
2021-07-17 18:16:44	kuribas	I don't know if that ever has been done.
2021-07-17 18:17:32	maerwald	https://hackage.haskell.org/package/optics-th-0.4/docs/Optics-TH.html#v:makeClassy
2021-07-17 18:17:34	maerwald	https://hackage.haskell.org/package/optics-th-0.4/docs/Optics-TH.html#v:makeFieldsNoPrefix
2021-07-17 18:17:36	maerwald	https://hackage.haskell.org/package/generic-optics-2.2.0.0/docs/Data-Generics-Product-Fields.html#t:HasField
2021-07-17 18:17:38	maerwald	which one of those to pick?
2021-07-17 18:18:20	-->	lavaman (~lavaman@98.38.249.169) has joined #haskell
2021-07-17 18:19:00	maerwald	HasField is kinda cool with those neat type errors
2021-07-17 18:19:56	-->	bitdex (~bitdex@gateway/tor-sasl/bitdex) has joined #haskell
2021-07-17 18:21:41	<--	Pickchea (~private@user/pickchea) has quit (Ping timeout: 268 seconds)
2021-07-17 18:22:55	<--	lavaman (~lavaman@98.38.249.169) has quit (Ping timeout: 268 seconds)
2021-07-17 18:23:54	<--	Feuermagier (~Feuermagi@user/feuermagier) has quit (Ping timeout: 240 seconds)
2021-07-17 18:25:06	<--	favonia (~favonia@user/favonia) has quit (Ping timeout: 240 seconds)
2021-07-17 18:25:32	-->	fef (~thedawn@user/thedawn) has joined #haskell
2021-07-17 18:27:13	-->	pesada (~agua@2804:18:48:588b:1:0:277e:35b0) has joined #haskell
2021-07-17 18:27:27	-->	favonia (~favonia@user/favonia) has joined #haskell
2021-07-17 18:29:33	<--	jippiedoe (~david@2a02-a44c-e14e-1-d983-46dc-7f08-a171.fixed6.kpn.net) has quit (Ping timeout: 255 seconds)
2021-07-17 18:29:34	<--	azeem (~azeem@dynamic-adsl-94-34-31-95.clienti.tiscali.it) has quit (Read error: Connection reset by peer)
2021-07-17 18:31:06	<--	agua (~agua@2804:14c:8793:8e2f:a4d4:3a0b:9f6:6100) has quit (Ping timeout: 240 seconds)
2021-07-17 18:34:25	-->	azeem (~azeem@dynamic-adsl-94-34-31-95.clienti.tiscali.it) has joined #haskell
2021-07-17 18:36:50	-->	jao (~jao@cpc103048-sgyl39-2-0-cust502.18-2.cable.virginm.net) has joined #haskell
2021-07-17 18:38:00	-->	raehik (~raehik@cpc95906-rdng25-2-0-cust156.15-3.cable.virginm.net) has joined #haskell
2021-07-17 18:38:26	-->	drd (~drd@93-39-151-19.ip76.fastwebnet.it) has joined #haskell
2021-07-17 18:41:29	-->	chomwitt (~Pitsikoko@athedsl-32487.home.otenet.gr) has joined #haskell
2021-07-17 18:46:58	<--	hegstal (~hegstal@2a02:c7f:7604:8a00:3e00:8986:ae6e:2aac) has quit (Remote host closed the connection)
2021-07-17 18:51:34	<--	machinedgod (~machinedg@24.105.81.50) has quit (Ping timeout: 258 seconds)
2021-07-17 18:52:44	<--	burnsidesLlama (~burnsides@dhcp168-011.wadham.ox.ac.uk) has quit (Remote host closed the connection)
2021-07-17 18:54:15	-->	justLearning96 (~justLearn@bb42-60-215-35.singnet.com.sg) has joined #haskell
2021-07-17 18:57:14	<--	justLearning96 (~justLearn@bb42-60-215-35.singnet.com.sg) has left #haskell
2021-07-17 18:59:20	-->	Maxdamantus (~Maxdamant@user/maxdamantus) has joined #haskell
2021-07-17 19:01:06	<--	favonia (~favonia@user/favonia) has quit (Ping timeout: 240 seconds)
2021-07-17 19:02:07	-->	agua (~agua@2804:14c:8793:8e2f:a4d4:3a0b:9f6:6100) has joined #haskell
2021-07-17 19:03:28	-->	favonia (~favonia@user/favonia) has joined #haskell
2021-07-17 19:04:12	<--	pesada (~agua@2804:18:48:588b:1:0:277e:35b0) has quit (Ping timeout: 255 seconds)
2021-07-17 19:09:28	<--	ezzieyguywuf (~Unknown@user/ezzieyguywuf) has quit (Remote host closed the connection)
2021-07-17 19:10:39	-->	ezzieyguywuf (~Unknown@user/ezzieyguywuf) has joined #haskell
2021-07-17 19:11:43	-->	merijn (~merijn@83-160-49-249.ip.xs4all.nl) has joined #haskell
2021-07-17 19:13:28	-->	Guest15 (~Guest15@2402:e280:2117:297:e041:4ae1:dd3c:1f08) has joined #haskell
2021-07-17 19:13:50	<--	xff0x (~xff0x@2001:1a81:5219:9d00:3d14:ef54:1c92:a192) has quit (Ping timeout: 255 seconds)
2021-07-17 19:14:20	<--	wei2912 (~wei2912@112.199.250.21) has quit (Quit: Lost terminal)
2021-07-17 19:14:30	-->	xff0x (~xff0x@port-92-193-131-10.dynamic.as20676.net) has joined #haskell
2021-07-17 19:15:18	<--	Guest15 (~Guest15@2402:e280:2117:297:e041:4ae1:dd3c:1f08) has quit (Client Quit)
2021-07-17 19:24:00	<--	mnrmnaugh (~mnrmnaugh@pool-96-252-87-182.bstnma.fios.verizon.net) has quit (Ping timeout: 255 seconds)
2021-07-17 19:32:29	-->	norias (~jaredm@c-98-219-195-163.hsd1.pa.comcast.net) has joined #haskell
2021-07-17 19:32:49	-->	burnsidesLlama (~burnsides@dhcp168-011.wadham.ox.ac.uk) has joined #haskell
2021-07-17 19:34:05	<--	favonia (~favonia@user/favonia) has quit (Ping timeout: 255 seconds)
2021-07-17 19:36:40	-->	favonia (~favonia@user/favonia) has joined #haskell
2021-07-17 19:36:43	-->	mnrmnaugh (~mnrmnaugh@pool-96-252-87-182.bstnma.fios.verizon.net) has joined #haskell
2021-07-17 19:43:41	--	irc: disconnected from server
2021-07-17 19:43:52	-->	amanr (~therojjha@20.204.87.0) has joined #haskell
2021-07-17 19:43:52	--	Topic for #haskell is "https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org | Paste code/errors: https://paste.tomsmeding.com | tunes.org-style logging should be coming soon | Logs: https://ircbrowse.tomsmeding.com/browse/lchaskell"
2021-07-17 19:43:52	--	Topic set by geekosaur (~geekosaur@xmonad/geekosaur) on Mon, 14 Jun 2021 05:16:14
2021-07-17 19:43:52	--	Channel #haskell: 698 nicks (1 op, 0 voices, 697 normals)
2021-07-17 19:43:52	***	Buffer Playback...
2021-07-17 19:43:52	arkanoid	[10:23:16] the Error monad link is broken https://wiki.haskell.org/Errormonad.html
2021-07-17 19:43:52	kuribas	[10:45:22] How does haskell compare to other functional languages?  Looking a bit at SML and OCaml, it seems that haskell has far more libraries, and is more practical for real world projects (other than compilers etc).
2021-07-17 19:43:52	kuribas	[10:46:31] Of course scala and clojure are also popular, but I don't consider clojure a real functional language, it's more a lisp derivative.  And Scala is mostly multiparadigm, and also complex and overengineerd.
2021-07-17 19:43:52	arahael	[10:47:48] kuribas: I use haskell for most of my private hobby/side projects.  It's awesule, but I've used F# and Swift, which are somewhat OCaml-inspired.
2021-07-17 19:43:52	arahael	[10:48:25] kuribas: The biggest most profound difference with Haskell is that it's *lazy*, and has a really really good type system, but in practice that it's lazy makes a big difference to how you use haskell.
2021-07-17 19:43:52	kuribas	[10:48:54] arahael: how much libraries are there for F#?  Or does it just use the C# ecosystem?
2021-07-17 19:43:52	arahael	[10:49:05] F# is just another .NET language, really, yeah.
2021-07-17 19:43:52	arahael	[10:49:17] As is C#. :)
2021-07-17 19:43:52	kuribas	[10:49:20] doesn't that mean that most libraries aren't really made for FP?
2021-07-17 19:43:52	arahael	[10:50:00] Kinda.  The way F# copes with nulls is interesting. (It assumes there aren't any).
2021-07-17 19:43:52	kuribas	[10:50:41] then how do you test if a function returns null?
2021-07-17 19:43:52	arahael	[10:51:33] kuribas: That's a trap, yeah.  In earlier versions, you'd check for it explicitly, and the compiler lets you. But then, the compiler *elides* that check because it thinks better.
2021-07-17 19:43:52	arahael	[10:51:44] Hopefully they've changed that now.
2021-07-17 19:43:52	arahael	[10:53:33] Looks like they've changed it - suggesting instead to use pattern matching.  Far better: https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/values/null-values
2021-07-17 19:43:52	arahael	[10:53:59] But anyway, one difference is that Haskell is lazy, so your functions must not have side effects.
2021-07-17 19:43:52	arahael	[10:54:30] And since that practice is so strictly encouraged (otherwise you risk loosing your sanity), that has a flow-on effect to all of haskell's libraries, too.
2021-07-17 19:43:52	DigitalKiwi	[10:55:34] haskell is non-strict
2021-07-17 19:43:52	DigitalKiwi	[10:55:52] https://wiki.haskell.org/Lazy_vs._non-strict
2021-07-17 19:43:52	arahael	[10:56:01] Yeah - more accurate - thanks for that.
2021-07-17 19:43:52	DigitalKiwi	[10:56:34] speaking only for myself haskell programmers are lazy ;)
2021-07-17 19:43:52	arahael	[10:58:05] Hmm. :)
2021-07-17 19:43:52	DigitalKiwi	[11:01:36] and obsesssed with bottoms
2021-07-17 19:43:52	 *	DigitalKiwi [11:02:01] drops mic
2021-07-17 19:43:52	Rembane	[11:03:21] I like lazy bottoms and I cannot lie.
2021-07-17 19:43:52	 *	arahael [11:05:07] suddenly realises why bottom is drawn like _|_
2021-07-17 19:43:52	DigitalKiwi	[11:06:04] dibblego twitter avatar lolol
2021-07-17 19:43:52	kuribas	[11:08:21] arahael: so haskell is the only language that doesn't let you get away coding imperative OO in it?
2021-07-17 19:43:52	kuribas	[11:09:07] Although imperative style is still quite possible in haskell.  OO on the other hand is pretty hard.
2021-07-17 19:43:52	dibblego	[11:09:35] DigitalKiwi: that's BUMFISH
2021-07-17 19:43:52	DigitalKiwi	[11:10:01] is that a new operator
2021-07-17 19:43:52	dibblego	[11:11:41] no, it's a pre-landing checklist
2021-07-17 19:43:52	arahael	[11:13:08] Heh.
2021-07-17 19:43:52	arahael	[11:13:36] kuribas: If it's subtyping you're referring to, no, I don't think haskell has that.
2021-07-17 19:43:52	arahael	[11:13:58] kuribas: It does have classes and instances, though, but they behave quite differently.
2021-07-17 19:43:52	kuribas	[11:14:06] And that's a good thing...
2021-07-17 19:43:52	 *	arahael [11:14:25] thinks so.
2021-07-17 19:43:52	DigitalKiwi	[11:14:37] https://www.parsonsmatt.org/2017/02/17/object_oriented_programming_in_haskell.html
2021-07-17 19:43:52	DigitalKiwi	[11:16:43] https://hackage.haskell.org/package/hoop
2021-07-17 19:43:52	DigitalKiwi	[11:16:56] cue bot "haskell can do that!"
2021-07-17 19:43:52	dibblego	[11:22:23] DigitalKiwi: https://flightscope.gitlab.io/aircraft/checklist/eurofox.pdf page 1, top-right
2021-07-17 19:43:52	kuribas	[11:58:55] I've been accused of being a haskell lanuage zealot.  But actually I am interested in other languages (logic, FP, dependently typed, etc...).  It just doesn't seem to be useful to push for other languages that I know less...
2021-07-17 19:43:52	kuribas	[11:59:21] I could recommend F# instead of haskell, but I don't know it that well, so there is less benefit IMO...
2021-07-17 19:43:52	kuribas	[12:04:48] Every time I come with rational arguments, I get a reply like "But I don't like types, they get in the way".  Or "programming languages don't matter, business logic does".  Or "I don't care it's more robust, we want to move fast and solve bugs as we go".
2021-07-17 19:43:52	dibblego	[12:18:06] get used to it
2021-07-17 19:43:52	tom__	[12:18:47] kuribas: I feel your pain
2021-07-17 19:43:52	tom__	[12:19:43] "Types get in the way" then spends three hours NULL chasing
2021-07-17 19:43:52	kuribas	[12:20:50] tom__: exactly!  I spend far more time thinking about types in clojure than in haskell.
2021-07-17 19:43:52	maerwald	[12:21:11] types can get in the way, especially since haskell lacks structural typing
2021-07-17 19:43:52	tom__	[12:21:34] haha sometimes you want types to get in the way
2021-07-17 19:43:52	maerwald	[12:21:51] I know of at least one Haskell dev who now works full-time with typescript and doesn't regret it
2021-07-17 19:43:52	maerwald	[12:22:09] I probably wouldn't, but it's a valid position
2021-07-17 19:43:52	tom__	[12:22:55] Clojure to me is just javascript with some immutability
2021-07-17 19:43:52	kuribas	[12:23:22] maerwald: I find that often, it just amounts to having a bit more boilerplate.  Or having duplicate type definitions.
2021-07-17 19:43:52	maerwald	[12:23:40] it can be a *lot* of boilerplate
2021-07-17 19:43:52	maerwald	[12:24:00] and prohibits you of expressing certain relationships between data
2021-07-17 19:43:52	tom__	[12:24:19] Haskell, Rust and Julia - desert island stack
2021-07-17 19:43:52	tom__	[12:24:37] Havent tried the latter two :D
2021-07-17 19:43:52	maerwald	[12:24:58] class based solutions don't work well when you need an *actual* data type for serialisation
2021-07-17 19:43:52	maerwald	[12:25:45] typescript is surprisingly simple and powerful on these matters... certainly less elegant and unsound in a few places, but that's the tradeoff the make
2021-07-17 19:43:52	kuribas	[12:26:10] tom__: rust is only my "to learn list" :)
2021-07-17 19:43:52	kuribas	[12:26:42] maerwald: you can be less elegant and unsound in haskell too...
2021-07-17 19:43:52	maerwald	[12:27:02] kuribas: yeah, but that usually involves MORE complexity, not less
2021-07-17 19:43:52	maerwald	[12:27:10] so the opposite of typescript
2021-07-17 19:43:52	tom__	[12:27:22] You can be and then people who don't understand what a theoretical model is say that it must mean Haskell is pointless
2021-07-17 19:43:52	kuribas	[12:28:12] maerwald: I don't agree
2021-07-17 19:43:52	maerwald	[12:28:47] well, you *can* do some forms of structural typing/subtyping, but it all ends in esoteric libraries
2021-07-17 19:43:52	kuribas	[12:29:00] maerwald: so don't do it.
2021-07-17 19:43:52	maerwald	[12:29:03] while you get all that in TS for free without complexity
2021-07-17 19:43:52	maerwald	[12:29:45] well, I'm not commenting on which language is better, I'm just commenting on "types can get in the way", because they can
2021-07-17 19:43:52	kuribas	[12:29:55] maerwald: plenty of ways to get around that: 1) partially applied functions (the Endo trick), create a new type with some of the fields.  3) just make the fields all Maybe.
2021-07-17 19:43:52	kuribas	[12:30:56] maerwald: there is a difference between "the types sometimes get in the way", and "the types always get in the way", the latter is what they seem to be implying.
2021-07-17 19:43:52	maerwald	[12:31:02] 1) difficult for serialisation, Show instances, debugging, ... 2) boilerplate, 3) unexpressive, because now you have two cases of `Maybe`
2021-07-17 19:43:52	kuribas	[12:32:02] You don't need two cases of Maybe
2021-07-17 19:43:52	kuribas	[12:32:44] and 4) just put default values.
2021-07-17 19:43:52	maerwald	[12:33:32] 1. there's no such value, because the computation doesn't return one for the given input, 2. there's no such value, because the computation can *never* return one
2021-07-17 19:43:52	maerwald	[12:33:45] now you also have to wonder: 3. there's a value, but there shouldn't be one
2021-07-17 19:43:52	maerwald	[12:33:47] oops
2021-07-17 19:43:52	kuribas	[12:33:47] IMO, the more you want correctness, the more you are restricted in what you write.  It has nothing to do with types (directly).
2021-07-17 19:43:52	kuribas	[12:34:28] maerwald: if you grab to clojure, you don't care anyway...
2021-07-17 19:43:52	maerwald	[12:34:48] default values.. what's my default account balance? :p
2021-07-17 19:43:52	dibblego	[12:34:54] like I said, get used to it
2021-07-17 19:43:52	tom__	[12:35:20] ^ yes and get used to makeNegative = (*) -1
2021-07-17 19:43:52	kuribas	[12:35:49] Which is my point, haskell can be a nice unsafe language to.  Just make a big sum type, and partial functions over it (don't forget to add error messages though...).
2021-07-17 19:43:52	maerwald	[12:36:21] well, with structural typing you don't need to be partial
2021-07-17 19:43:52	int-e	[12:36:25] Or unsafeCoerce everything and program untyped lambda calculus? :)
2021-07-17 19:43:52	arahael	[12:36:48] kuribas: Mind you, Clojure seems to offer alternative methods to allow you to type ocrrect code.  In particular, Clojure seems to have a fantastic runtime repl.
2021-07-17 19:43:52	arahael	[12:37:15] kuribas: Such that you're running the live program and debugging it and replacing functions on the fly.
2021-07-17 19:43:52	int-e	[12:37:26] I like types, they prevent some of the more embarrassing programming errors from being run as code.
2021-07-17 19:43:52	tom__	[12:37:44] Revenge is forcing them to write a web app in the Lean proof assistant fully verified.
2021-07-17 19:43:52	tom__	[12:37:49] It has IO.
2021-07-17 19:43:52	maerwald	[12:38:25] right... clojure: forget a closing  bracket, code still compiles, but doesn't compute prime numbers... instead it compiles to a chess engine
2021-07-17 19:43:52	tom__	[12:38:42] haha
2021-07-17 19:43:52	maerwald	[12:38:45] type safe? Yeah maybe. But.
2021-07-17 19:43:52	kuribas	[12:38:48] arahael: I think you never actually used clojure?
2021-07-17 19:43:52	int-e	[12:39:03] tom__: That's deep in "overdoing it" territory. At least if the specification is anything more elaborate than "something in, something out", and even that may be tricky if you interpret it as a promise to fulfil request in finite time.
2021-07-17 19:43:52	kuribas	[12:39:26] arahael: it's a very mediocre runtime IMO, compared to java.  Error messages are nearly incomprehensible.  Tracing is nice though...
2021-07-17 19:43:52	tom__	[12:39:39] int-e: Yeah pointless torture :)
2021-07-17 19:43:52	maerwald	[12:39:50] the only upside of clojure is interactive development
2021-07-17 19:43:52	tom__	[12:40:08] The haskell compiler feels pretty interactive
2021-07-17 19:43:52	maerwald	[12:40:29] if HLS works, maybe
2021-07-17 19:43:52	arahael	[12:40:37] kuribas: Seemed to be effective enough.
2021-07-17 19:43:52	arahael	[12:40:53] But no, I haven't personally used it.
2021-07-17 19:43:52	maerwald	[12:41:00] but on the other hand: usually not. Compile times are too slow
2021-07-17 19:43:52	kuribas	[12:41:12] arahael: clojurists just have a different idea of "correct code".
2021-07-17 19:43:52	arahael	[12:41:15] I personally quite like ghcid.
2021-07-17 19:43:52	arahael	[12:41:27] kuribas: Indeed, but I think it's the process of discovery that they like.
2021-07-17 19:43:52	arahael	[12:41:57] kuribas: In haskell, we seem to prefer to test functions in isolation. Clojure people seem to prefer to test functions in the live system.
2021-07-17 19:43:52	maerwald	[12:42:00] if you're working on 300+ modules and your Type module has a whitespace change, you're gonna need to restart cabal a few times, because your machine OOMed due to TH
2021-07-17 19:43:52	tom__	[12:42:18] Which library is recommended for sampling probability distributions?
2021-07-17 19:43:52	arahael	[12:42:42] maerwald: The amount of memory Haskell uses is crazy high.  Sadly, I find it way faster than Swift. :/
2021-07-17 19:43:52	kuribas	[12:45:45] arahael: lispers will boast about how easy it is to hot patch live systems.  They don't tell you that it becomes very hard to see who changed what and when.
2021-07-17 19:43:52	kuribas	[12:46:05] arahael: so you'll end up with CI/CD anyway.  
2021-07-17 19:43:52	kuribas	[12:46:34] However a theoretically, a "live" programming environment with integrated version control could be nice.
2021-07-17 19:43:52	kuribas	[12:46:44] I don't know if that ever has been done.
2021-07-17 19:43:52	maerwald	[12:47:32] https://hackage.haskell.org/package/optics-th-0.4/docs/Optics-TH.html#v:makeClassy
2021-07-17 19:43:52	maerwald	[12:47:34] https://hackage.haskell.org/package/optics-th-0.4/docs/Optics-TH.html#v:makeFieldsNoPrefix
2021-07-17 19:43:52	maerwald	[12:47:36] https://hackage.haskell.org/package/generic-optics-2.2.0.0/docs/Data-Generics-Product-Fields.html#t:HasField
2021-07-17 19:43:52	maerwald	[12:47:38] which one of those to pick?
2021-07-17 19:43:52	maerwald	[12:49:00] HasField is kinda cool with those neat type errors
2021-07-17 19:43:52	***	Playback Complete.
2021-07-17 19:44:01	--	Channel created on Sun, 25 Apr 2021 01:04:39
2021-07-17 19:49:06	<--	favonia (~favonia@user/favonia) has quit (Ping timeout: 240 seconds)
2021-07-17 19:51:25	-->	favonia (~favonia@user/favonia) has joined #haskell
2021-07-17 20:05:12	-->	nate1 (~nate@108-233-125-227.lightspeed.sntcca.sbcglobal.net) has joined #haskell
2021-07-17 20:10:32	<--	favonia (~favonia@user/favonia) has quit (Ping timeout: 255 seconds)
2021-07-17 20:10:56	-->	favonia (~favonia@user/favonia) has joined #haskell
2021-07-17 20:14:11	-->	Ariakenom (~Ariakenom@c83-255-154-140.bredband.tele2.se) has joined #haskell
2021-07-17 20:14:32	<--	merijn (~merijn@83-160-49-249.ip.xs4all.nl) has quit (Ping timeout: 268 seconds)
2021-07-17 20:14:37	<--	Guest77 (~Guest77@2402:e280:2117:297:e041:4ae1:dd3c:1f08) has quit (Quit: Ping timeout (120 seconds))
2021-07-17 20:15:50	-->	Guest77 (~Guest77@2402:e280:2117:297:e041:4ae1:dd3c:1f08) has joined #haskell
2021-07-17 20:21:13	-->	zebrag (~chris@user/zebrag) has joined #haskell
2021-07-17 20:25:15	-->	slowButPresent (~slowButPr@user/slowbutpresent) has joined #haskell
2021-07-17 20:26:14	<--	Guest77 (~Guest77@2402:e280:2117:297:e041:4ae1:dd3c:1f08) has quit (Quit: Client closed)
2021-07-17 20:26:32	-->	Guest77 (~Guest77@2402:e280:2117:297:e041:4ae1:dd3c:1f08) has joined #haskell
2021-07-17 20:27:27	--	fef is now known as admin
2021-07-17 20:27:36	--	admin is now known as adminll
2021-07-17 20:27:48	-->	wroathe (~wroathe@c-68-54-25-135.hsd1.mn.comcast.net) has joined #haskell
2021-07-17 20:32:55	<--	meinside_ (uid24933@id-24933.brockwell.irccloud.com) has quit (Quit: Connection closed for inactivity)
2021-07-17 20:34:20	-->	merijn (~merijn@83-160-49-249.ip.xs4all.nl) has joined #haskell
2021-07-17 20:38:14	-->	smichel17 (~smichel17@c-73-68-217-18.hsd1.ma.comcast.net) has joined #haskell
2021-07-17 20:38:50	-->	gehmehgeh (~user@user/gehmehgeh) has joined #haskell
2021-07-17 20:39:01	-->	texasmynsted (~texasmyns@99.96.221.112) has joined #haskell
2021-07-17 20:40:23	<--	gehmehgeh (~user@user/gehmehgeh) has quit (Client Quit)
2021-07-17 20:42:29	<--	nate1 (~nate@108-233-125-227.lightspeed.sntcca.sbcglobal.net) has quit (Ping timeout: 255 seconds)
2021-07-17 20:42:54	-->	fradet (~fradet@216.252.75.247) has joined #haskell
2021-07-17 20:43:31	<--	andreas303 (andreas303@ip227.orange.bnc4free.com) has quit (Ping timeout: 268 seconds)
2021-07-17 20:44:01	-->	Zemyla_ (~ec2-user@ec2-54-196-11-2.compute-1.amazonaws.com) has joined #haskell
2021-07-17 20:44:08	<--	Aleksejs_Home (~Aleksejs@haskell.lv) has quit (Ping timeout: 268 seconds)
2021-07-17 20:44:08	<--	ajb (~ajb@cupid.whatbox.ca) has quit (Ping timeout: 268 seconds)
2021-07-17 20:44:45	<--	Zemyla (~ec2-user@ec2-54-196-11-2.compute-1.amazonaws.com) has quit (Ping timeout: 268 seconds)
2021-07-17 20:44:57	-->	oso (~oso@2601:58c:c080:a950:e67d:b4e2:c5be:433f) has joined #haskell
2021-07-17 20:45:01	-->	andreas303 (andreas303@ip227.orange.bnc4free.com) has joined #haskell
2021-07-17 20:45:22	<--	superbil (~superbil@1-34-176-171.hinet-ip.hinet.net) has quit (Ping timeout: 268 seconds)
2021-07-17 20:45:35	-->	sim590 (~simon@modemcable090.207-203-24.mc.videotron.ca) has joined #haskell
2021-07-17 20:45:35	boxscape	maerwald: the TH versions say "This method of optics generation should only be used when migrating an existing codebase from the lens library to optics"
2021-07-17 20:45:40	-->	ajb (~ajb@cupid.whatbox.ca) has joined #haskell
2021-07-17 20:45:51	boxscape	maerwald: this, my final answer is C
2021-07-17 20:45:56	boxscape	s/this/thus
2021-07-17 20:46:00	<--	nonzen (~nonzen@user/nonzen) has quit (Ping timeout: 268 seconds)
2021-07-17 20:46:00	<--	aweinstock (~aweinstoc@cpe-67-248-65-250.nycap.res.rr.com) has quit (Ping timeout: 268 seconds)
2021-07-17 20:46:00	<--	hololeap (~hololeap@user/hololeap) has quit (Ping timeout: 244 seconds)
2021-07-17 20:46:07	maerwald	HasField?
2021-07-17 20:46:20	-->	Aleksejs (~Aleksejs@haskell.lv) has joined #haskell
2021-07-17 20:46:21	<--	Ariakenom (~Ariakenom@c83-255-154-140.bredband.tele2.se) has quit (Ping timeout: 255 seconds)
2021-07-17 20:46:34	-->	nonzen (~nonzen@user/nonzen) has joined #haskell
2021-07-17 20:46:46	boxscape	yeah.. though I thought there was a version of that which uses OverloadedLabels
2021-07-17 20:47:20	maerwald	HasField though doesn't allow arbitrary subtyping... it's a simple getter
2021-07-17 20:47:23	-->	aweinstock (~aweinstoc@cpe-67-248-65-250.nycap.res.rr.com) has joined #haskell
2021-07-17 20:47:32	<--	adminll (~thedawn@user/thedawn) has quit (Remote host closed the connection)
2021-07-17 20:47:36	-->	hololeap (~hololeap@user/hololeap) has joined #haskell
2021-07-17 20:47:54	maerwald	with makeClassy style classes you could descend deeper into the structure with the same getter
2021-07-17 20:48:03	-->	Guest9 (~Guest9@43.242.116.127) has joined #haskell
2021-07-17 20:48:12	-->	superbil (~superbil@1-34-176-171.HINET-IP.hinet.net) has joined #haskell
2021-07-17 20:48:12	-->	adminll (~thedawn@user/thedawn) has joined #haskell
2021-07-17 20:48:31	boxscape	maerwald: oh actually the TH version links to https://hackage.haskell.org/package/optics-core-0.4/docs/Optics-Label.html as preferred solution
2021-07-17 20:49:03	boxscape	that's the OverloadedLabels version I was remembering
2021-07-17 20:49:04	<--	ByronJohnson (~bairyn@mail.digitalkingdom.org) has quit (Ping timeout: 268 seconds)
2021-07-17 20:49:12	-->	ByronJohnson (~bairyn@mail.digitalkingdom.org) has joined #haskell
2021-07-17 20:49:41	-->	Ariakenom (~Ariakenom@c83-255-154-140.bredband.tele2.se) has joined #haskell
2021-07-17 20:51:31	-->	Null_A (~null_a@2601:645:8700:2290:b55a:33c2:1e1d:f229) has joined #haskell
2021-07-17 20:52:44	maerwald	so there you could also define custom LabelOptic instances that descend into a structure?
2021-07-17 20:53:26	boxscape	that seems plausible but I haven't tried doing it
2021-07-17 20:53:47	maerwald	I'm leaning towards makeClassy, but I'm not sure
2021-07-17 20:54:25	boxscape	I like makeClassy, the main reason I would avoid it personally is that the documentation advises against it
2021-07-17 20:55:40	maerwald	so what does LabelOptic give over HasField?
2021-07-17 20:55:43	-->	Ariakenom_ (~Ariakenom@c83-255-154-140.bredband.tele2.se) has joined #haskell
2021-07-17 20:56:17	texasmynsted	What is the modern answer to haskell records? Lens?
2021-07-17 20:56:49	maerwald	only difference I see is labelOptic is `Optic` and HasField is a `Lens`
2021-07-17 20:58:24	boxscape	hm I'm not sure what the concrete differences are
2021-07-17 20:59:14	-->	elf_fortrez (~elf_fortr@adsl-72-50-6-20.prtc.net) has joined #haskell
2021-07-17 20:59:33	<--	Ariakenom (~Ariakenom@c83-255-154-140.bredband.tele2.se) has quit (Ping timeout: 268 seconds)
2021-07-17 20:59:35	-->	Lycurgus (~juan@cpe-45-46-140-49.buffalo.res.rr.com) has joined #haskell
2021-07-17 21:00:52	boxscape	texasmynsted: there are a few answers to this: In the next version, OverloadedRecordDot is being introduces, which allows one to write something like `personA.company.name`. (Updates are a bit iffy but will improve over time.) In the meantime, lens is definitely still widely used, though optics is a replacement which aims to have better error messages. There is also some research going into row types, but that's further out.
2021-07-17 21:00:55	boxscape	s/next version/next version of GHC
2021-07-17 21:01:36	-->	nate1 (~nate@108-233-125-227.lightspeed.sntcca.sbcglobal.net) has joined #haskell
2021-07-17 21:02:08	boxscape	(though regarding row types, the vinyl records package allows something similar today)
2021-07-17 21:03:11	-->	hnOsmium0001 (uid453710@id-453710.stonehaven.irccloud.com) has joined #haskell
2021-07-17 21:05:02	-->	Ariakenom__ (~Ariakenom@c83-255-154-140.bredband.tele2.se) has joined #haskell
2021-07-17 21:05:20	<--	enemeth79 (uid309041@id-309041.tooting.irccloud.com) has quit (Quit: Connection closed for inactivity)
2021-07-17 21:05:21	-->	gehmehgeh (~user@user/gehmehgeh) has joined #haskell
2021-07-17 21:05:30	<--	elf_fortrez (~elf_fortr@adsl-72-50-6-20.prtc.net) has quit (Quit: Client closed)
2021-07-17 21:06:09	<--	nate1 (~nate@108-233-125-227.lightspeed.sntcca.sbcglobal.net) has quit (Ping timeout: 255 seconds)
2021-07-17 21:08:40	<--	oso (~oso@2601:58c:c080:a950:e67d:b4e2:c5be:433f) has quit (Ping timeout: 246 seconds)
2021-07-17 21:08:48	<--	Ariakenom_ (~Ariakenom@c83-255-154-140.bredband.tele2.se) has quit (Ping timeout: 268 seconds)
2021-07-17 21:09:45	<--	favonia (~favonia@user/favonia) has quit (Ping timeout: 255 seconds)
2021-07-17 21:10:03	-->	favonia (~favonia@user/favonia) has joined #haskell
2021-07-17 21:13:24	<--	MQ-17J (~MQ-17J@d14-69-206-129.try.wideopenwest.com) has quit (Ping timeout: 258 seconds)
2021-07-17 21:13:44	<--	kuribas (~user@ptr-25vy0i9ash1yu2tubi9.18120a2.ip6.access.telenet.be) has quit (Quit: ERC (IRC client for Emacs 26.3))
2021-07-17 21:14:31	-->	falafel (~falafel@pool-96-255-70-50.washdc.fios.verizon.net) has joined #haskell
2021-07-17 21:15:43	<--	keutoi (~keutoi@157.48.202.216) has quit (Quit: Reconnecting)
2021-07-17 21:15:53	-->	keutoi (~keutoi@157.48.202.216) has joined #haskell
2021-07-17 21:16:54	-->	chris_ (~chris@81.96.113.213) has joined #haskell
2021-07-17 21:17:16	<--	Guest77 (~Guest77@2402:e280:2117:297:e041:4ae1:dd3c:1f08) has quit (Quit: Client closed)
2021-07-17 21:23:52	-->	MQ-17J (~MQ-17J@d14-69-206-129.try.wideopenwest.com) has joined #haskell
2021-07-17 21:25:47	<--	hendursa1 (~weechat@user/hendursaga) has quit (Ping timeout: 244 seconds)
2021-07-17 21:26:16	-->	hendursa1 (~weechat@user/hendursaga) has joined #haskell
2021-07-17 21:26:22	-->	arjun (~user@user/arjun) has joined #haskell
2021-07-17 21:29:48	-->	Guest14 (~Guest14@76-236-222-208.lightspeed.tukrga.sbcglobal.net) has joined #haskell
2021-07-17 21:33:06	Guest14	Hello :)
2021-07-17 21:33:40	Guest14	I am new to Haskell and am working through the Real World Haskell Book
2021-07-17 21:33:57	-->	econo (uid147250@user/econo) has joined #haskell
2021-07-17 21:34:27	Guest14	I have a basic question if anyone would care to listen
2021-07-17 21:36:02	allbery_b	best to just ask it rather than asking to ask
2021-07-17 21:36:11	--	allbery_b is now known as geekosaur
2021-07-17 21:36:23	davean	asking to ask is why I wasn't helping
2021-07-17 21:37:44	Guest14	splitWith _ [] = []
2021-07-17 21:37:45	Guest14	splitWith a xs = [pre ++ [x]] ++ next
2021-07-17 21:37:45	Guest14	    where 
2021-07-17 21:37:46	Guest14	        (pre, x:suf) = span a xs
2021-07-17 21:37:47	Guest14	        next = splitWith a suf
2021-07-17 21:38:10	Guest14	I have this program and I run into a problem with x:suf when span a xs is [] becuase there is no head
2021-07-17 21:39:30	<--	chomwitt (~Pitsikoko@athedsl-32487.home.otenet.gr) has quit (Ping timeout: 240 seconds)
2021-07-17 21:39:34	int-e	> let f = splitAt 1 in (f "abc", f "")
2021-07-17 21:39:36	lambdabot	 (("a","bc"),("",""))
2021-07-17 21:41:31	int-e	(So maybe use splitAt instead of the x:suf pattern.)
2021-07-17 21:41:39	maerwald	was there a question yet?
2021-07-17 21:41:45	davean	No
2021-07-17 21:42:09	Guest14	Ok I will give that a try thanks
2021-07-17 21:42:10	int-e	They described a problem, close enough.
2021-07-17 21:42:35	maerwald	They also described the answer
2021-07-17 21:42:38	maerwald	"there is no head"
2021-07-17 21:42:47	int-e	@where paste
2021-07-17 21:42:47	lambdabot	Help us help you: please paste full code, input and/or output at e.g. https://paste.tomsmeding.com
2021-07-17 21:43:04	int-e	maerwald: That's the reason, but not a solution for the problem?
2021-07-17 21:43:06	 *	int-e shrugs
2021-07-17 21:43:10	maerwald	So my answer is: yes
2021-07-17 21:43:28	int-e	Well, so sorry for trying to be helpful.
2021-07-17 21:43:33	<--	dajoer (~david@user/gvx) has quit (Quit: leaving)
2021-07-17 21:44:08	<--	Ariakenom__ (~Ariakenom@c83-255-154-140.bredband.tele2.se) has quit (Ping timeout: 255 seconds)
2021-07-17 21:44:09	davean	int-e: oh do be helpful
2021-07-17 21:45:04	<--	mnrmnaugh (~mnrmnaugh@pool-96-252-87-182.bstnma.fios.verizon.net) has left #haskell (Leaving)
2021-07-17 21:45:14	Guest14	int-e that worked thank you
2021-07-17 21:46:19	-->	darius-os_ (uid508861@id-508861.stonehaven.irccloud.com) has joined #haskell
2021-07-17 21:50:42	texasmynsted	thank you boxscape 
2021-07-17 21:51:29	texasmynsted	Sounds like optics or vinyl for now
2021-07-17 21:51:44	<--	Guest14 (~Guest14@76-236-222-208.lightspeed.tukrga.sbcglobal.net) has quit (Quit: Client closed)
2021-07-17 21:52:07	<--	merijn (~merijn@83-160-49-249.ip.xs4all.nl) has quit (Ping timeout: 258 seconds)
2021-07-17 21:53:04	-->	Ariakenom__ (~Ariakenom@c83-255-154-140.bredband.tele2.se) has joined #haskell
2021-07-17 21:54:27	-->	Guest14 (~Guest14@76-236-222-208.lightspeed.tukrga.sbcglobal.net) has joined #haskell
2021-07-17 21:57:27	<--	brian_da_mage (~Neuromanc@user/briandamag) has quit (Ping timeout: 255 seconds)
2021-07-17 21:57:58	-->	oso (~oso@2601:58c:c080:a950:e67d:b4e2:c5be:433f) has joined #haskell
2021-07-17 22:00:57	-->	eggplantade (~Eggplanta@108-201-191-115.lightspeed.sntcca.sbcglobal.net) has joined #haskell
2021-07-17 22:01:11	sm	g'day all. Speaking of optics.. you experienced [lens] coders, do you find it good or bad for (a) fields and (b) lenses to be visually disctinct from other kinds of bindings (functions, "variables") ? As in eg _field/lens_, field_/lens__, _field/lensL, .... ?
2021-07-17 22:01:57	<--	Ariakenom__ (~Ariakenom@c83-255-154-140.bredband.tele2.se) has quit (Ping timeout: 255 seconds)
2021-07-17 22:02:24	sm	I feel it would be good overall, for avoiding collisions and for human comprehension . But I don't have a lot of lens experience
2021-07-17 22:03:02	<--	eggplantade (~Eggplanta@108-201-191-115.lightspeed.sntcca.sbcglobal.net) has quit (Remote host closed the connection)
2021-07-17 22:03:18	<--	norias (~jaredm@c-98-219-195-163.hsd1.pa.comcast.net) has quit (Ping timeout: 255 seconds)
2021-07-17 22:03:20	-->	eggplantade (~Eggplanta@108-201-191-115.lightspeed.sntcca.sbcglobal.net) has joined #haskell
2021-07-17 22:04:12	-->	Gurkenglas (~Gurkengla@dslb-002-203-144-156.002.203.pools.vodafone-ip.de) has joined #haskell
2021-07-17 22:06:33	-->	Ariakenom__ (~Ariakenom@c83-255-154-140.bredband.tele2.se) has joined #haskell
2021-07-17 22:06:59	-->	retroid_ (~retro@97e2ba5d.skybroadband.com) has joined #haskell
2021-07-17 22:08:11	<--	smichel17 (~smichel17@c-73-68-217-18.hsd1.ma.comcast.net) has quit (Quit: smichel17)
2021-07-17 22:10:10	maerwald	can you derive LabelOptic with deriving via for an inner type? 
2021-07-17 22:11:05	<--	retro_ (~retro@97e2ba5d.skybroadband.com) has quit (Ping timeout: 268 seconds)
2021-07-17 22:11:42	<--	retroid_ (~retro@97e2ba5d.skybroadband.com) has quit (Ping timeout: 268 seconds)
2021-07-17 22:12:24	-->	retroid_ (~retro@97e2ba5d.skybroadband.com) has joined #haskell
2021-07-17 22:12:50	oso	xpost from #haskell-beginners:
2021-07-17 22:12:52	oso	I'm passing around a type synonym for Int, but in reality the only constraint it needs to  follow is that it's hashable. what constructor do i use for this? my brain says go from `type UID = Int` to `data UID a = Hashable a` but that's very not correct, and google isn't helping much
2021-07-17 22:13:21	oso	nvm sorry got an answer there
2021-07-17 22:18:56	-->	merijn (~merijn@83-160-49-249.ip.xs4all.nl) has joined #haskell
2021-07-17 22:19:57	-->	lavaman (~lavaman@98.38.249.169) has joined #haskell
2021-07-17 22:20:11	<--	Guest14 (~Guest14@76-236-222-208.lightspeed.tukrga.sbcglobal.net) has quit (Quit: Client closed)
2021-07-17 22:21:02	<--	favonia (~favonia@user/favonia) has quit (Ping timeout: 255 seconds)
2021-07-17 22:21:26	-->	favonia (~favonia@user/favonia) has joined #haskell
2021-07-17 22:22:47	<--	cheater (~Username@user/cheater) has quit (Remote host closed the connection)
2021-07-17 22:23:50	-->	machinedgod (~machinedg@24.105.81.50) has joined #haskell
2021-07-17 22:24:38	glguy	oso, if you just need to know that something is hashable you'd use it like: stuff :: Hashable a => a -> b -> c
2021-07-17 22:24:39	<--	lavaman (~lavaman@98.38.249.169) has quit (Ping timeout: 268 seconds)
2021-07-17 22:24:39	<--	merijn (~merijn@83-160-49-249.ip.xs4all.nl) has quit (Ping timeout: 268 seconds)
2021-07-17 22:25:19	glguy	If a parameter is the uid parameter you can document that like:  stuff :: Hashable uid => uid {- ^ the UID -} -> etc
2021-07-17 22:25:35	oso	I was trying to do that while also using types to keep my signatures from becoming unwieldy, but first i'll just worry about getting the code working
2021-07-17 22:25:43	<--	keutoi (~keutoi@157.48.202.216) has quit (Quit: leaving)
2021-07-17 22:25:53	<--	falafel (~falafel@pool-96-255-70-50.washdc.fios.verizon.net) has quit (Ping timeout: 268 seconds)
2021-07-17 22:25:58	-->	burnsidesLlama (~burnsides@dhcp168-011.wadham.ox.ac.uk) has joined #haskell
2021-07-17 22:26:05	-->	cheater (~Username@user/cheater) has joined #haskell
2021-07-17 22:26:22	glguy	the documentation for parameters goes in the haddock comments rather than type synonyms
2021-07-17 22:26:43	oso	mmk
2021-07-17 22:27:00	<--	chris_ (~chris@81.96.113.213) has quit (Remote host closed the connection)
2021-07-17 22:27:52	-->	burnside_ (~burnsides@dhcp168-011.wadham.ox.ac.uk) has joined #haskell
2021-07-17 22:27:55	-->	smichel17 (~smichel17@2601:193:8300:4b9::600) has joined #haskell
2021-07-17 22:28:07	<--	burnsidesLlama (~burnsides@dhcp168-011.wadham.ox.ac.uk) has quit (Read error: Connection reset by peer)
2021-07-17 22:30:31	<--	arjun (~user@user/arjun) has quit (Ping timeout: 250 seconds)
2021-07-17 22:31:33	<--	mikoto-chan (~mikoto-ch@ip-213-49-189-31.dsl.scarlet.be) has quit (Read error: Connection reset by peer)
2021-07-17 22:32:18	-->	mikoto-chan (~mikoto-ch@ip-213-49-189-31.dsl.scarlet.be) has joined #haskell
2021-07-17 22:35:41	dsal	oso: It's tempting to put constraints in the type definitions, but if you take a look at, for example, `Data.Map.Strict` you'll see the type definition is just `data Map k a`.  You'd think k would always have to be ordered, but that's not the case.  You can create and work on maps that have unorderable keys when you don't do things that require ordering.  e.g.:
2021-07-17 22:35:42	dsal	> M.elems $ (* 2) <$> M.singleton id 3
2021-07-17 22:35:43	lambdabot	 [6]
2021-07-17 22:37:10	dsal	The idea is that you only have to constrain things where they actually need to be constrained.  The Functor instance, e.g., doesn't care about the keys at all, so why should it require they're ordered?
2021-07-17 22:38:00	-->	falafel (~falafel@pool-96-255-70-50.washdc.fios.verizon.net) has joined #haskell
2021-07-17 22:39:25	<--	Lycurgus (~juan@cpe-45-46-140-49.buffalo.res.rr.com) has quit (Quit: Exeunt)
2021-07-17 22:41:52	-->	waleee (~waleee@2001:9b0:216:8200:d457:9189:7843:1dbd) has joined #haskell
2021-07-17 22:42:32	-->	dyeplexer (~dyeplexer@user/dyeplexer) has joined #haskell
2021-07-17 22:43:45	oso	got it working \o/
2021-07-17 22:43:47	oso	thank you
2021-07-17 22:45:07	-->	tzh (~tzh@c-24-21-73-154.hsd1.or.comcast.net) has joined #haskell
2021-07-17 22:46:22	-->	nate1 (~nate@108-233-125-227.lightspeed.sntcca.sbcglobal.net) has joined #haskell
2021-07-17 22:51:49	-->	merijn (~merijn@83-160-49-249.ip.xs4all.nl) has joined #haskell
2021-07-17 22:52:00	-->	mnrmnaugh (~mnrmnaugh@pool-96-252-87-182.bstnma.fios.verizon.net) has joined #haskell
2021-07-17 22:56:35	<--	Null_A (~null_a@2601:645:8700:2290:b55a:33c2:1e1d:f229) has quit (Remote host closed the connection)
2021-07-17 22:57:45	<--	falafel (~falafel@pool-96-255-70-50.washdc.fios.verizon.net) has quit (Ping timeout: 255 seconds)
2021-07-17 22:58:36	-->	Sgeo (~Sgeo@user/sgeo) has joined #haskell
2021-07-17 23:11:25	-->	Pickchea (~private@user/pickchea) has joined #haskell
2021-07-17 23:12:20	-->	shapr (~user@pool-100-36-247-68.washdc.fios.verizon.net) has joined #haskell
2021-07-17 23:13:14	<--	mcfrdy (~mcfrdy@user/mcfrdy) has quit (Ping timeout: 255 seconds)
2021-07-17 23:14:09	<--	mjs2600 (~mjs2600@c-24-91-3-49.hsd1.vt.comcast.net) has quit (Ping timeout: 258 seconds)
2021-07-17 23:14:25	-->	mcfrdy (~mcfrdy@45.67.96.126) has joined #haskell
2021-07-17 23:14:25	<--	mcfrdy (~mcfrdy@45.67.96.126) has quit (Changing host)
2021-07-17 23:14:25	-->	mcfrdy (~mcfrdy@user/mcfrdy) has joined #haskell
2021-07-17 23:16:09	hololeap	so, I figured out a way to make a function with an arbitrary number of arguments using type families and type-level lists. but, I have to wonder ... has someone already made this and put it on hackage?
2021-07-17 23:17:04	-->	lavaman (~lavaman@98.38.249.169) has joined #haskell
2021-07-17 23:17:46	texasmynsted	wait, why do you want a function with an arbitrary number of arguments?
2021-07-17 23:18:31	<--	takuan (~takuan@178-116-218-225.access.telenet.be) has quit (Remote host closed the connection)
2021-07-17 23:19:03	c_wraith	usually to cover for a lack of other expressiveness
2021-07-17 23:19:09	c_wraith	printf is a common example
2021-07-17 23:19:12	texasmynsted	Seems to me ideally a function should have exactly one argument
2021-07-17 23:19:19	c_wraith	We can't write the type it actually has in Haskell
2021-07-17 23:19:25	c_wraith	Because it's a dependent type
2021-07-17 23:19:52	c_wraith	So varargs lets us do it anyway and fail at runtime if the programmer got it wrong
2021-07-17 23:20:07	texasmynsted	printf solves a problem in a particular way that I think could be solved better, differently 
2021-07-17 23:20:18	c_wraith	differently?  sure.  Better?  Not really.
2021-07-17 23:20:21	hololeap	the motivation was because I had a typeclass with a function, and I encountered some outliers that needed extra arguments passed to that function
2021-07-17 23:20:47	texasmynsted	c_wraith: I am not convinced 
2021-07-17 23:20:48	hololeap	I'd have to write up a blog post or something to get into all the details
2021-07-17 23:20:57	Rembane	hololeap: Do it! :D
2021-07-17 23:21:08	texasmynsted	yes, that would be a good read
2021-07-17 23:21:15	c_wraith	printf is *really* good at doing exactly what it's intended for.  Compactly specifying output formatted for monospace devices.
2021-07-17 23:21:33	texasmynsted	like regular expressions?
2021-07-17 23:21:42	c_wraith	honestly, it's more useful
2021-07-17 23:22:01	c_wraith	regular expressions have to involve things like capturing group to really be useful, and those complicate APIs tremendously
2021-07-17 23:22:05	c_wraith	printf has no such problems
2021-07-17 23:22:20	texasmynsted	Right. I think regular expressions work great but are terrible and the problem is better solved differently 
2021-07-17 23:22:46	EvanR	compare and contrast serious uses of printf with the expanded version, replicate that across a code base like 50 times and compare xD
2021-07-17 23:23:12	EvanR	also, printf for debugging
2021-07-17 23:23:25	EvanR	debugging would be harsher without it
2021-07-17 23:23:56	<--	merijn (~merijn@83-160-49-249.ip.xs4all.nl) has quit (Ping timeout: 252 seconds)
2021-07-17 23:24:27	EvanR	I'm more interested with this case of some function sometimes needing more arguments
2021-07-17 23:26:04	texasmynsted	I am still going with functions should have exactly one argument 
2021-07-17 23:26:31	hololeap	I mean... they do, technically.
2021-07-17 23:27:24	-->	Null_A (~null_a@2601:645:8700:2290:b55a:33c2:1e1d:f229) has joined #haskell
2021-07-17 23:27:38	texasmynsted	yes
2021-07-17 23:28:02	EvanR	if the difference is between argument type (A,B) and (A,B,C) it's about argument type and not number
2021-07-17 23:28:23	texasmynsted	Okay now we are getting somewhere
2021-07-17 23:30:32	-->	MorrowM (~Morrow@bzq-110-168-31-106.red.bezeqint.net) has joined #haskell
2021-07-17 23:30:36	<--	azeem (~azeem@dynamic-adsl-94-34-31-95.clienti.tiscali.it) has quit (Ping timeout: 265 seconds)
2021-07-17 23:30:57	<--	johnw (~johnw@76-234-69-149.lightspeed.frokca.sbcglobal.net) has quit (Ping timeout: 245 seconds)
2021-07-17 23:31:47	<--	Morrow (~Morrow@bzq-110-168-31-106.red.bezeqint.net) has quit (Ping timeout: 258 seconds)
2021-07-17 23:33:07	-->	azeem (~azeem@176.201.25.252) has joined #haskell
2021-07-17 23:35:12	--	irc: disconnected from server
2021-07-17 23:35:19	-->	amanr (~therojjha@20.204.87.0) has joined #haskell
2021-07-17 23:35:19	--	Topic for #haskell is "https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org | Paste code/errors: https://paste.tomsmeding.com | tunes.org-style logging should be coming soon | Logs: https://ircbrowse.tomsmeding.com/browse/lchaskell"
2021-07-17 23:35:19	--	Topic set by geekosaur (~geekosaur@xmonad/geekosaur) on Mon, 14 Jun 2021 05:16:14
2021-07-17 23:35:19	--	Channel #haskell: 712 nicks (1 op, 0 voices, 711 normals)
2021-07-17 23:35:19	***	Buffer Playback...
2021-07-17 23:35:19	arkanoid	[10:23:16] the Error monad link is broken https://wiki.haskell.org/Errormonad.html
2021-07-17 23:35:19	kuribas	[10:45:22] How does haskell compare to other functional languages?  Looking a bit at SML and OCaml, it seems that haskell has far more libraries, and is more practical for real world projects (other than compilers etc).
2021-07-17 23:35:19	kuribas	[10:46:31] Of course scala and clojure are also popular, but I don't consider clojure a real functional language, it's more a lisp derivative.  And Scala is mostly multiparadigm, and also complex and overengineerd.
2021-07-17 23:35:19	arahael	[10:47:48] kuribas: I use haskell for most of my private hobby/side projects.  It's awesule, but I've used F# and Swift, which are somewhat OCaml-inspired.
2021-07-17 23:35:19	arahael	[10:48:25] kuribas: The biggest most profound difference with Haskell is that it's *lazy*, and has a really really good type system, but in practice that it's lazy makes a big difference to how you use haskell.
2021-07-17 23:35:19	kuribas	[10:48:54] arahael: how much libraries are there for F#?  Or does it just use the C# ecosystem?
2021-07-17 23:35:19	arahael	[10:49:05] F# is just another .NET language, really, yeah.
2021-07-17 23:35:19	arahael	[10:49:17] As is C#. :)
2021-07-17 23:35:19	kuribas	[10:49:20] doesn't that mean that most libraries aren't really made for FP?
2021-07-17 23:35:19	arahael	[10:50:00] Kinda.  The way F# copes with nulls is interesting. (It assumes there aren't any).
2021-07-17 23:35:19	kuribas	[10:50:41] then how do you test if a function returns null?
2021-07-17 23:35:19	arahael	[10:51:33] kuribas: That's a trap, yeah.  In earlier versions, you'd check for it explicitly, and the compiler lets you. But then, the compiler *elides* that check because it thinks better.
2021-07-17 23:35:19	arahael	[10:51:44] Hopefully they've changed that now.
2021-07-17 23:35:19	arahael	[10:53:33] Looks like they've changed it - suggesting instead to use pattern matching.  Far better: https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/values/null-values
2021-07-17 23:35:19	arahael	[10:53:59] But anyway, one difference is that Haskell is lazy, so your functions must not have side effects.
2021-07-17 23:35:19	arahael	[10:54:30] And since that practice is so strictly encouraged (otherwise you risk loosing your sanity), that has a flow-on effect to all of haskell's libraries, too.
2021-07-17 23:35:19	DigitalKiwi	[10:55:34] haskell is non-strict
2021-07-17 23:35:19	DigitalKiwi	[10:55:52] https://wiki.haskell.org/Lazy_vs._non-strict
2021-07-17 23:35:19	arahael	[10:56:01] Yeah - more accurate - thanks for that.
2021-07-17 23:35:19	DigitalKiwi	[10:56:34] speaking only for myself haskell programmers are lazy ;)
2021-07-17 23:35:19	arahael	[10:58:05] Hmm. :)
2021-07-17 23:35:19	DigitalKiwi	[11:01:36] and obsesssed with bottoms
2021-07-17 23:35:19	 *	DigitalKiwi [11:02:01] drops mic
2021-07-17 23:35:19	Rembane	[11:03:21] I like lazy bottoms and I cannot lie.
2021-07-17 23:35:19	 *	arahael [11:05:07] suddenly realises why bottom is drawn like _|_
2021-07-17 23:35:19	DigitalKiwi	[11:06:04] dibblego twitter avatar lolol
2021-07-17 23:35:19	kuribas	[11:08:21] arahael: so haskell is the only language that doesn't let you get away coding imperative OO in it?
2021-07-17 23:35:19	kuribas	[11:09:07] Although imperative style is still quite possible in haskell.  OO on the other hand is pretty hard.
2021-07-17 23:35:19	dibblego	[11:09:35] DigitalKiwi: that's BUMFISH
2021-07-17 23:35:19	DigitalKiwi	[11:10:01] is that a new operator
2021-07-17 23:35:19	dibblego	[11:11:41] no, it's a pre-landing checklist
2021-07-17 23:35:19	arahael	[11:13:08] Heh.
2021-07-17 23:35:19	arahael	[11:13:36] kuribas: If it's subtyping you're referring to, no, I don't think haskell has that.
2021-07-17 23:35:19	arahael	[11:13:58] kuribas: It does have classes and instances, though, but they behave quite differently.
2021-07-17 23:35:19	kuribas	[11:14:06] And that's a good thing...
2021-07-17 23:35:19	 *	arahael [11:14:25] thinks so.
2021-07-17 23:35:19	DigitalKiwi	[11:14:37] https://www.parsonsmatt.org/2017/02/17/object_oriented_programming_in_haskell.html
2021-07-17 23:35:19	DigitalKiwi	[11:16:43] https://hackage.haskell.org/package/hoop
2021-07-17 23:35:19	DigitalKiwi	[11:16:56] cue bot "haskell can do that!"
2021-07-17 23:35:19	dibblego	[11:22:23] DigitalKiwi: https://flightscope.gitlab.io/aircraft/checklist/eurofox.pdf page 1, top-right
2021-07-17 23:35:19	kuribas	[11:58:55] I've been accused of being a haskell lanuage zealot.  But actually I am interested in other languages (logic, FP, dependently typed, etc...).  It just doesn't seem to be useful to push for other languages that I know less...
2021-07-17 23:35:19	kuribas	[11:59:21] I could recommend F# instead of haskell, but I don't know it that well, so there is less benefit IMO...
2021-07-17 23:35:19	kuribas	[12:04:48] Every time I come with rational arguments, I get a reply like "But I don't like types, they get in the way".  Or "programming languages don't matter, business logic does".  Or "I don't care it's more robust, we want to move fast and solve bugs as we go".
2021-07-17 23:35:19	dibblego	[12:18:06] get used to it
2021-07-17 23:35:19	tom__	[12:18:47] kuribas: I feel your pain
2021-07-17 23:35:19	tom__	[12:19:43] "Types get in the way" then spends three hours NULL chasing
2021-07-17 23:35:19	kuribas	[12:20:50] tom__: exactly!  I spend far more time thinking about types in clojure than in haskell.
2021-07-17 23:35:19	maerwald	[12:21:11] types can get in the way, especially since haskell lacks structural typing
2021-07-17 23:35:19	tom__	[12:21:34] haha sometimes you want types to get in the way
2021-07-17 23:35:19	maerwald	[12:21:51] I know of at least one Haskell dev who now works full-time with typescript and doesn't regret it
2021-07-17 23:35:19	maerwald	[12:22:09] I probably wouldn't, but it's a valid position
2021-07-17 23:35:19	tom__	[12:22:55] Clojure to me is just javascript with some immutability
2021-07-17 23:35:19	kuribas	[12:23:22] maerwald: I find that often, it just amounts to having a bit more boilerplate.  Or having duplicate type definitions.
2021-07-17 23:35:19	maerwald	[12:23:40] it can be a *lot* of boilerplate
2021-07-17 23:35:19	maerwald	[12:24:00] and prohibits you of expressing certain relationships between data
2021-07-17 23:35:19	tom__	[12:24:19] Haskell, Rust and Julia - desert island stack
2021-07-17 23:35:19	tom__	[12:24:37] Havent tried the latter two :D
2021-07-17 23:35:19	maerwald	[12:24:58] class based solutions don't work well when you need an *actual* data type for serialisation
2021-07-17 23:35:19	maerwald	[12:25:45] typescript is surprisingly simple and powerful on these matters... certainly less elegant and unsound in a few places, but that's the tradeoff the make
2021-07-17 23:35:19	kuribas	[12:26:10] tom__: rust is only my "to learn list" :)
2021-07-17 23:35:19	kuribas	[12:26:42] maerwald: you can be less elegant and unsound in haskell too...
2021-07-17 23:35:19	maerwald	[12:27:02] kuribas: yeah, but that usually involves MORE complexity, not less
2021-07-17 23:35:19	maerwald	[12:27:10] so the opposite of typescript
2021-07-17 23:35:19	tom__	[12:27:22] You can be and then people who don't understand what a theoretical model is say that it must mean Haskell is pointless
2021-07-17 23:35:19	kuribas	[12:28:12] maerwald: I don't agree
2021-07-17 23:35:19	maerwald	[12:28:47] well, you *can* do some forms of structural typing/subtyping, but it all ends in esoteric libraries
2021-07-17 23:35:19	kuribas	[12:29:00] maerwald: so don't do it.
2021-07-17 23:35:19	maerwald	[12:29:03] while you get all that in TS for free without complexity
2021-07-17 23:35:19	maerwald	[12:29:45] well, I'm not commenting on which language is better, I'm just commenting on "types can get in the way", because they can
2021-07-17 23:35:19	kuribas	[12:29:55] maerwald: plenty of ways to get around that: 1) partially applied functions (the Endo trick), create a new type with some of the fields.  3) just make the fields all Maybe.
2021-07-17 23:35:19	kuribas	[12:30:56] maerwald: there is a difference between "the types sometimes get in the way", and "the types always get in the way", the latter is what they seem to be implying.
2021-07-17 23:35:19	maerwald	[12:31:02] 1) difficult for serialisation, Show instances, debugging, ... 2) boilerplate, 3) unexpressive, because now you have two cases of `Maybe`
2021-07-17 23:35:19	kuribas	[12:32:02] You don't need two cases of Maybe
2021-07-17 23:35:19	kuribas	[12:32:44] and 4) just put default values.
2021-07-17 23:35:19	maerwald	[12:33:32] 1. there's no such value, because the computation doesn't return one for the given input, 2. there's no such value, because the computation can *never* return one
2021-07-17 23:35:19	maerwald	[12:33:45] now you also have to wonder: 3. there's a value, but there shouldn't be one
2021-07-17 23:35:19	maerwald	[12:33:47] oops
2021-07-17 23:35:19	kuribas	[12:33:47] IMO, the more you want correctness, the more you are restricted in what you write.  It has nothing to do with types (directly).
2021-07-17 23:35:19	kuribas	[12:34:28] maerwald: if you grab to clojure, you don't care anyway...
2021-07-17 23:35:19	maerwald	[12:34:48] default values.. what's my default account balance? :p
2021-07-17 23:35:19	dibblego	[12:34:54] like I said, get used to it
2021-07-17 23:35:19	tom__	[12:35:20] ^ yes and get used to makeNegative = (*) -1
2021-07-17 23:35:19	kuribas	[12:35:49] Which is my point, haskell can be a nice unsafe language to.  Just make a big sum type, and partial functions over it (don't forget to add error messages though...).
2021-07-17 23:35:19	maerwald	[12:36:21] well, with structural typing you don't need to be partial
2021-07-17 23:35:19	int-e	[12:36:25] Or unsafeCoerce everything and program untyped lambda calculus? :)
2021-07-17 23:35:19	arahael	[12:36:48] kuribas: Mind you, Clojure seems to offer alternative methods to allow you to type ocrrect code.  In particular, Clojure seems to have a fantastic runtime repl.
2021-07-17 23:35:19	arahael	[12:37:15] kuribas: Such that you're running the live program and debugging it and replacing functions on the fly.
2021-07-17 23:35:19	int-e	[12:37:26] I like types, they prevent some of the more embarrassing programming errors from being run as code.
2021-07-17 23:35:19	tom__	[12:37:44] Revenge is forcing them to write a web app in the Lean proof assistant fully verified.
2021-07-17 23:35:19	tom__	[12:37:49] It has IO.
2021-07-17 23:35:19	maerwald	[12:38:25] right... clojure: forget a closing  bracket, code still compiles, but doesn't compute prime numbers... instead it compiles to a chess engine
2021-07-17 23:35:19	tom__	[12:38:42] haha
2021-07-17 23:35:19	maerwald	[12:38:45] type safe? Yeah maybe. But.
2021-07-17 23:35:19	kuribas	[12:38:48] arahael: I think you never actually used clojure?
2021-07-17 23:35:19	int-e	[12:39:03] tom__: That's deep in "overdoing it" territory. At least if the specification is anything more elaborate than "something in, something out", and even that may be tricky if you interpret it as a promise to fulfil request in finite time.
2021-07-17 23:35:19	kuribas	[12:39:26] arahael: it's a very mediocre runtime IMO, compared to java.  Error messages are nearly incomprehensible.  Tracing is nice though...
2021-07-17 23:35:19	tom__	[12:39:39] int-e: Yeah pointless torture :)
2021-07-17 23:35:19	maerwald	[12:39:50] the only upside of clojure is interactive development
2021-07-17 23:35:19	tom__	[12:40:08] The haskell compiler feels pretty interactive
2021-07-17 23:35:19	maerwald	[12:40:29] if HLS works, maybe
2021-07-17 23:35:19	arahael	[12:40:37] kuribas: Seemed to be effective enough.
2021-07-17 23:35:19	arahael	[12:40:53] But no, I haven't personally used it.
2021-07-17 23:35:19	maerwald	[12:41:00] but on the other hand: usually not. Compile times are too slow
2021-07-17 23:35:19	kuribas	[12:41:12] arahael: clojurists just have a different idea of "correct code".
2021-07-17 23:35:19	arahael	[12:41:15] I personally quite like ghcid.
2021-07-17 23:35:19	arahael	[12:41:27] kuribas: Indeed, but I think it's the process of discovery that they like.
2021-07-17 23:35:19	arahael	[12:41:57] kuribas: In haskell, we seem to prefer to test functions in isolation. Clojure people seem to prefer to test functions in the live system.
2021-07-17 23:35:19	maerwald	[12:42:00] if you're working on 300+ modules and your Type module has a whitespace change, you're gonna need to restart cabal a few times, because your machine OOMed due to TH
2021-07-17 23:35:19	tom__	[12:42:18] Which library is recommended for sampling probability distributions?
2021-07-17 23:35:19	arahael	[12:42:42] maerwald: The amount of memory Haskell uses is crazy high.  Sadly, I find it way faster than Swift. :/
2021-07-17 23:35:19	kuribas	[12:45:45] arahael: lispers will boast about how easy it is to hot patch live systems.  They don't tell you that it becomes very hard to see who changed what and when.
2021-07-17 23:35:19	kuribas	[12:46:05] arahael: so you'll end up with CI/CD anyway.  
2021-07-17 23:35:19	kuribas	[12:46:34] However a theoretically, a "live" programming environment with integrated version control could be nice.
2021-07-17 23:35:19	kuribas	[12:46:44] I don't know if that ever has been done.
2021-07-17 23:35:19	maerwald	[12:47:32] https://hackage.haskell.org/package/optics-th-0.4/docs/Optics-TH.html#v:makeClassy
2021-07-17 23:35:19	maerwald	[12:47:34] https://hackage.haskell.org/package/optics-th-0.4/docs/Optics-TH.html#v:makeFieldsNoPrefix
2021-07-17 23:35:19	maerwald	[12:47:36] https://hackage.haskell.org/package/generic-optics-2.2.0.0/docs/Data-Generics-Product-Fields.html#t:HasField
2021-07-17 23:35:19	maerwald	[12:47:38] which one of those to pick?
2021-07-17 23:35:19	maerwald	[12:49:00] HasField is kinda cool with those neat type errors
2021-07-17 23:35:19	boxscape	[15:15:35] maerwald: the TH versions say "This method of optics generation should only be used when migrating an existing codebase from the lens library to optics"
2021-07-17 23:35:19	boxscape	[15:15:51] maerwald: this, my final answer is C
2021-07-17 23:35:19	boxscape	[15:15:56] s/this/thus
2021-07-17 23:35:19	maerwald	[15:16:07] HasField?
2021-07-17 23:35:19	boxscape	[15:16:46] yeah.. though I thought there was a version of that which uses OverloadedLabels
2021-07-17 23:35:19	maerwald	[15:17:20] HasField though doesn't allow arbitrary subtyping... it's a simple getter
2021-07-17 23:35:19	maerwald	[15:17:54] with makeClassy style classes you could descend deeper into the structure with the same getter
2021-07-17 23:35:19	boxscape	[15:18:30] maerwald: oh actually the TH version links to https://hackage.haskell.org/package/optics-core-0.4/docs/Optics-Label.html as preferred solution
2021-07-17 23:35:19	boxscape	[15:19:03] that's the OverloadedLabels version I was remembering
2021-07-17 23:35:19	maerwald	[15:22:44] so there you could also define custom LabelOptic instances that descend into a structure?
2021-07-17 23:35:19	boxscape	[15:23:27] that seems plausible but I haven't tried doing it
2021-07-17 23:35:19	maerwald	[15:23:47] I'm leaning towards makeClassy, but I'm not sure
2021-07-17 23:35:19	boxscape	[15:24:25] I like makeClassy, the main reason I would avoid it personally is that the documentation advises against it
2021-07-17 23:35:19	maerwald	[15:25:40] so what does LabelOptic give over HasField?
2021-07-17 23:35:19	texasmynsted	[15:26:17] What is the modern answer to haskell records? Lens?
2021-07-17 23:35:19	maerwald	[15:26:49] only difference I see is labelOptic is `Optic` and HasField is a `Lens`
2021-07-17 23:35:19	boxscape	[15:28:24] hm I'm not sure what the concrete differences are
2021-07-17 23:35:19	boxscape	[15:30:52] texasmynsted: there are a few answers to this: In the next version, OverloadedRecordDot is being introduces, which allows one to write something like `personA.company.name`. (Updates are a bit iffy but will improve over time.) In the meantime, lens is definitely still widely used, though optics is a replacement which aims to have better error messages. There is also some research going into row types, but that's further out.
2021-07-17 23:35:19	boxscape	[15:30:55] s/next version/next version of GHC
2021-07-17 23:35:19	boxscape	[15:32:08] (though regarding row types, the vinyl records package allows something similar today)
2021-07-17 23:35:19	Guest14	[16:03:05] Hello :)
2021-07-17 23:35:19	Guest14	[16:03:40] I am new to Haskell and am working through the Real World Haskell Book
2021-07-17 23:35:19	Guest14	[16:04:27] I have a basic question if anyone would care to listen
2021-07-17 23:35:19	allbery_b	[16:06:02] best to just ask it rather than asking to ask
2021-07-17 23:35:19	davean	[16:06:23] asking to ask is why I wasn't helping
2021-07-17 23:35:19	Guest14	[16:07:44] splitWith _ [] = []
2021-07-17 23:35:19	Guest14	[16:07:45] splitWith a xs = [pre ++ [x]] ++ next
2021-07-17 23:35:19	Guest14	[16:07:45]     where 
2021-07-17 23:35:19	Guest14	[16:07:46]         (pre, x:suf) = span a xs
2021-07-17 23:35:19	Guest14	[16:07:46]         next = splitWith a suf
2021-07-17 23:35:19	Guest14	[16:08:10] I have this program and I run into a problem with x:suf when span a xs is [] becuase there is no head
2021-07-17 23:35:19	int-e	[16:09:34] > let f = splitAt 1 in (f "abc", f "")
2021-07-17 23:35:19	lambdabot	[16:09:36]  (("a","bc"),("",""))
2021-07-17 23:35:19	int-e	[16:11:31] (So maybe use splitAt instead of the x:suf pattern.)
2021-07-17 23:35:19	maerwald	[16:11:39] was there a question yet?
2021-07-17 23:35:19	davean	[16:11:45] No
2021-07-17 23:35:19	Guest14	[16:12:09] Ok I will give that a try thanks
2021-07-17 23:35:19	int-e	[16:12:10] They described a problem, close enough.
2021-07-17 23:35:19	maerwald	[16:12:35] They also described the answer
2021-07-17 23:35:19	maerwald	[16:12:38] "there is no head"
2021-07-17 23:35:19	int-e	[16:12:47] @where paste
2021-07-17 23:35:19	lambdabot	[16:12:47] Help us help you: please paste full code, input and/or output at e.g. https://paste.tomsmeding.com
2021-07-17 23:35:19	int-e	[16:13:04] maerwald: That's the reason, but not a solution for the problem?
2021-07-17 23:35:19	 *	int-e [16:13:06] shrugs
2021-07-17 23:35:19	maerwald	[16:13:10] So my answer is: yes
2021-07-17 23:35:19	int-e	[16:13:28] Well, so sorry for trying to be helpful.
2021-07-17 23:35:19	davean	[16:14:09] int-e: oh do be helpful
2021-07-17 23:35:19	Guest14	[16:15:14] int-e that worked thank you
2021-07-17 23:35:19	texasmynsted	[16:20:42] thank you boxscape 
2021-07-17 23:35:19	texasmynsted	[16:21:29] Sounds like optics or vinyl for now
2021-07-17 23:35:19	sm	[16:31:11] g'day all. Speaking of optics.. you experienced [lens] coders, do you find it good or bad for (a) fields and (b) lenses to be visually disctinct from other kinds of bindings (functions, "variables") ? As in eg _field/lens_, field_/lens__, _field/lensL, .... ?
2021-07-17 23:35:19	sm	[16:32:24] I feel it would be good overall, for avoiding collisions and for human comprehension . But I don't have a lot of lens experience
2021-07-17 23:35:19	maerwald	[16:40:10] can you derive LabelOptic with deriving via for an inner type? 
2021-07-17 23:35:19	oso	[16:42:50] xpost from #haskell-beginners:
2021-07-17 23:35:19	oso	[16:42:52] I'm passing around a type synonym for Int, but in reality the only constraint it needs to  follow is that it's hashable. what constructor do i use for this? my brain says go from `type UID = Int` to `data UID a = Hashable a` but that's very not correct, and google isn't helping much
2021-07-17 23:35:19	oso	[16:43:21] nvm sorry got an answer there
2021-07-17 23:35:19	glguy	[16:54:37] oso, if you just need to know that something is hashable you'd use it like: stuff :: Hashable a => a -> b -> c
2021-07-17 23:35:19	glguy	[16:55:19] If a parameter is the uid parameter you can document that like:  stuff :: Hashable uid => uid {- ^ the UID -} -> etc
2021-07-17 23:35:19	oso	[16:55:35] I was trying to do that while also using types to keep my signatures from becoming unwieldy, but first i'll just worry about getting the code working
2021-07-17 23:35:19	glguy	[16:56:22] the documentation for parameters goes in the haddock comments rather than type synonyms
2021-07-17 23:35:19	oso	[16:56:43] mmk
2021-07-17 23:35:19	dsal	[17:05:40] oso: It's tempting to put constraints in the type definitions, but if you take a look at, for example, `Data.Map.Strict` you'll see the type definition is just `data Map k a`.  You'd think k would always have to be ordered, but that's not the case.  You can create and work on maps that have unorderable keys when you don't do things that require ordering.  e.g.:
2021-07-17 23:35:19	dsal	[17:05:42] > M.elems $ (* 2) <$> M.singleton id 3
2021-07-17 23:35:19	lambdabot	[17:05:43]  [6]
2021-07-17 23:35:19	dsal	[17:07:10] The idea is that you only have to constrain things where they actually need to be constrained.  The Functor instance, e.g., doesn't care about the keys at all, so why should it require they're ordered?
2021-07-17 23:35:19	oso	[17:13:45] got it working \o/
2021-07-17 23:35:19	oso	[17:13:47] thank you
2021-07-17 23:35:19	hololeap	[17:46:09] so, I figured out a way to make a function with an arbitrary number of arguments using type families and type-level lists. but, I have to wonder ... has someone already made this and put it on hackage?
2021-07-17 23:35:19	texasmynsted	[17:47:46] wait, why do you want a function with an arbitrary number of arguments?
2021-07-17 23:35:19	c_wraith	[17:49:03] usually to cover for a lack of other expressiveness
2021-07-17 23:35:19	c_wraith	[17:49:09] printf is a common example
2021-07-17 23:35:19	texasmynsted	[17:49:12] Seems to me ideally a function should have exactly one argument
2021-07-17 23:35:19	c_wraith	[17:49:19] We can't write the type it actually has in Haskell
2021-07-17 23:35:19	c_wraith	[17:49:25] Because it's a dependent type
2021-07-17 23:35:19	c_wraith	[17:49:51] So varargs lets us do it anyway and fail at runtime if the programmer got it wrong
2021-07-17 23:35:19	texasmynsted	[17:50:07] printf solves a problem in a particular way that I think could be solved better, differently 
2021-07-17 23:35:19	c_wraith	[17:50:18] differently?  sure.  Better?  Not really.
2021-07-17 23:35:19	hololeap	[17:50:21] the motivation was because I had a typeclass with a function, and I encountered some outliers that needed extra arguments passed to that function
2021-07-17 23:35:19	texasmynsted	[17:50:47] c_wraith: I am not convinced 
2021-07-17 23:35:19	hololeap	[17:50:48] I'd have to write up a blog post or something to get into all the details
2021-07-17 23:35:19	Rembane	[17:50:57] hololeap: Do it! :D
2021-07-17 23:35:19	texasmynsted	[17:51:08] yes, that would be a good read
2021-07-17 23:35:19	c_wraith	[17:51:15] printf is *really* good at doing exactly what it's intended for.  Compactly specifying output formatted for monospace devices.
2021-07-17 23:35:19	texasmynsted	[17:51:32] like regular expressions?
2021-07-17 23:35:19	c_wraith	[17:51:42] honestly, it's more useful
2021-07-17 23:35:19	c_wraith	[17:52:01] regular expressions have to involve things like capturing group to really be useful, and those complicate APIs tremendously
2021-07-17 23:35:19	c_wraith	[17:52:05] printf has no such problems
2021-07-17 23:35:19	texasmynsted	[17:52:20] Right. I think regular expressions work great but are terrible and the problem is better solved differently 
2021-07-17 23:35:19	EvanR	[17:52:46] compare and contrast serious uses of printf with the expanded version, replicate that across a code base like 50 times and compare xD
2021-07-17 23:35:19	EvanR	[17:53:12] also, printf for debugging
2021-07-17 23:35:19	EvanR	[17:53:25] debugging would be harsher without it
2021-07-17 23:35:19	EvanR	[17:54:27] I'm more interested with this case of some function sometimes needing more arguments
2021-07-17 23:35:19	texasmynsted	[17:56:04] I am still going with functions should have exactly one argument 
2021-07-17 23:35:19	hololeap	[17:56:30] I mean... they do, technically.
2021-07-17 23:35:19	texasmynsted	[17:57:38] yes
2021-07-17 23:35:19	EvanR	[17:58:02] if the difference is between argument type (A,B) and (A,B,C) it's about argument type and not number
2021-07-17 23:35:19	texasmynsted	[17:58:23] Okay now we are getting somewhere
2021-07-17 23:35:19	***	Playback Complete.
2021-07-17 23:35:26	<--	flukiluke_ (~flukiluke@168.138.23.5) has quit (Ping timeout: 265 seconds)
2021-07-17 23:35:27	--	Channel created on Sun, 25 Apr 2021 01:04:39
2021-07-17 23:35:49	-->	flukiluke (~flukiluke@2603:c023:c000:6c7e:8945:ad24:9113:a962) has joined #haskell
2021-07-17 23:36:15	<--	elcaro (~anonymous@45.32.191.75) has quit (Ping timeout: 252 seconds)
2021-07-17 23:37:09	-->	elcaro (~anonymous@45.32.191.75) has joined #haskell
2021-07-17 23:37:14	--	irc: disconnected from server
2021-07-17 23:37:27	-->	amanr (~therojjha@20.204.87.0) has joined #haskell
2021-07-17 23:37:27	--	Topic for #haskell is "https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org | Paste code/errors: https://paste.tomsmeding.com | tunes.org-style logging should be coming soon | Logs: https://ircbrowse.tomsmeding.com/browse/lchaskell"
2021-07-17 23:37:27	--	Topic set by geekosaur (~geekosaur@xmonad/geekosaur) on Mon, 14 Jun 2021 05:16:14
2021-07-17 23:37:28	--	Channel #haskell: 712 nicks (1 op, 0 voices, 711 normals)
2021-07-17 23:37:28	***	Buffer Playback...
2021-07-17 23:37:28	arkanoid	[10:23:16] the Error monad link is broken https://wiki.haskell.org/Errormonad.html
2021-07-17 23:37:28	kuribas	[10:45:22] How does haskell compare to other functional languages?  Looking a bit at SML and OCaml, it seems that haskell has far more libraries, and is more practical for real world projects (other than compilers etc).
2021-07-17 23:37:28	kuribas	[10:46:31] Of course scala and clojure are also popular, but I don't consider clojure a real functional language, it's more a lisp derivative.  And Scala is mostly multiparadigm, and also complex and overengineerd.
2021-07-17 23:37:28	arahael	[10:47:48] kuribas: I use haskell for most of my private hobby/side projects.  It's awesule, but I've used F# and Swift, which are somewhat OCaml-inspired.
2021-07-17 23:37:28	arahael	[10:48:25] kuribas: The biggest most profound difference with Haskell is that it's *lazy*, and has a really really good type system, but in practice that it's lazy makes a big difference to how you use haskell.
2021-07-17 23:37:28	kuribas	[10:48:54] arahael: how much libraries are there for F#?  Or does it just use the C# ecosystem?
2021-07-17 23:37:28	arahael	[10:49:05] F# is just another .NET language, really, yeah.
2021-07-17 23:37:28	arahael	[10:49:17] As is C#. :)
2021-07-17 23:37:28	kuribas	[10:49:20] doesn't that mean that most libraries aren't really made for FP?
2021-07-17 23:37:28	arahael	[10:50:00] Kinda.  The way F# copes with nulls is interesting. (It assumes there aren't any).
2021-07-17 23:37:28	kuribas	[10:50:41] then how do you test if a function returns null?
2021-07-17 23:37:28	arahael	[10:51:33] kuribas: That's a trap, yeah.  In earlier versions, you'd check for it explicitly, and the compiler lets you. But then, the compiler *elides* that check because it thinks better.
2021-07-17 23:37:28	arahael	[10:51:44] Hopefully they've changed that now.
2021-07-17 23:37:28	arahael	[10:53:33] Looks like they've changed it - suggesting instead to use pattern matching.  Far better: https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/values/null-values
2021-07-17 23:37:28	arahael	[10:53:59] But anyway, one difference is that Haskell is lazy, so your functions must not have side effects.
2021-07-17 23:37:28	arahael	[10:54:30] And since that practice is so strictly encouraged (otherwise you risk loosing your sanity), that has a flow-on effect to all of haskell's libraries, too.
2021-07-17 23:37:28	DigitalKiwi	[10:55:34] haskell is non-strict
2021-07-17 23:37:28	DigitalKiwi	[10:55:52] https://wiki.haskell.org/Lazy_vs._non-strict
2021-07-17 23:37:28	arahael	[10:56:01] Yeah - more accurate - thanks for that.
2021-07-17 23:37:28	DigitalKiwi	[10:56:34] speaking only for myself haskell programmers are lazy ;)
2021-07-17 23:37:28	arahael	[10:58:05] Hmm. :)
2021-07-17 23:37:28	DigitalKiwi	[11:01:36] and obsesssed with bottoms
2021-07-17 23:37:28	 *	DigitalKiwi [11:02:01] drops mic
2021-07-17 23:37:28	Rembane	[11:03:21] I like lazy bottoms and I cannot lie.
2021-07-17 23:37:28	 *	arahael [11:05:07] suddenly realises why bottom is drawn like _|_
2021-07-17 23:37:28	DigitalKiwi	[11:06:04] dibblego twitter avatar lolol
2021-07-17 23:37:28	kuribas	[11:08:21] arahael: so haskell is the only language that doesn't let you get away coding imperative OO in it?
2021-07-17 23:37:28	kuribas	[11:09:07] Although imperative style is still quite possible in haskell.  OO on the other hand is pretty hard.
2021-07-17 23:37:28	dibblego	[11:09:35] DigitalKiwi: that's BUMFISH
2021-07-17 23:37:28	DigitalKiwi	[11:10:01] is that a new operator
2021-07-17 23:37:28	dibblego	[11:11:41] no, it's a pre-landing checklist
2021-07-17 23:37:28	arahael	[11:13:08] Heh.
2021-07-17 23:37:28	arahael	[11:13:36] kuribas: If it's subtyping you're referring to, no, I don't think haskell has that.
2021-07-17 23:37:28	arahael	[11:13:58] kuribas: It does have classes and instances, though, but they behave quite differently.
2021-07-17 23:37:28	kuribas	[11:14:06] And that's a good thing...
2021-07-17 23:37:28	 *	arahael [11:14:25] thinks so.
2021-07-17 23:37:28	DigitalKiwi	[11:14:37] https://www.parsonsmatt.org/2017/02/17/object_oriented_programming_in_haskell.html
2021-07-17 23:37:28	DigitalKiwi	[11:16:43] https://hackage.haskell.org/package/hoop
2021-07-17 23:37:28	DigitalKiwi	[11:16:56] cue bot "haskell can do that!"
2021-07-17 23:37:28	dibblego	[11:22:23] DigitalKiwi: https://flightscope.gitlab.io/aircraft/checklist/eurofox.pdf page 1, top-right
2021-07-17 23:37:28	kuribas	[11:58:55] I've been accused of being a haskell lanuage zealot.  But actually I am interested in other languages (logic, FP, dependently typed, etc...).  It just doesn't seem to be useful to push for other languages that I know less...
2021-07-17 23:37:28	kuribas	[11:59:21] I could recommend F# instead of haskell, but I don't know it that well, so there is less benefit IMO...
2021-07-17 23:37:28	kuribas	[12:04:48] Every time I come with rational arguments, I get a reply like "But I don't like types, they get in the way".  Or "programming languages don't matter, business logic does".  Or "I don't care it's more robust, we want to move fast and solve bugs as we go".
2021-07-17 23:37:28	dibblego	[12:18:06] get used to it
2021-07-17 23:37:28	tom__	[12:18:47] kuribas: I feel your pain
2021-07-17 23:37:28	tom__	[12:19:43] "Types get in the way" then spends three hours NULL chasing
2021-07-17 23:37:28	kuribas	[12:20:50] tom__: exactly!  I spend far more time thinking about types in clojure than in haskell.
2021-07-17 23:37:28	maerwald	[12:21:11] types can get in the way, especially since haskell lacks structural typing
2021-07-17 23:37:28	tom__	[12:21:34] haha sometimes you want types to get in the way
2021-07-17 23:37:28	maerwald	[12:21:51] I know of at least one Haskell dev who now works full-time with typescript and doesn't regret it
2021-07-17 23:37:28	maerwald	[12:22:09] I probably wouldn't, but it's a valid position
2021-07-17 23:37:28	tom__	[12:22:55] Clojure to me is just javascript with some immutability
2021-07-17 23:37:28	kuribas	[12:23:22] maerwald: I find that often, it just amounts to having a bit more boilerplate.  Or having duplicate type definitions.
2021-07-17 23:37:28	maerwald	[12:23:40] it can be a *lot* of boilerplate
2021-07-17 23:37:28	maerwald	[12:24:00] and prohibits you of expressing certain relationships between data
2021-07-17 23:37:28	tom__	[12:24:19] Haskell, Rust and Julia - desert island stack
2021-07-17 23:37:28	tom__	[12:24:37] Havent tried the latter two :D
2021-07-17 23:37:28	maerwald	[12:24:58] class based solutions don't work well when you need an *actual* data type for serialisation
2021-07-17 23:37:28	maerwald	[12:25:45] typescript is surprisingly simple and powerful on these matters... certainly less elegant and unsound in a few places, but that's the tradeoff the make
2021-07-17 23:37:28	kuribas	[12:26:10] tom__: rust is only my "to learn list" :)
2021-07-17 23:37:28	kuribas	[12:26:42] maerwald: you can be less elegant and unsound in haskell too...
2021-07-17 23:37:28	maerwald	[12:27:02] kuribas: yeah, but that usually involves MORE complexity, not less
2021-07-17 23:37:28	maerwald	[12:27:10] so the opposite of typescript
2021-07-17 23:37:28	tom__	[12:27:22] You can be and then people who don't understand what a theoretical model is say that it must mean Haskell is pointless
2021-07-17 23:37:28	kuribas	[12:28:12] maerwald: I don't agree
2021-07-17 23:37:28	maerwald	[12:28:47] well, you *can* do some forms of structural typing/subtyping, but it all ends in esoteric libraries
2021-07-17 23:37:28	kuribas	[12:29:00] maerwald: so don't do it.
2021-07-17 23:37:28	maerwald	[12:29:03] while you get all that in TS for free without complexity
2021-07-17 23:37:28	maerwald	[12:29:45] well, I'm not commenting on which language is better, I'm just commenting on "types can get in the way", because they can
2021-07-17 23:37:28	kuribas	[12:29:55] maerwald: plenty of ways to get around that: 1) partially applied functions (the Endo trick), create a new type with some of the fields.  3) just make the fields all Maybe.
2021-07-17 23:37:28	kuribas	[12:30:56] maerwald: there is a difference between "the types sometimes get in the way", and "the types always get in the way", the latter is what they seem to be implying.
2021-07-17 23:37:28	maerwald	[12:31:02] 1) difficult for serialisation, Show instances, debugging, ... 2) boilerplate, 3) unexpressive, because now you have two cases of `Maybe`
2021-07-17 23:37:28	kuribas	[12:32:02] You don't need two cases of Maybe
2021-07-17 23:37:28	kuribas	[12:32:44] and 4) just put default values.
2021-07-17 23:37:28	maerwald	[12:33:32] 1. there's no such value, because the computation doesn't return one for the given input, 2. there's no such value, because the computation can *never* return one
2021-07-17 23:37:28	maerwald	[12:33:45] now you also have to wonder: 3. there's a value, but there shouldn't be one
2021-07-17 23:37:28	maerwald	[12:33:47] oops
2021-07-17 23:37:28	kuribas	[12:33:47] IMO, the more you want correctness, the more you are restricted in what you write.  It has nothing to do with types (directly).
2021-07-17 23:37:28	kuribas	[12:34:28] maerwald: if you grab to clojure, you don't care anyway...
2021-07-17 23:37:28	maerwald	[12:34:48] default values.. what's my default account balance? :p
2021-07-17 23:37:28	dibblego	[12:34:54] like I said, get used to it
2021-07-17 23:37:28	tom__	[12:35:20] ^ yes and get used to makeNegative = (*) -1
2021-07-17 23:37:28	kuribas	[12:35:49] Which is my point, haskell can be a nice unsafe language to.  Just make a big sum type, and partial functions over it (don't forget to add error messages though...).
2021-07-17 23:37:28	maerwald	[12:36:21] well, with structural typing you don't need to be partial
2021-07-17 23:37:28	int-e	[12:36:25] Or unsafeCoerce everything and program untyped lambda calculus? :)
2021-07-17 23:37:28	arahael	[12:36:48] kuribas: Mind you, Clojure seems to offer alternative methods to allow you to type ocrrect code.  In particular, Clojure seems to have a fantastic runtime repl.
2021-07-17 23:37:28	arahael	[12:37:15] kuribas: Such that you're running the live program and debugging it and replacing functions on the fly.
2021-07-17 23:37:28	int-e	[12:37:26] I like types, they prevent some of the more embarrassing programming errors from being run as code.
2021-07-17 23:37:28	tom__	[12:37:44] Revenge is forcing them to write a web app in the Lean proof assistant fully verified.
2021-07-17 23:37:28	tom__	[12:37:49] It has IO.
2021-07-17 23:37:28	maerwald	[12:38:25] right... clojure: forget a closing  bracket, code still compiles, but doesn't compute prime numbers... instead it compiles to a chess engine
2021-07-17 23:37:28	tom__	[12:38:42] haha
2021-07-17 23:37:28	maerwald	[12:38:45] type safe? Yeah maybe. But.
2021-07-17 23:37:28	kuribas	[12:38:48] arahael: I think you never actually used clojure?
2021-07-17 23:37:28	int-e	[12:39:03] tom__: That's deep in "overdoing it" territory. At least if the specification is anything more elaborate than "something in, something out", and even that may be tricky if you interpret it as a promise to fulfil request in finite time.
2021-07-17 23:37:28	kuribas	[12:39:26] arahael: it's a very mediocre runtime IMO, compared to java.  Error messages are nearly incomprehensible.  Tracing is nice though...
2021-07-17 23:37:28	tom__	[12:39:39] int-e: Yeah pointless torture :)
2021-07-17 23:37:28	maerwald	[12:39:50] the only upside of clojure is interactive development
2021-07-17 23:37:28	tom__	[12:40:08] The haskell compiler feels pretty interactive
2021-07-17 23:37:28	maerwald	[12:40:29] if HLS works, maybe
2021-07-17 23:37:28	arahael	[12:40:37] kuribas: Seemed to be effective enough.
2021-07-17 23:37:28	arahael	[12:40:53] But no, I haven't personally used it.
2021-07-17 23:37:28	maerwald	[12:41:00] but on the other hand: usually not. Compile times are too slow
2021-07-17 23:37:28	kuribas	[12:41:12] arahael: clojurists just have a different idea of "correct code".
2021-07-17 23:37:28	arahael	[12:41:15] I personally quite like ghcid.
2021-07-17 23:37:28	arahael	[12:41:27] kuribas: Indeed, but I think it's the process of discovery that they like.
2021-07-17 23:37:28	arahael	[12:41:57] kuribas: In haskell, we seem to prefer to test functions in isolation. Clojure people seem to prefer to test functions in the live system.
2021-07-17 23:37:28	maerwald	[12:42:00] if you're working on 300+ modules and your Type module has a whitespace change, you're gonna need to restart cabal a few times, because your machine OOMed due to TH
2021-07-17 23:37:28	tom__	[12:42:18] Which library is recommended for sampling probability distributions?
2021-07-17 23:37:28	arahael	[12:42:42] maerwald: The amount of memory Haskell uses is crazy high.  Sadly, I find it way faster than Swift. :/
2021-07-17 23:37:28	kuribas	[12:45:45] arahael: lispers will boast about how easy it is to hot patch live systems.  They don't tell you that it becomes very hard to see who changed what and when.
2021-07-17 23:37:28	kuribas	[12:46:05] arahael: so you'll end up with CI/CD anyway.  
2021-07-17 23:37:28	kuribas	[12:46:34] However a theoretically, a "live" programming environment with integrated version control could be nice.
2021-07-17 23:37:28	kuribas	[12:46:44] I don't know if that ever has been done.
2021-07-17 23:37:28	maerwald	[12:47:32] https://hackage.haskell.org/package/optics-th-0.4/docs/Optics-TH.html#v:makeClassy
2021-07-17 23:37:28	maerwald	[12:47:34] https://hackage.haskell.org/package/optics-th-0.4/docs/Optics-TH.html#v:makeFieldsNoPrefix
2021-07-17 23:37:28	maerwald	[12:47:36] https://hackage.haskell.org/package/generic-optics-2.2.0.0/docs/Data-Generics-Product-Fields.html#t:HasField
2021-07-17 23:37:28	maerwald	[12:47:38] which one of those to pick?
2021-07-17 23:37:28	maerwald	[12:49:00] HasField is kinda cool with those neat type errors
2021-07-17 23:37:28	boxscape	[15:15:35] maerwald: the TH versions say "This method of optics generation should only be used when migrating an existing codebase from the lens library to optics"
2021-07-17 23:37:28	boxscape	[15:15:51] maerwald: this, my final answer is C
2021-07-17 23:37:28	boxscape	[15:15:56] s/this/thus
2021-07-17 23:37:28	maerwald	[15:16:07] HasField?
2021-07-17 23:37:28	boxscape	[15:16:46] yeah.. though I thought there was a version of that which uses OverloadedLabels
2021-07-17 23:37:28	maerwald	[15:17:20] HasField though doesn't allow arbitrary subtyping... it's a simple getter
2021-07-17 23:37:28	maerwald	[15:17:54] with makeClassy style classes you could descend deeper into the structure with the same getter
2021-07-17 23:37:28	boxscape	[15:18:30] maerwald: oh actually the TH version links to https://hackage.haskell.org/package/optics-core-0.4/docs/Optics-Label.html as preferred solution
2021-07-17 23:37:28	boxscape	[15:19:03] that's the OverloadedLabels version I was remembering
2021-07-17 23:37:28	maerwald	[15:22:44] so there you could also define custom LabelOptic instances that descend into a structure?
2021-07-17 23:37:28	boxscape	[15:23:27] that seems plausible but I haven't tried doing it
2021-07-17 23:37:28	maerwald	[15:23:47] I'm leaning towards makeClassy, but I'm not sure
2021-07-17 23:37:28	boxscape	[15:24:25] I like makeClassy, the main reason I would avoid it personally is that the documentation advises against it
2021-07-17 23:37:28	maerwald	[15:25:40] so what does LabelOptic give over HasField?
2021-07-17 23:37:28	texasmynsted	[15:26:17] What is the modern answer to haskell records? Lens?
2021-07-17 23:37:28	maerwald	[15:26:49] only difference I see is labelOptic is `Optic` and HasField is a `Lens`
2021-07-17 23:37:28	boxscape	[15:28:24] hm I'm not sure what the concrete differences are
2021-07-17 23:37:28	boxscape	[15:30:52] texasmynsted: there are a few answers to this: In the next version, OverloadedRecordDot is being introduces, which allows one to write something like `personA.company.name`. (Updates are a bit iffy but will improve over time.) In the meantime, lens is definitely still widely used, though optics is a replacement which aims to have better error messages. There is also some research going into row types, but that's further out.
2021-07-17 23:37:28	boxscape	[15:30:55] s/next version/next version of GHC
2021-07-17 23:37:28	boxscape	[15:32:08] (though regarding row types, the vinyl records package allows something similar today)
2021-07-17 23:37:28	Guest14	[16:03:05] Hello :)
2021-07-17 23:37:28	Guest14	[16:03:40] I am new to Haskell and am working through the Real World Haskell Book
2021-07-17 23:37:28	Guest14	[16:04:27] I have a basic question if anyone would care to listen
2021-07-17 23:37:28	allbery_b	[16:06:02] best to just ask it rather than asking to ask
2021-07-17 23:37:28	davean	[16:06:23] asking to ask is why I wasn't helping
2021-07-17 23:37:28	Guest14	[16:07:44] splitWith _ [] = []
2021-07-17 23:37:28	Guest14	[16:07:45] splitWith a xs = [pre ++ [x]] ++ next
2021-07-17 23:37:28	Guest14	[16:07:45]     where 
2021-07-17 23:37:28	Guest14	[16:07:46]         (pre, x:suf) = span a xs
2021-07-17 23:37:28	Guest14	[16:07:46]         next = splitWith a suf
2021-07-17 23:37:28	Guest14	[16:08:10] I have this program and I run into a problem with x:suf when span a xs is [] becuase there is no head
2021-07-17 23:37:28	int-e	[16:09:34] > let f = splitAt 1 in (f "abc", f "")
2021-07-17 23:37:28	lambdabot	[16:09:36]  (("a","bc"),("",""))
2021-07-17 23:37:28	int-e	[16:11:31] (So maybe use splitAt instead of the x:suf pattern.)
2021-07-17 23:37:28	maerwald	[16:11:39] was there a question yet?
2021-07-17 23:37:28	davean	[16:11:45] No
2021-07-17 23:37:28	Guest14	[16:12:09] Ok I will give that a try thanks
2021-07-17 23:37:28	int-e	[16:12:10] They described a problem, close enough.
2021-07-17 23:37:28	maerwald	[16:12:35] They also described the answer
2021-07-17 23:37:28	maerwald	[16:12:38] "there is no head"
2021-07-17 23:37:28	int-e	[16:12:47] @where paste
2021-07-17 23:37:28	lambdabot	[16:12:47] Help us help you: please paste full code, input and/or output at e.g. https://paste.tomsmeding.com
2021-07-17 23:37:28	int-e	[16:13:04] maerwald: That's the reason, but not a solution for the problem?
2021-07-17 23:37:28	 *	int-e [16:13:06] shrugs
2021-07-17 23:37:28	maerwald	[16:13:10] So my answer is: yes
2021-07-17 23:37:28	int-e	[16:13:28] Well, so sorry for trying to be helpful.
2021-07-17 23:37:28	davean	[16:14:09] int-e: oh do be helpful
2021-07-17 23:37:28	Guest14	[16:15:14] int-e that worked thank you
2021-07-17 23:37:28	texasmynsted	[16:20:42] thank you boxscape 
2021-07-17 23:37:28	texasmynsted	[16:21:29] Sounds like optics or vinyl for now
2021-07-17 23:37:28	sm	[16:31:11] g'day all. Speaking of optics.. you experienced [lens] coders, do you find it good or bad for (a) fields and (b) lenses to be visually disctinct from other kinds of bindings (functions, "variables") ? As in eg _field/lens_, field_/lens__, _field/lensL, .... ?
2021-07-17 23:37:28	sm	[16:32:24] I feel it would be good overall, for avoiding collisions and for human comprehension . But I don't have a lot of lens experience
2021-07-17 23:37:28	maerwald	[16:40:10] can you derive LabelOptic with deriving via for an inner type? 
2021-07-17 23:37:28	oso	[16:42:50] xpost from #haskell-beginners:
2021-07-17 23:37:28	oso	[16:42:52] I'm passing around a type synonym for Int, but in reality the only constraint it needs to  follow is that it's hashable. what constructor do i use for this? my brain says go from `type UID = Int` to `data UID a = Hashable a` but that's very not correct, and google isn't helping much
2021-07-17 23:37:28	oso	[16:43:21] nvm sorry got an answer there
2021-07-17 23:37:28	glguy	[16:54:37] oso, if you just need to know that something is hashable you'd use it like: stuff :: Hashable a => a -> b -> c
2021-07-17 23:37:28	glguy	[16:55:19] If a parameter is the uid parameter you can document that like:  stuff :: Hashable uid => uid {- ^ the UID -} -> etc
2021-07-17 23:37:28	oso	[16:55:35] I was trying to do that while also using types to keep my signatures from becoming unwieldy, but first i'll just worry about getting the code working
2021-07-17 23:37:28	glguy	[16:56:22] the documentation for parameters goes in the haddock comments rather than type synonyms
2021-07-17 23:37:28	oso	[16:56:43] mmk
2021-07-17 23:37:28	dsal	[17:05:40] oso: It's tempting to put constraints in the type definitions, but if you take a look at, for example, `Data.Map.Strict` you'll see the type definition is just `data Map k a`.  You'd think k would always have to be ordered, but that's not the case.  You can create and work on maps that have unorderable keys when you don't do things that require ordering.  e.g.:
2021-07-17 23:37:28	dsal	[17:05:42] > M.elems $ (* 2) <$> M.singleton id 3
2021-07-17 23:37:28	lambdabot	[17:05:43]  [6]
2021-07-17 23:37:28	dsal	[17:07:10] The idea is that you only have to constrain things where they actually need to be constrained.  The Functor instance, e.g., doesn't care about the keys at all, so why should it require they're ordered?
2021-07-17 23:37:28	oso	[17:13:45] got it working \o/
2021-07-17 23:37:28	oso	[17:13:47] thank you
2021-07-17 23:37:28	hololeap	[17:46:09] so, I figured out a way to make a function with an arbitrary number of arguments using type families and type-level lists. but, I have to wonder ... has someone already made this and put it on hackage?
2021-07-17 23:37:28	texasmynsted	[17:47:46] wait, why do you want a function with an arbitrary number of arguments?
2021-07-17 23:37:28	c_wraith	[17:49:03] usually to cover for a lack of other expressiveness
2021-07-17 23:37:28	c_wraith	[17:49:09] printf is a common example
2021-07-17 23:37:28	texasmynsted	[17:49:12] Seems to me ideally a function should have exactly one argument
2021-07-17 23:37:28	c_wraith	[17:49:19] We can't write the type it actually has in Haskell
2021-07-17 23:37:28	c_wraith	[17:49:25] Because it's a dependent type
2021-07-17 23:37:28	c_wraith	[17:49:51] So varargs lets us do it anyway and fail at runtime if the programmer got it wrong
2021-07-17 23:37:28	texasmynsted	[17:50:07] printf solves a problem in a particular way that I think could be solved better, differently 
2021-07-17 23:37:28	c_wraith	[17:50:18] differently?  sure.  Better?  Not really.
2021-07-17 23:37:28	hololeap	[17:50:21] the motivation was because I had a typeclass with a function, and I encountered some outliers that needed extra arguments passed to that function
2021-07-17 23:37:28	texasmynsted	[17:50:47] c_wraith: I am not convinced 
2021-07-17 23:37:28	hololeap	[17:50:48] I'd have to write up a blog post or something to get into all the details
2021-07-17 23:37:28	Rembane	[17:50:57] hololeap: Do it! :D
2021-07-17 23:37:28	texasmynsted	[17:51:08] yes, that would be a good read
2021-07-17 23:37:28	c_wraith	[17:51:15] printf is *really* good at doing exactly what it's intended for.  Compactly specifying output formatted for monospace devices.
2021-07-17 23:37:28	texasmynsted	[17:51:32] like regular expressions?
2021-07-17 23:37:28	c_wraith	[17:51:42] honestly, it's more useful
2021-07-17 23:37:28	c_wraith	[17:52:01] regular expressions have to involve things like capturing group to really be useful, and those complicate APIs tremendously
2021-07-17 23:37:28	c_wraith	[17:52:05] printf has no such problems
2021-07-17 23:37:28	texasmynsted	[17:52:20] Right. I think regular expressions work great but are terrible and the problem is better solved differently 
2021-07-17 23:37:28	EvanR	[17:52:46] compare and contrast serious uses of printf with the expanded version, replicate that across a code base like 50 times and compare xD
2021-07-17 23:37:28	EvanR	[17:53:12] also, printf for debugging
2021-07-17 23:37:28	EvanR	[17:53:25] debugging would be harsher without it
2021-07-17 23:37:28	EvanR	[17:54:27] I'm more interested with this case of some function sometimes needing more arguments
2021-07-17 23:37:28	texasmynsted	[17:56:04] I am still going with functions should have exactly one argument 
2021-07-17 23:37:28	hololeap	[17:56:30] I mean... they do, technically.
2021-07-17 23:37:28	texasmynsted	[17:57:38] yes
2021-07-17 23:37:28	EvanR	[17:58:02] if the difference is between argument type (A,B) and (A,B,C) it's about argument type and not number
2021-07-17 23:37:28	texasmynsted	[17:58:23] Okay now we are getting somewhere
2021-07-17 23:37:28	***	Playback Complete.
2021-07-17 23:37:34	--	Channel created on Sun, 25 Apr 2021 01:04:39
2021-07-17 23:39:18	<--	drd (~drd@93-39-151-19.ip76.fastwebnet.it) has quit (Ping timeout: 265 seconds)
2021-07-17 23:39:54	-->	pesada (~agua@2804:18:48:588b:1:0:277e:35b0) has joined #haskell
2021-07-17 23:40:09	-->	Core5124 (~agua@2804:14c:8793:8e2f:642c:be4c:c775:de87) has joined #haskell
2021-07-17 23:43:10	-->	__monty__ (~toonn@user/toonn) has joined #haskell
2021-07-17 23:43:23	<--	agua (~agua@2804:14c:8793:8e2f:a4d4:3a0b:9f6:6100) has quit (Ping timeout: 255 seconds)
2021-07-17 23:44:11	<--	pesada (~agua@2804:18:48:588b:1:0:277e:35b0) has quit (Ping timeout: 250 seconds)
2021-07-17 23:45:09	--	irc: disconnected from server
2021-07-17 23:53:31	-->	amanr (~therojjha@20.204.87.0) has joined #haskell
2021-07-17 23:53:31	--	Topic for #haskell is "https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org | Paste code/errors: https://paste.tomsmeding.com | tunes.org-style logging should be coming soon | Logs: https://ircbrowse.tomsmeding.com/browse/lchaskell"
2021-07-17 23:53:31	--	Topic set by geekosaur (~geekosaur@xmonad/geekosaur) on Mon, 14 Jun 2021 05:16:14
2021-07-17 23:53:31	--	Channel #haskell: 709 nicks (1 op, 0 voices, 708 normals)
2021-07-17 23:53:31	***	Buffer Playback...
2021-07-17 23:53:31	arkanoid	[10:23:16] the Error monad link is broken https://wiki.haskell.org/Errormonad.html
2021-07-17 23:53:31	kuribas	[10:45:22] How does haskell compare to other functional languages?  Looking a bit at SML and OCaml, it seems that haskell has far more libraries, and is more practical for real world projects (other than compilers etc).
2021-07-17 23:53:31	kuribas	[10:46:31] Of course scala and clojure are also popular, but I don't consider clojure a real functional language, it's more a lisp derivative.  And Scala is mostly multiparadigm, and also complex and overengineerd.
2021-07-17 23:53:31	arahael	[10:47:48] kuribas: I use haskell for most of my private hobby/side projects.  It's awesule, but I've used F# and Swift, which are somewhat OCaml-inspired.
2021-07-17 23:53:31	arahael	[10:48:25] kuribas: The biggest most profound difference with Haskell is that it's *lazy*, and has a really really good type system, but in practice that it's lazy makes a big difference to how you use haskell.
2021-07-17 23:53:31	kuribas	[10:48:54] arahael: how much libraries are there for F#?  Or does it just use the C# ecosystem?
2021-07-17 23:53:31	arahael	[10:49:05] F# is just another .NET language, really, yeah.
2021-07-17 23:53:31	arahael	[10:49:17] As is C#. :)
2021-07-17 23:53:31	kuribas	[10:49:20] doesn't that mean that most libraries aren't really made for FP?
2021-07-17 23:53:31	arahael	[10:50:00] Kinda.  The way F# copes with nulls is interesting. (It assumes there aren't any).
2021-07-17 23:53:31	kuribas	[10:50:41] then how do you test if a function returns null?
2021-07-17 23:53:31	arahael	[10:51:33] kuribas: That's a trap, yeah.  In earlier versions, you'd check for it explicitly, and the compiler lets you. But then, the compiler *elides* that check because it thinks better.
2021-07-17 23:53:31	arahael	[10:51:44] Hopefully they've changed that now.
2021-07-17 23:53:31	arahael	[10:53:33] Looks like they've changed it - suggesting instead to use pattern matching.  Far better: https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/values/null-values
2021-07-17 23:53:31	arahael	[10:53:59] But anyway, one difference is that Haskell is lazy, so your functions must not have side effects.
2021-07-17 23:53:31	arahael	[10:54:30] And since that practice is so strictly encouraged (otherwise you risk loosing your sanity), that has a flow-on effect to all of haskell's libraries, too.
2021-07-17 23:53:31	DigitalKiwi	[10:55:34] haskell is non-strict
2021-07-17 23:53:31	DigitalKiwi	[10:55:52] https://wiki.haskell.org/Lazy_vs._non-strict
2021-07-17 23:53:31	arahael	[10:56:01] Yeah - more accurate - thanks for that.
2021-07-17 23:53:31	DigitalKiwi	[10:56:34] speaking only for myself haskell programmers are lazy ;)
2021-07-17 23:53:31	arahael	[10:58:05] Hmm. :)
2021-07-17 23:53:31	DigitalKiwi	[11:01:36] and obsesssed with bottoms
2021-07-17 23:53:31	 *	DigitalKiwi [11:02:01] drops mic
2021-07-17 23:53:31	Rembane	[11:03:21] I like lazy bottoms and I cannot lie.
2021-07-17 23:53:31	 *	arahael [11:05:07] suddenly realises why bottom is drawn like _|_
2021-07-17 23:53:31	DigitalKiwi	[11:06:04] dibblego twitter avatar lolol
2021-07-17 23:53:31	kuribas	[11:08:21] arahael: so haskell is the only language that doesn't let you get away coding imperative OO in it?
2021-07-17 23:53:31	kuribas	[11:09:07] Although imperative style is still quite possible in haskell.  OO on the other hand is pretty hard.
2021-07-17 23:53:31	dibblego	[11:09:35] DigitalKiwi: that's BUMFISH
2021-07-17 23:53:31	DigitalKiwi	[11:10:01] is that a new operator
2021-07-17 23:53:31	dibblego	[11:11:41] no, it's a pre-landing checklist
2021-07-17 23:53:31	arahael	[11:13:08] Heh.
2021-07-17 23:53:31	arahael	[11:13:36] kuribas: If it's subtyping you're referring to, no, I don't think haskell has that.
2021-07-17 23:53:31	arahael	[11:13:58] kuribas: It does have classes and instances, though, but they behave quite differently.
2021-07-17 23:53:31	kuribas	[11:14:06] And that's a good thing...
2021-07-17 23:53:31	 *	arahael [11:14:25] thinks so.
2021-07-17 23:53:31	DigitalKiwi	[11:14:37] https://www.parsonsmatt.org/2017/02/17/object_oriented_programming_in_haskell.html
2021-07-17 23:53:31	DigitalKiwi	[11:16:43] https://hackage.haskell.org/package/hoop
2021-07-17 23:53:31	DigitalKiwi	[11:16:56] cue bot "haskell can do that!"
2021-07-17 23:53:31	dibblego	[11:22:23] DigitalKiwi: https://flightscope.gitlab.io/aircraft/checklist/eurofox.pdf page 1, top-right
2021-07-17 23:53:31	kuribas	[11:58:55] I've been accused of being a haskell lanuage zealot.  But actually I am interested in other languages (logic, FP, dependently typed, etc...).  It just doesn't seem to be useful to push for other languages that I know less...
2021-07-17 23:53:31	kuribas	[11:59:21] I could recommend F# instead of haskell, but I don't know it that well, so there is less benefit IMO...
2021-07-17 23:53:31	kuribas	[12:04:48] Every time I come with rational arguments, I get a reply like "But I don't like types, they get in the way".  Or "programming languages don't matter, business logic does".  Or "I don't care it's more robust, we want to move fast and solve bugs as we go".
2021-07-17 23:53:31	dibblego	[12:18:06] get used to it
2021-07-17 23:53:31	tom__	[12:18:47] kuribas: I feel your pain
2021-07-17 23:53:31	tom__	[12:19:43] "Types get in the way" then spends three hours NULL chasing
2021-07-17 23:53:31	kuribas	[12:20:50] tom__: exactly!  I spend far more time thinking about types in clojure than in haskell.
2021-07-17 23:53:31	maerwald	[12:21:11] types can get in the way, especially since haskell lacks structural typing
2021-07-17 23:53:31	tom__	[12:21:34] haha sometimes you want types to get in the way
2021-07-17 23:53:31	maerwald	[12:21:51] I know of at least one Haskell dev who now works full-time with typescript and doesn't regret it
2021-07-17 23:53:31	maerwald	[12:22:09] I probably wouldn't, but it's a valid position
2021-07-17 23:53:31	tom__	[12:22:55] Clojure to me is just javascript with some immutability
2021-07-17 23:53:31	kuribas	[12:23:22] maerwald: I find that often, it just amounts to having a bit more boilerplate.  Or having duplicate type definitions.
2021-07-17 23:53:31	maerwald	[12:23:40] it can be a *lot* of boilerplate
2021-07-17 23:53:31	maerwald	[12:24:00] and prohibits you of expressing certain relationships between data
2021-07-17 23:53:31	tom__	[12:24:19] Haskell, Rust and Julia - desert island stack
2021-07-17 23:53:31	tom__	[12:24:37] Havent tried the latter two :D
2021-07-17 23:53:31	maerwald	[12:24:58] class based solutions don't work well when you need an *actual* data type for serialisation
2021-07-17 23:53:31	maerwald	[12:25:45] typescript is surprisingly simple and powerful on these matters... certainly less elegant and unsound in a few places, but that's the tradeoff the make
2021-07-17 23:53:31	kuribas	[12:26:10] tom__: rust is only my "to learn list" :)
2021-07-17 23:53:31	kuribas	[12:26:42] maerwald: you can be less elegant and unsound in haskell too...
2021-07-17 23:53:31	maerwald	[12:27:02] kuribas: yeah, but that usually involves MORE complexity, not less
2021-07-17 23:53:31	maerwald	[12:27:10] so the opposite of typescript
2021-07-17 23:53:31	tom__	[12:27:22] You can be and then people who don't understand what a theoretical model is say that it must mean Haskell is pointless
2021-07-17 23:53:31	kuribas	[12:28:12] maerwald: I don't agree
2021-07-17 23:53:31	maerwald	[12:28:47] well, you *can* do some forms of structural typing/subtyping, but it all ends in esoteric libraries
2021-07-17 23:53:31	kuribas	[12:29:00] maerwald: so don't do it.
2021-07-17 23:53:31	maerwald	[12:29:03] while you get all that in TS for free without complexity
2021-07-17 23:53:31	maerwald	[12:29:45] well, I'm not commenting on which language is better, I'm just commenting on "types can get in the way", because they can
2021-07-17 23:53:31	kuribas	[12:29:55] maerwald: plenty of ways to get around that: 1) partially applied functions (the Endo trick), create a new type with some of the fields.  3) just make the fields all Maybe.
2021-07-17 23:53:31	kuribas	[12:30:56] maerwald: there is a difference between "the types sometimes get in the way", and "the types always get in the way", the latter is what they seem to be implying.
2021-07-17 23:53:31	maerwald	[12:31:02] 1) difficult for serialisation, Show instances, debugging, ... 2) boilerplate, 3) unexpressive, because now you have two cases of `Maybe`
2021-07-17 23:53:31	kuribas	[12:32:02] You don't need two cases of Maybe
2021-07-17 23:53:31	kuribas	[12:32:44] and 4) just put default values.
2021-07-17 23:53:31	maerwald	[12:33:32] 1. there's no such value, because the computation doesn't return one for the given input, 2. there's no such value, because the computation can *never* return one
2021-07-17 23:53:31	maerwald	[12:33:45] now you also have to wonder: 3. there's a value, but there shouldn't be one
2021-07-17 23:53:31	maerwald	[12:33:47] oops
2021-07-17 23:53:31	kuribas	[12:33:47] IMO, the more you want correctness, the more you are restricted in what you write.  It has nothing to do with types (directly).
2021-07-17 23:53:31	kuribas	[12:34:28] maerwald: if you grab to clojure, you don't care anyway...
2021-07-17 23:53:31	maerwald	[12:34:48] default values.. what's my default account balance? :p
2021-07-17 23:53:31	dibblego	[12:34:54] like I said, get used to it
2021-07-17 23:53:31	tom__	[12:35:20] ^ yes and get used to makeNegative = (*) -1
2021-07-17 23:53:31	kuribas	[12:35:49] Which is my point, haskell can be a nice unsafe language to.  Just make a big sum type, and partial functions over it (don't forget to add error messages though...).
2021-07-17 23:53:31	maerwald	[12:36:21] well, with structural typing you don't need to be partial
2021-07-17 23:53:31	int-e	[12:36:25] Or unsafeCoerce everything and program untyped lambda calculus? :)
2021-07-17 23:53:31	arahael	[12:36:48] kuribas: Mind you, Clojure seems to offer alternative methods to allow you to type ocrrect code.  In particular, Clojure seems to have a fantastic runtime repl.
2021-07-17 23:53:31	arahael	[12:37:15] kuribas: Such that you're running the live program and debugging it and replacing functions on the fly.
2021-07-17 23:53:31	int-e	[12:37:26] I like types, they prevent some of the more embarrassing programming errors from being run as code.
2021-07-17 23:53:31	tom__	[12:37:44] Revenge is forcing them to write a web app in the Lean proof assistant fully verified.
2021-07-17 23:53:31	tom__	[12:37:49] It has IO.
2021-07-17 23:53:31	maerwald	[12:38:25] right... clojure: forget a closing  bracket, code still compiles, but doesn't compute prime numbers... instead it compiles to a chess engine
2021-07-17 23:53:31	tom__	[12:38:42] haha
2021-07-17 23:53:31	maerwald	[12:38:45] type safe? Yeah maybe. But.
2021-07-17 23:53:31	kuribas	[12:38:48] arahael: I think you never actually used clojure?
2021-07-17 23:53:31	int-e	[12:39:03] tom__: That's deep in "overdoing it" territory. At least if the specification is anything more elaborate than "something in, something out", and even that may be tricky if you interpret it as a promise to fulfil request in finite time.
2021-07-17 23:53:31	kuribas	[12:39:26] arahael: it's a very mediocre runtime IMO, compared to java.  Error messages are nearly incomprehensible.  Tracing is nice though...
2021-07-17 23:53:31	tom__	[12:39:39] int-e: Yeah pointless torture :)
2021-07-17 23:53:31	maerwald	[12:39:50] the only upside of clojure is interactive development
2021-07-17 23:53:31	tom__	[12:40:08] The haskell compiler feels pretty interactive
2021-07-17 23:53:31	maerwald	[12:40:29] if HLS works, maybe
2021-07-17 23:53:31	arahael	[12:40:37] kuribas: Seemed to be effective enough.
2021-07-17 23:53:31	arahael	[12:40:53] But no, I haven't personally used it.
2021-07-17 23:53:31	maerwald	[12:41:00] but on the other hand: usually not. Compile times are too slow
2021-07-17 23:53:31	kuribas	[12:41:12] arahael: clojurists just have a different idea of "correct code".
2021-07-17 23:53:31	arahael	[12:41:15] I personally quite like ghcid.
2021-07-17 23:53:31	arahael	[12:41:27] kuribas: Indeed, but I think it's the process of discovery that they like.
2021-07-17 23:53:31	arahael	[12:41:57] kuribas: In haskell, we seem to prefer to test functions in isolation. Clojure people seem to prefer to test functions in the live system.
2021-07-17 23:53:31	maerwald	[12:42:00] if you're working on 300+ modules and your Type module has a whitespace change, you're gonna need to restart cabal a few times, because your machine OOMed due to TH
2021-07-17 23:53:31	tom__	[12:42:18] Which library is recommended for sampling probability distributions?
2021-07-17 23:53:31	arahael	[12:42:42] maerwald: The amount of memory Haskell uses is crazy high.  Sadly, I find it way faster than Swift. :/
2021-07-17 23:53:31	kuribas	[12:45:45] arahael: lispers will boast about how easy it is to hot patch live systems.  They don't tell you that it becomes very hard to see who changed what and when.
2021-07-17 23:53:31	kuribas	[12:46:05] arahael: so you'll end up with CI/CD anyway.  
2021-07-17 23:53:31	kuribas	[12:46:34] However a theoretically, a "live" programming environment with integrated version control could be nice.
2021-07-17 23:53:31	kuribas	[12:46:44] I don't know if that ever has been done.
2021-07-17 23:53:31	maerwald	[12:47:32] https://hackage.haskell.org/package/optics-th-0.4/docs/Optics-TH.html#v:makeClassy
2021-07-17 23:53:31	maerwald	[12:47:34] https://hackage.haskell.org/package/optics-th-0.4/docs/Optics-TH.html#v:makeFieldsNoPrefix
2021-07-17 23:53:31	maerwald	[12:47:36] https://hackage.haskell.org/package/generic-optics-2.2.0.0/docs/Data-Generics-Product-Fields.html#t:HasField
2021-07-17 23:53:31	maerwald	[12:47:38] which one of those to pick?
2021-07-17 23:53:31	maerwald	[12:49:00] HasField is kinda cool with those neat type errors
2021-07-17 23:53:31	boxscape	[15:15:35] maerwald: the TH versions say "This method of optics generation should only be used when migrating an existing codebase from the lens library to optics"
2021-07-17 23:53:31	boxscape	[15:15:51] maerwald: this, my final answer is C
2021-07-17 23:53:31	boxscape	[15:15:56] s/this/thus
2021-07-17 23:53:31	maerwald	[15:16:07] HasField?
2021-07-17 23:53:31	boxscape	[15:16:46] yeah.. though I thought there was a version of that which uses OverloadedLabels
2021-07-17 23:53:31	maerwald	[15:17:20] HasField though doesn't allow arbitrary subtyping... it's a simple getter
2021-07-17 23:53:31	maerwald	[15:17:54] with makeClassy style classes you could descend deeper into the structure with the same getter
2021-07-17 23:53:31	boxscape	[15:18:30] maerwald: oh actually the TH version links to https://hackage.haskell.org/package/optics-core-0.4/docs/Optics-Label.html as preferred solution
2021-07-17 23:53:31	boxscape	[15:19:03] that's the OverloadedLabels version I was remembering
2021-07-17 23:53:31	maerwald	[15:22:44] so there you could also define custom LabelOptic instances that descend into a structure?
2021-07-17 23:53:31	boxscape	[15:23:27] that seems plausible but I haven't tried doing it
2021-07-17 23:53:31	maerwald	[15:23:47] I'm leaning towards makeClassy, but I'm not sure
2021-07-17 23:53:31	boxscape	[15:24:25] I like makeClassy, the main reason I would avoid it personally is that the documentation advises against it
2021-07-17 23:53:31	maerwald	[15:25:40] so what does LabelOptic give over HasField?
2021-07-17 23:53:31	texasmynsted	[15:26:17] What is the modern answer to haskell records? Lens?
2021-07-17 23:53:31	maerwald	[15:26:49] only difference I see is labelOptic is `Optic` and HasField is a `Lens`
2021-07-17 23:53:31	boxscape	[15:28:24] hm I'm not sure what the concrete differences are
2021-07-17 23:53:31	boxscape	[15:30:52] texasmynsted: there are a few answers to this: In the next version, OverloadedRecordDot is being introduces, which allows one to write something like `personA.company.name`. (Updates are a bit iffy but will improve over time.) In the meantime, lens is definitely still widely used, though optics is a replacement which aims to have better error messages. There is also some research going into row types, but that's further out.
2021-07-17 23:53:31	boxscape	[15:30:55] s/next version/next version of GHC
2021-07-17 23:53:31	boxscape	[15:32:08] (though regarding row types, the vinyl records package allows something similar today)
2021-07-17 23:53:31	Guest14	[16:03:05] Hello :)
2021-07-17 23:53:31	Guest14	[16:03:40] I am new to Haskell and am working through the Real World Haskell Book
2021-07-17 23:53:31	Guest14	[16:04:27] I have a basic question if anyone would care to listen
2021-07-17 23:53:31	allbery_b	[16:06:02] best to just ask it rather than asking to ask
2021-07-17 23:53:31	davean	[16:06:23] asking to ask is why I wasn't helping
2021-07-17 23:53:31	Guest14	[16:07:44] splitWith _ [] = []
2021-07-17 23:53:31	Guest14	[16:07:45] splitWith a xs = [pre ++ [x]] ++ next
2021-07-17 23:53:31	Guest14	[16:07:45]     where 
2021-07-17 23:53:31	Guest14	[16:07:46]         (pre, x:suf) = span a xs
2021-07-17 23:53:31	Guest14	[16:07:46]         next = splitWith a suf
2021-07-17 23:53:31	Guest14	[16:08:10] I have this program and I run into a problem with x:suf when span a xs is [] becuase there is no head
2021-07-17 23:53:31	int-e	[16:09:34] > let f = splitAt 1 in (f "abc", f "")
2021-07-17 23:53:31	lambdabot	[16:09:36]  (("a","bc"),("",""))
2021-07-17 23:53:31	int-e	[16:11:31] (So maybe use splitAt instead of the x:suf pattern.)
2021-07-17 23:53:31	maerwald	[16:11:39] was there a question yet?
2021-07-17 23:53:31	davean	[16:11:45] No
2021-07-17 23:53:31	Guest14	[16:12:09] Ok I will give that a try thanks
2021-07-17 23:53:31	int-e	[16:12:10] They described a problem, close enough.
2021-07-17 23:53:31	maerwald	[16:12:35] They also described the answer
2021-07-17 23:53:31	maerwald	[16:12:38] "there is no head"
2021-07-17 23:53:31	int-e	[16:12:47] @where paste
2021-07-17 23:53:31	lambdabot	[16:12:47] Help us help you: please paste full code, input and/or output at e.g. https://paste.tomsmeding.com
2021-07-17 23:53:31	int-e	[16:13:04] maerwald: That's the reason, but not a solution for the problem?
2021-07-17 23:53:31	 *	int-e [16:13:06] shrugs
2021-07-17 23:53:31	maerwald	[16:13:10] So my answer is: yes
2021-07-17 23:53:31	int-e	[16:13:28] Well, so sorry for trying to be helpful.
2021-07-17 23:53:31	davean	[16:14:09] int-e: oh do be helpful
2021-07-17 23:53:31	Guest14	[16:15:14] int-e that worked thank you
2021-07-17 23:53:31	texasmynsted	[16:20:42] thank you boxscape 
2021-07-17 23:53:31	texasmynsted	[16:21:29] Sounds like optics or vinyl for now
2021-07-17 23:53:31	sm	[16:31:11] g'day all. Speaking of optics.. you experienced [lens] coders, do you find it good or bad for (a) fields and (b) lenses to be visually disctinct from other kinds of bindings (functions, "variables") ? As in eg _field/lens_, field_/lens__, _field/lensL, .... ?
2021-07-17 23:53:31	sm	[16:32:24] I feel it would be good overall, for avoiding collisions and for human comprehension . But I don't have a lot of lens experience
2021-07-17 23:53:31	maerwald	[16:40:10] can you derive LabelOptic with deriving via for an inner type? 
2021-07-17 23:53:31	oso	[16:42:50] xpost from #haskell-beginners:
2021-07-17 23:53:31	oso	[16:42:52] I'm passing around a type synonym for Int, but in reality the only constraint it needs to  follow is that it's hashable. what constructor do i use for this? my brain says go from `type UID = Int` to `data UID a = Hashable a` but that's very not correct, and google isn't helping much
2021-07-17 23:53:31	oso	[16:43:21] nvm sorry got an answer there
2021-07-17 23:53:31	glguy	[16:54:37] oso, if you just need to know that something is hashable you'd use it like: stuff :: Hashable a => a -> b -> c
2021-07-17 23:53:31	glguy	[16:55:19] If a parameter is the uid parameter you can document that like:  stuff :: Hashable uid => uid {- ^ the UID -} -> etc
2021-07-17 23:53:31	oso	[16:55:35] I was trying to do that while also using types to keep my signatures from becoming unwieldy, but first i'll just worry about getting the code working
2021-07-17 23:53:31	glguy	[16:56:22] the documentation for parameters goes in the haddock comments rather than type synonyms
2021-07-17 23:53:31	oso	[16:56:43] mmk
2021-07-17 23:53:31	dsal	[17:05:40] oso: It's tempting to put constraints in the type definitions, but if you take a look at, for example, `Data.Map.Strict` you'll see the type definition is just `data Map k a`.  You'd think k would always have to be ordered, but that's not the case.  You can create and work on maps that have unorderable keys when you don't do things that require ordering.  e.g.:
2021-07-17 23:53:31	dsal	[17:05:42] > M.elems $ (* 2) <$> M.singleton id 3
2021-07-17 23:53:31	lambdabot	[17:05:43]  [6]
2021-07-17 23:53:31	dsal	[17:07:10] The idea is that you only have to constrain things where they actually need to be constrained.  The Functor instance, e.g., doesn't care about the keys at all, so why should it require they're ordered?
2021-07-17 23:53:31	oso	[17:13:45] got it working \o/
2021-07-17 23:53:31	oso	[17:13:47] thank you
2021-07-17 23:53:31	hololeap	[17:46:09] so, I figured out a way to make a function with an arbitrary number of arguments using type families and type-level lists. but, I have to wonder ... has someone already made this and put it on hackage?
2021-07-17 23:53:31	texasmynsted	[17:47:46] wait, why do you want a function with an arbitrary number of arguments?
2021-07-17 23:53:31	c_wraith	[17:49:03] usually to cover for a lack of other expressiveness
2021-07-17 23:53:31	c_wraith	[17:49:09] printf is a common example
2021-07-17 23:53:31	texasmynsted	[17:49:12] Seems to me ideally a function should have exactly one argument
2021-07-17 23:53:31	c_wraith	[17:49:19] We can't write the type it actually has in Haskell
2021-07-17 23:53:31	c_wraith	[17:49:25] Because it's a dependent type
2021-07-17 23:53:31	c_wraith	[17:49:51] So varargs lets us do it anyway and fail at runtime if the programmer got it wrong
2021-07-17 23:53:31	texasmynsted	[17:50:07] printf solves a problem in a particular way that I think could be solved better, differently 
2021-07-17 23:53:31	c_wraith	[17:50:18] differently?  sure.  Better?  Not really.
2021-07-17 23:53:31	hololeap	[17:50:21] the motivation was because I had a typeclass with a function, and I encountered some outliers that needed extra arguments passed to that function
2021-07-17 23:53:31	texasmynsted	[17:50:47] c_wraith: I am not convinced 
2021-07-17 23:53:31	hololeap	[17:50:48] I'd have to write up a blog post or something to get into all the details
2021-07-17 23:53:31	Rembane	[17:50:57] hololeap: Do it! :D
2021-07-17 23:53:31	texasmynsted	[17:51:08] yes, that would be a good read
2021-07-17 23:53:31	c_wraith	[17:51:15] printf is *really* good at doing exactly what it's intended for.  Compactly specifying output formatted for monospace devices.
2021-07-17 23:53:31	texasmynsted	[17:51:32] like regular expressions?
2021-07-17 23:53:31	c_wraith	[17:51:42] honestly, it's more useful
2021-07-17 23:53:31	c_wraith	[17:52:01] regular expressions have to involve things like capturing group to really be useful, and those complicate APIs tremendously
2021-07-17 23:53:31	c_wraith	[17:52:05] printf has no such problems
2021-07-17 23:53:31	texasmynsted	[17:52:20] Right. I think regular expressions work great but are terrible and the problem is better solved differently 
2021-07-17 23:53:31	EvanR	[17:52:46] compare and contrast serious uses of printf with the expanded version, replicate that across a code base like 50 times and compare xD
2021-07-17 23:53:31	EvanR	[17:53:12] also, printf for debugging
2021-07-17 23:53:31	EvanR	[17:53:25] debugging would be harsher without it
2021-07-17 23:53:31	EvanR	[17:54:27] I'm more interested with this case of some function sometimes needing more arguments
2021-07-17 23:53:31	texasmynsted	[17:56:04] I am still going with functions should have exactly one argument 
2021-07-17 23:53:31	hololeap	[17:56:30] I mean... they do, technically.
2021-07-17 23:53:31	texasmynsted	[17:57:38] yes
2021-07-17 23:53:31	EvanR	[17:58:02] if the difference is between argument type (A,B) and (A,B,C) it's about argument type and not number
2021-07-17 23:53:31	texasmynsted	[17:58:23] Okay now we are getting somewhere
2021-07-17 23:53:31	***	Playback Complete.
2021-07-17 23:53:40	--	Channel created on Sun, 25 Apr 2021 01:04:39
2021-07-17 23:54:10	-->	Ananta-shesha (~pjetcetal@128-71-13-182.broadband.corbina.ru) has joined #haskell
2021-07-17 23:54:10	--	irc: disconnected from server
2021-07-17 23:54:18	-->	amanr (~therojjha@20.204.87.0) has joined #haskell
2021-07-17 23:54:18	--	Topic for #haskell is "https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org | Paste code/errors: https://paste.tomsmeding.com | tunes.org-style logging should be coming soon | Logs: https://ircbrowse.tomsmeding.com/browse/lchaskell"
2021-07-17 23:54:18	--	Topic set by geekosaur (~geekosaur@xmonad/geekosaur) on Mon, 14 Jun 2021 05:16:14
2021-07-17 23:54:18	--	Channel #haskell: 710 nicks (1 op, 0 voices, 709 normals)
2021-07-17 23:54:18	***	Buffer Playback...
2021-07-17 23:54:18	arkanoid	[10:23:16] the Error monad link is broken https://wiki.haskell.org/Errormonad.html
2021-07-17 23:54:18	kuribas	[10:45:22] How does haskell compare to other functional languages?  Looking a bit at SML and OCaml, it seems that haskell has far more libraries, and is more practical for real world projects (other than compilers etc).
2021-07-17 23:54:18	kuribas	[10:46:31] Of course scala and clojure are also popular, but I don't consider clojure a real functional language, it's more a lisp derivative.  And Scala is mostly multiparadigm, and also complex and overengineerd.
2021-07-17 23:54:18	arahael	[10:47:48] kuribas: I use haskell for most of my private hobby/side projects.  It's awesule, but I've used F# and Swift, which are somewhat OCaml-inspired.
2021-07-17 23:54:18	arahael	[10:48:25] kuribas: The biggest most profound difference with Haskell is that it's *lazy*, and has a really really good type system, but in practice that it's lazy makes a big difference to how you use haskell.
2021-07-17 23:54:18	kuribas	[10:48:54] arahael: how much libraries are there for F#?  Or does it just use the C# ecosystem?
2021-07-17 23:54:18	arahael	[10:49:05] F# is just another .NET language, really, yeah.
2021-07-17 23:54:18	arahael	[10:49:17] As is C#. :)
2021-07-17 23:54:18	kuribas	[10:49:20] doesn't that mean that most libraries aren't really made for FP?
2021-07-17 23:54:18	arahael	[10:50:00] Kinda.  The way F# copes with nulls is interesting. (It assumes there aren't any).
2021-07-17 23:54:18	kuribas	[10:50:41] then how do you test if a function returns null?
2021-07-17 23:54:18	arahael	[10:51:33] kuribas: That's a trap, yeah.  In earlier versions, you'd check for it explicitly, and the compiler lets you. But then, the compiler *elides* that check because it thinks better.
2021-07-17 23:54:18	arahael	[10:51:44] Hopefully they've changed that now.
2021-07-17 23:54:18	arahael	[10:53:33] Looks like they've changed it - suggesting instead to use pattern matching.  Far better: https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/values/null-values
2021-07-17 23:54:18	arahael	[10:53:59] But anyway, one difference is that Haskell is lazy, so your functions must not have side effects.
2021-07-17 23:54:18	arahael	[10:54:30] And since that practice is so strictly encouraged (otherwise you risk loosing your sanity), that has a flow-on effect to all of haskell's libraries, too.
2021-07-17 23:54:18	DigitalKiwi	[10:55:34] haskell is non-strict
2021-07-17 23:54:18	DigitalKiwi	[10:55:52] https://wiki.haskell.org/Lazy_vs._non-strict
2021-07-17 23:54:18	arahael	[10:56:01] Yeah - more accurate - thanks for that.
2021-07-17 23:54:18	DigitalKiwi	[10:56:34] speaking only for myself haskell programmers are lazy ;)
2021-07-17 23:54:18	arahael	[10:58:05] Hmm. :)
2021-07-17 23:54:18	DigitalKiwi	[11:01:36] and obsesssed with bottoms
2021-07-17 23:54:18	 *	DigitalKiwi [11:02:01] drops mic
2021-07-17 23:54:18	Rembane	[11:03:21] I like lazy bottoms and I cannot lie.
2021-07-17 23:54:18	 *	arahael [11:05:07] suddenly realises why bottom is drawn like _|_
2021-07-17 23:54:18	DigitalKiwi	[11:06:04] dibblego twitter avatar lolol
2021-07-17 23:54:18	kuribas	[11:08:21] arahael: so haskell is the only language that doesn't let you get away coding imperative OO in it?
2021-07-17 23:54:18	kuribas	[11:09:07] Although imperative style is still quite possible in haskell.  OO on the other hand is pretty hard.
2021-07-17 23:54:18	dibblego	[11:09:35] DigitalKiwi: that's BUMFISH
2021-07-17 23:54:18	DigitalKiwi	[11:10:01] is that a new operator
2021-07-17 23:54:18	dibblego	[11:11:41] no, it's a pre-landing checklist
2021-07-17 23:54:18	arahael	[11:13:08] Heh.
2021-07-17 23:54:18	arahael	[11:13:36] kuribas: If it's subtyping you're referring to, no, I don't think haskell has that.
2021-07-17 23:54:18	arahael	[11:13:58] kuribas: It does have classes and instances, though, but they behave quite differently.
2021-07-17 23:54:18	kuribas	[11:14:06] And that's a good thing...
2021-07-17 23:54:18	 *	arahael [11:14:25] thinks so.
2021-07-17 23:54:18	DigitalKiwi	[11:14:37] https://www.parsonsmatt.org/2017/02/17/object_oriented_programming_in_haskell.html
2021-07-17 23:54:18	DigitalKiwi	[11:16:43] https://hackage.haskell.org/package/hoop
2021-07-17 23:54:18	DigitalKiwi	[11:16:56] cue bot "haskell can do that!"
2021-07-17 23:54:18	dibblego	[11:22:23] DigitalKiwi: https://flightscope.gitlab.io/aircraft/checklist/eurofox.pdf page 1, top-right
2021-07-17 23:54:18	kuribas	[11:58:55] I've been accused of being a haskell lanuage zealot.  But actually I am interested in other languages (logic, FP, dependently typed, etc...).  It just doesn't seem to be useful to push for other languages that I know less...
2021-07-17 23:54:18	kuribas	[11:59:21] I could recommend F# instead of haskell, but I don't know it that well, so there is less benefit IMO...
2021-07-17 23:54:18	kuribas	[12:04:48] Every time I come with rational arguments, I get a reply like "But I don't like types, they get in the way".  Or "programming languages don't matter, business logic does".  Or "I don't care it's more robust, we want to move fast and solve bugs as we go".
2021-07-17 23:54:18	dibblego	[12:18:06] get used to it
2021-07-17 23:54:18	tom__	[12:18:47] kuribas: I feel your pain
2021-07-17 23:54:18	tom__	[12:19:43] "Types get in the way" then spends three hours NULL chasing
2021-07-17 23:54:18	kuribas	[12:20:50] tom__: exactly!  I spend far more time thinking about types in clojure than in haskell.
2021-07-17 23:54:18	maerwald	[12:21:11] types can get in the way, especially since haskell lacks structural typing
2021-07-17 23:54:18	tom__	[12:21:34] haha sometimes you want types to get in the way
2021-07-17 23:54:18	maerwald	[12:21:51] I know of at least one Haskell dev who now works full-time with typescript and doesn't regret it
2021-07-17 23:54:18	maerwald	[12:22:09] I probably wouldn't, but it's a valid position
2021-07-17 23:54:18	tom__	[12:22:55] Clojure to me is just javascript with some immutability
2021-07-17 23:54:18	kuribas	[12:23:22] maerwald: I find that often, it just amounts to having a bit more boilerplate.  Or having duplicate type definitions.
2021-07-17 23:54:18	maerwald	[12:23:40] it can be a *lot* of boilerplate
2021-07-17 23:54:18	maerwald	[12:24:00] and prohibits you of expressing certain relationships between data
2021-07-17 23:54:18	tom__	[12:24:19] Haskell, Rust and Julia - desert island stack
2021-07-17 23:54:18	tom__	[12:24:37] Havent tried the latter two :D
2021-07-17 23:54:18	maerwald	[12:24:58] class based solutions don't work well when you need an *actual* data type for serialisation
2021-07-17 23:54:18	maerwald	[12:25:45] typescript is surprisingly simple and powerful on these matters... certainly less elegant and unsound in a few places, but that's the tradeoff the make
2021-07-17 23:54:18	kuribas	[12:26:10] tom__: rust is only my "to learn list" :)
2021-07-17 23:54:18	kuribas	[12:26:42] maerwald: you can be less elegant and unsound in haskell too...
2021-07-17 23:54:18	maerwald	[12:27:02] kuribas: yeah, but that usually involves MORE complexity, not less
2021-07-17 23:54:18	maerwald	[12:27:10] so the opposite of typescript
2021-07-17 23:54:18	tom__	[12:27:22] You can be and then people who don't understand what a theoretical model is say that it must mean Haskell is pointless
2021-07-17 23:54:18	kuribas	[12:28:12] maerwald: I don't agree
2021-07-17 23:54:18	maerwald	[12:28:47] well, you *can* do some forms of structural typing/subtyping, but it all ends in esoteric libraries
2021-07-17 23:54:18	kuribas	[12:29:00] maerwald: so don't do it.
2021-07-17 23:54:18	maerwald	[12:29:03] while you get all that in TS for free without complexity
2021-07-17 23:54:18	maerwald	[12:29:45] well, I'm not commenting on which language is better, I'm just commenting on "types can get in the way", because they can
2021-07-17 23:54:18	kuribas	[12:29:55] maerwald: plenty of ways to get around that: 1) partially applied functions (the Endo trick), create a new type with some of the fields.  3) just make the fields all Maybe.
2021-07-17 23:54:18	kuribas	[12:30:56] maerwald: there is a difference between "the types sometimes get in the way", and "the types always get in the way", the latter is what they seem to be implying.
2021-07-17 23:54:18	maerwald	[12:31:02] 1) difficult for serialisation, Show instances, debugging, ... 2) boilerplate, 3) unexpressive, because now you have two cases of `Maybe`
2021-07-17 23:54:18	kuribas	[12:32:02] You don't need two cases of Maybe
2021-07-17 23:54:18	kuribas	[12:32:44] and 4) just put default values.
2021-07-17 23:54:18	maerwald	[12:33:32] 1. there's no such value, because the computation doesn't return one for the given input, 2. there's no such value, because the computation can *never* return one
2021-07-17 23:54:18	maerwald	[12:33:45] now you also have to wonder: 3. there's a value, but there shouldn't be one
2021-07-17 23:54:18	maerwald	[12:33:47] oops
2021-07-17 23:54:18	kuribas	[12:33:47] IMO, the more you want correctness, the more you are restricted in what you write.  It has nothing to do with types (directly).
2021-07-17 23:54:18	kuribas	[12:34:28] maerwald: if you grab to clojure, you don't care anyway...
2021-07-17 23:54:18	maerwald	[12:34:48] default values.. what's my default account balance? :p
2021-07-17 23:54:18	dibblego	[12:34:54] like I said, get used to it
2021-07-17 23:54:18	tom__	[12:35:20] ^ yes and get used to makeNegative = (*) -1
2021-07-17 23:54:18	kuribas	[12:35:49] Which is my point, haskell can be a nice unsafe language to.  Just make a big sum type, and partial functions over it (don't forget to add error messages though...).
2021-07-17 23:54:18	maerwald	[12:36:21] well, with structural typing you don't need to be partial
2021-07-17 23:54:18	int-e	[12:36:25] Or unsafeCoerce everything and program untyped lambda calculus? :)
2021-07-17 23:54:18	arahael	[12:36:48] kuribas: Mind you, Clojure seems to offer alternative methods to allow you to type ocrrect code.  In particular, Clojure seems to have a fantastic runtime repl.
2021-07-17 23:54:18	arahael	[12:37:15] kuribas: Such that you're running the live program and debugging it and replacing functions on the fly.
2021-07-17 23:54:18	int-e	[12:37:26] I like types, they prevent some of the more embarrassing programming errors from being run as code.
2021-07-17 23:54:18	tom__	[12:37:44] Revenge is forcing them to write a web app in the Lean proof assistant fully verified.
2021-07-17 23:54:18	tom__	[12:37:49] It has IO.
2021-07-17 23:54:18	maerwald	[12:38:25] right... clojure: forget a closing  bracket, code still compiles, but doesn't compute prime numbers... instead it compiles to a chess engine
2021-07-17 23:54:18	tom__	[12:38:42] haha
2021-07-17 23:54:18	maerwald	[12:38:45] type safe? Yeah maybe. But.
2021-07-17 23:54:18	kuribas	[12:38:48] arahael: I think you never actually used clojure?
2021-07-17 23:54:18	int-e	[12:39:03] tom__: That's deep in "overdoing it" territory. At least if the specification is anything more elaborate than "something in, something out", and even that may be tricky if you interpret it as a promise to fulfil request in finite time.
2021-07-17 23:54:18	kuribas	[12:39:26] arahael: it's a very mediocre runtime IMO, compared to java.  Error messages are nearly incomprehensible.  Tracing is nice though...
2021-07-17 23:54:18	tom__	[12:39:39] int-e: Yeah pointless torture :)
2021-07-17 23:54:18	maerwald	[12:39:50] the only upside of clojure is interactive development
2021-07-17 23:54:18	tom__	[12:40:08] The haskell compiler feels pretty interactive
2021-07-17 23:54:18	maerwald	[12:40:29] if HLS works, maybe
2021-07-17 23:54:18	arahael	[12:40:37] kuribas: Seemed to be effective enough.
2021-07-17 23:54:18	arahael	[12:40:53] But no, I haven't personally used it.
2021-07-17 23:54:18	maerwald	[12:41:00] but on the other hand: usually not. Compile times are too slow
2021-07-17 23:54:18	kuribas	[12:41:12] arahael: clojurists just have a different idea of "correct code".
2021-07-17 23:54:18	arahael	[12:41:15] I personally quite like ghcid.
2021-07-17 23:54:18	arahael	[12:41:27] kuribas: Indeed, but I think it's the process of discovery that they like.
2021-07-17 23:54:18	arahael	[12:41:57] kuribas: In haskell, we seem to prefer to test functions in isolation. Clojure people seem to prefer to test functions in the live system.
2021-07-17 23:54:18	maerwald	[12:42:00] if you're working on 300+ modules and your Type module has a whitespace change, you're gonna need to restart cabal a few times, because your machine OOMed due to TH
2021-07-17 23:54:18	tom__	[12:42:18] Which library is recommended for sampling probability distributions?
2021-07-17 23:54:18	arahael	[12:42:42] maerwald: The amount of memory Haskell uses is crazy high.  Sadly, I find it way faster than Swift. :/
2021-07-17 23:54:18	kuribas	[12:45:45] arahael: lispers will boast about how easy it is to hot patch live systems.  They don't tell you that it becomes very hard to see who changed what and when.
2021-07-17 23:54:18	kuribas	[12:46:05] arahael: so you'll end up with CI/CD anyway.  
2021-07-17 23:54:18	kuribas	[12:46:34] However a theoretically, a "live" programming environment with integrated version control could be nice.
2021-07-17 23:54:18	kuribas	[12:46:44] I don't know if that ever has been done.
2021-07-17 23:54:18	maerwald	[12:47:32] https://hackage.haskell.org/package/optics-th-0.4/docs/Optics-TH.html#v:makeClassy
2021-07-17 23:54:18	maerwald	[12:47:34] https://hackage.haskell.org/package/optics-th-0.4/docs/Optics-TH.html#v:makeFieldsNoPrefix
2021-07-17 23:54:18	maerwald	[12:47:36] https://hackage.haskell.org/package/generic-optics-2.2.0.0/docs/Data-Generics-Product-Fields.html#t:HasField
2021-07-17 23:54:18	maerwald	[12:47:38] which one of those to pick?
2021-07-17 23:54:18	maerwald	[12:49:00] HasField is kinda cool with those neat type errors
2021-07-17 23:54:18	boxscape	[15:15:35] maerwald: the TH versions say "This method of optics generation should only be used when migrating an existing codebase from the lens library to optics"
2021-07-17 23:54:18	boxscape	[15:15:51] maerwald: this, my final answer is C
2021-07-17 23:54:18	boxscape	[15:15:56] s/this/thus
2021-07-17 23:54:18	maerwald	[15:16:07] HasField?
2021-07-17 23:54:18	boxscape	[15:16:46] yeah.. though I thought there was a version of that which uses OverloadedLabels
2021-07-17 23:54:18	maerwald	[15:17:20] HasField though doesn't allow arbitrary subtyping... it's a simple getter
2021-07-17 23:54:18	maerwald	[15:17:54] with makeClassy style classes you could descend deeper into the structure with the same getter
2021-07-17 23:54:18	boxscape	[15:18:30] maerwald: oh actually the TH version links to https://hackage.haskell.org/package/optics-core-0.4/docs/Optics-Label.html as preferred solution
2021-07-17 23:54:18	boxscape	[15:19:03] that's the OverloadedLabels version I was remembering
2021-07-17 23:54:18	maerwald	[15:22:44] so there you could also define custom LabelOptic instances that descend into a structure?
2021-07-17 23:54:18	boxscape	[15:23:27] that seems plausible but I haven't tried doing it
2021-07-17 23:54:18	maerwald	[15:23:47] I'm leaning towards makeClassy, but I'm not sure
2021-07-17 23:54:18	boxscape	[15:24:25] I like makeClassy, the main reason I would avoid it personally is that the documentation advises against it
2021-07-17 23:54:18	maerwald	[15:25:40] so what does LabelOptic give over HasField?
2021-07-17 23:54:18	texasmynsted	[15:26:17] What is the modern answer to haskell records? Lens?
2021-07-17 23:54:18	maerwald	[15:26:49] only difference I see is labelOptic is `Optic` and HasField is a `Lens`
2021-07-17 23:54:18	boxscape	[15:28:24] hm I'm not sure what the concrete differences are
2021-07-17 23:54:18	boxscape	[15:30:52] texasmynsted: there are a few answers to this: In the next version, OverloadedRecordDot is being introduces, which allows one to write something like `personA.company.name`. (Updates are a bit iffy but will improve over time.) In the meantime, lens is definitely still widely used, though optics is a replacement which aims to have better error messages. There is also some research going into row types, but that's further out.
2021-07-17 23:54:18	boxscape	[15:30:55] s/next version/next version of GHC
2021-07-17 23:54:18	boxscape	[15:32:08] (though regarding row types, the vinyl records package allows something similar today)
2021-07-17 23:54:18	Guest14	[16:03:05] Hello :)
2021-07-17 23:54:18	Guest14	[16:03:40] I am new to Haskell and am working through the Real World Haskell Book
2021-07-17 23:54:18	Guest14	[16:04:27] I have a basic question if anyone would care to listen
2021-07-17 23:54:18	allbery_b	[16:06:02] best to just ask it rather than asking to ask
2021-07-17 23:54:18	davean	[16:06:23] asking to ask is why I wasn't helping
2021-07-17 23:54:18	Guest14	[16:07:44] splitWith _ [] = []
2021-07-17 23:54:18	Guest14	[16:07:45] splitWith a xs = [pre ++ [x]] ++ next
2021-07-17 23:54:18	Guest14	[16:07:45]     where 
2021-07-17 23:54:18	Guest14	[16:07:46]         (pre, x:suf) = span a xs
2021-07-17 23:54:18	Guest14	[16:07:46]         next = splitWith a suf
2021-07-17 23:54:18	Guest14	[16:08:10] I have this program and I run into a problem with x:suf when span a xs is [] becuase there is no head
2021-07-17 23:54:18	int-e	[16:09:34] > let f = splitAt 1 in (f "abc", f "")
2021-07-17 23:54:18	lambdabot	[16:09:36]  (("a","bc"),("",""))
2021-07-17 23:54:18	int-e	[16:11:31] (So maybe use splitAt instead of the x:suf pattern.)
2021-07-17 23:54:18	maerwald	[16:11:39] was there a question yet?
2021-07-17 23:54:18	davean	[16:11:45] No
2021-07-17 23:54:18	Guest14	[16:12:09] Ok I will give that a try thanks
2021-07-17 23:54:18	int-e	[16:12:10] They described a problem, close enough.
2021-07-17 23:54:18	maerwald	[16:12:35] They also described the answer
2021-07-17 23:54:18	maerwald	[16:12:38] "there is no head"
2021-07-17 23:54:18	int-e	[16:12:47] @where paste
2021-07-17 23:54:18	lambdabot	[16:12:47] Help us help you: please paste full code, input and/or output at e.g. https://paste.tomsmeding.com
2021-07-17 23:54:18	int-e	[16:13:04] maerwald: That's the reason, but not a solution for the problem?
2021-07-17 23:54:18	 *	int-e [16:13:06] shrugs
2021-07-17 23:54:18	maerwald	[16:13:10] So my answer is: yes
2021-07-17 23:54:18	int-e	[16:13:28] Well, so sorry for trying to be helpful.
2021-07-17 23:54:18	davean	[16:14:09] int-e: oh do be helpful
2021-07-17 23:54:18	Guest14	[16:15:14] int-e that worked thank you
2021-07-17 23:54:18	texasmynsted	[16:20:42] thank you boxscape 
2021-07-17 23:54:18	texasmynsted	[16:21:29] Sounds like optics or vinyl for now
2021-07-17 23:54:18	sm	[16:31:11] g'day all. Speaking of optics.. you experienced [lens] coders, do you find it good or bad for (a) fields and (b) lenses to be visually disctinct from other kinds of bindings (functions, "variables") ? As in eg _field/lens_, field_/lens__, _field/lensL, .... ?
2021-07-17 23:54:18	sm	[16:32:24] I feel it would be good overall, for avoiding collisions and for human comprehension . But I don't have a lot of lens experience
2021-07-17 23:54:18	maerwald	[16:40:10] can you derive LabelOptic with deriving via for an inner type? 
2021-07-17 23:54:18	oso	[16:42:50] xpost from #haskell-beginners:
2021-07-17 23:54:18	oso	[16:42:52] I'm passing around a type synonym for Int, but in reality the only constraint it needs to  follow is that it's hashable. what constructor do i use for this? my brain says go from `type UID = Int` to `data UID a = Hashable a` but that's very not correct, and google isn't helping much
2021-07-17 23:54:18	oso	[16:43:21] nvm sorry got an answer there
2021-07-17 23:54:18	glguy	[16:54:37] oso, if you just need to know that something is hashable you'd use it like: stuff :: Hashable a => a -> b -> c
2021-07-17 23:54:18	glguy	[16:55:19] If a parameter is the uid parameter you can document that like:  stuff :: Hashable uid => uid {- ^ the UID -} -> etc
2021-07-17 23:54:18	oso	[16:55:35] I was trying to do that while also using types to keep my signatures from becoming unwieldy, but first i'll just worry about getting the code working
2021-07-17 23:54:18	glguy	[16:56:22] the documentation for parameters goes in the haddock comments rather than type synonyms
2021-07-17 23:54:18	oso	[16:56:43] mmk
2021-07-17 23:54:18	dsal	[17:05:40] oso: It's tempting to put constraints in the type definitions, but if you take a look at, for example, `Data.Map.Strict` you'll see the type definition is just `data Map k a`.  You'd think k would always have to be ordered, but that's not the case.  You can create and work on maps that have unorderable keys when you don't do things that require ordering.  e.g.:
2021-07-17 23:54:18	dsal	[17:05:42] > M.elems $ (* 2) <$> M.singleton id 3
2021-07-17 23:54:18	lambdabot	[17:05:43]  [6]
2021-07-17 23:54:18	dsal	[17:07:10] The idea is that you only have to constrain things where they actually need to be constrained.  The Functor instance, e.g., doesn't care about the keys at all, so why should it require they're ordered?
2021-07-17 23:54:18	oso	[17:13:45] got it working \o/
2021-07-17 23:54:18	oso	[17:13:47] thank you
2021-07-17 23:54:18	hololeap	[17:46:09] so, I figured out a way to make a function with an arbitrary number of arguments using type families and type-level lists. but, I have to wonder ... has someone already made this and put it on hackage?
2021-07-17 23:54:18	texasmynsted	[17:47:46] wait, why do you want a function with an arbitrary number of arguments?
2021-07-17 23:54:18	c_wraith	[17:49:03] usually to cover for a lack of other expressiveness
2021-07-17 23:54:18	c_wraith	[17:49:09] printf is a common example
2021-07-17 23:54:18	texasmynsted	[17:49:12] Seems to me ideally a function should have exactly one argument
2021-07-17 23:54:18	c_wraith	[17:49:19] We can't write the type it actually has in Haskell
2021-07-17 23:54:18	c_wraith	[17:49:25] Because it's a dependent type
2021-07-17 23:54:18	c_wraith	[17:49:51] So varargs lets us do it anyway and fail at runtime if the programmer got it wrong
2021-07-17 23:54:18	texasmynsted	[17:50:07] printf solves a problem in a particular way that I think could be solved better, differently 
2021-07-17 23:54:18	c_wraith	[17:50:18] differently?  sure.  Better?  Not really.
2021-07-17 23:54:18	hololeap	[17:50:21] the motivation was because I had a typeclass with a function, and I encountered some outliers that needed extra arguments passed to that function
2021-07-17 23:54:18	texasmynsted	[17:50:47] c_wraith: I am not convinced 
2021-07-17 23:54:18	hololeap	[17:50:48] I'd have to write up a blog post or something to get into all the details
2021-07-17 23:54:18	Rembane	[17:50:57] hololeap: Do it! :D
2021-07-17 23:54:18	texasmynsted	[17:51:08] yes, that would be a good read
2021-07-17 23:54:18	c_wraith	[17:51:15] printf is *really* good at doing exactly what it's intended for.  Compactly specifying output formatted for monospace devices.
2021-07-17 23:54:18	texasmynsted	[17:51:32] like regular expressions?
2021-07-17 23:54:18	c_wraith	[17:51:42] honestly, it's more useful
2021-07-17 23:54:18	c_wraith	[17:52:01] regular expressions have to involve things like capturing group to really be useful, and those complicate APIs tremendously
2021-07-17 23:54:18	c_wraith	[17:52:05] printf has no such problems
2021-07-17 23:54:18	texasmynsted	[17:52:20] Right. I think regular expressions work great but are terrible and the problem is better solved differently 
2021-07-17 23:54:18	EvanR	[17:52:46] compare and contrast serious uses of printf with the expanded version, replicate that across a code base like 50 times and compare xD
2021-07-17 23:54:18	EvanR	[17:53:12] also, printf for debugging
2021-07-17 23:54:18	EvanR	[17:53:25] debugging would be harsher without it
2021-07-17 23:54:18	EvanR	[17:54:27] I'm more interested with this case of some function sometimes needing more arguments
2021-07-17 23:54:18	texasmynsted	[17:56:04] I am still going with functions should have exactly one argument 
2021-07-17 23:54:18	hololeap	[17:56:30] I mean... they do, technically.
2021-07-17 23:54:18	texasmynsted	[17:57:38] yes
2021-07-17 23:54:18	EvanR	[17:58:02] if the difference is between argument type (A,B) and (A,B,C) it's about argument type and not number
2021-07-17 23:54:18	texasmynsted	[17:58:23] Okay now we are getting somewhere
2021-07-17 23:54:18	***	Playback Complete.
2021-07-17 23:54:24	--	Channel created on Sun, 25 Apr 2021 01:04:39
2021-07-17 23:54:31	-->	merijn (~merijn@83-160-49-249.ip.xs4all.nl) has joined #haskell
2021-07-17 23:54:49	<--	azeem (~azeem@176.201.25.252) has quit (Read error: Connection reset by peer)
2021-07-17 23:55:39	--	irc: disconnected from server
2021-07-17 23:58:54	-->	amanr (~therojjha@20.204.87.0) has joined #haskell
2021-07-17 23:58:54	--	Topic for #haskell is "https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org | Paste code/errors: https://paste.tomsmeding.com | tunes.org-style logging should be coming soon | Logs: https://ircbrowse.tomsmeding.com/browse/lchaskell"
2021-07-17 23:58:54	--	Topic set by geekosaur (~geekosaur@xmonad/geekosaur) on Mon, 14 Jun 2021 05:16:14
2021-07-17 23:58:54	--	Channel #haskell: 712 nicks (1 op, 0 voices, 711 normals)
2021-07-17 23:58:54	***	Buffer Playback...
2021-07-17 23:58:54	arkanoid	[10:23:16] the Error monad link is broken https://wiki.haskell.org/Errormonad.html
2021-07-17 23:58:54	kuribas	[10:45:22] How does haskell compare to other functional languages?  Looking a bit at SML and OCaml, it seems that haskell has far more libraries, and is more practical for real world projects (other than compilers etc).
2021-07-17 23:58:54	kuribas	[10:46:31] Of course scala and clojure are also popular, but I don't consider clojure a real functional language, it's more a lisp derivative.  And Scala is mostly multiparadigm, and also complex and overengineerd.
2021-07-17 23:58:54	arahael	[10:47:48] kuribas: I use haskell for most of my private hobby/side projects.  It's awesule, but I've used F# and Swift, which are somewhat OCaml-inspired.
2021-07-17 23:58:54	arahael	[10:48:25] kuribas: The biggest most profound difference with Haskell is that it's *lazy*, and has a really really good type system, but in practice that it's lazy makes a big difference to how you use haskell.
2021-07-17 23:58:54	kuribas	[10:48:54] arahael: how much libraries are there for F#?  Or does it just use the C# ecosystem?
2021-07-17 23:58:54	arahael	[10:49:05] F# is just another .NET language, really, yeah.
2021-07-17 23:58:54	arahael	[10:49:17] As is C#. :)
2021-07-17 23:58:54	kuribas	[10:49:20] doesn't that mean that most libraries aren't really made for FP?
2021-07-17 23:58:54	arahael	[10:50:00] Kinda.  The way F# copes with nulls is interesting. (It assumes there aren't any).
2021-07-17 23:58:54	kuribas	[10:50:41] then how do you test if a function returns null?
2021-07-17 23:58:54	arahael	[10:51:33] kuribas: That's a trap, yeah.  In earlier versions, you'd check for it explicitly, and the compiler lets you. But then, the compiler *elides* that check because it thinks better.
2021-07-17 23:58:54	arahael	[10:51:44] Hopefully they've changed that now.
2021-07-17 23:58:54	arahael	[10:53:33] Looks like they've changed it - suggesting instead to use pattern matching.  Far better: https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/values/null-values
2021-07-17 23:58:54	arahael	[10:53:59] But anyway, one difference is that Haskell is lazy, so your functions must not have side effects.
2021-07-17 23:58:54	arahael	[10:54:30] And since that practice is so strictly encouraged (otherwise you risk loosing your sanity), that has a flow-on effect to all of haskell's libraries, too.
2021-07-17 23:58:54	DigitalKiwi	[10:55:34] haskell is non-strict
2021-07-17 23:58:54	DigitalKiwi	[10:55:52] https://wiki.haskell.org/Lazy_vs._non-strict
2021-07-17 23:58:54	arahael	[10:56:01] Yeah - more accurate - thanks for that.
2021-07-17 23:58:54	DigitalKiwi	[10:56:34] speaking only for myself haskell programmers are lazy ;)
2021-07-17 23:58:54	arahael	[10:58:05] Hmm. :)
2021-07-17 23:58:54	DigitalKiwi	[11:01:36] and obsesssed with bottoms
2021-07-17 23:58:54	 *	DigitalKiwi [11:02:01] drops mic
2021-07-17 23:58:54	Rembane	[11:03:21] I like lazy bottoms and I cannot lie.
2021-07-17 23:58:55	 *	arahael [11:05:07] suddenly realises why bottom is drawn like _|_
2021-07-17 23:58:55	DigitalKiwi	[11:06:04] dibblego twitter avatar lolol
2021-07-17 23:58:55	kuribas	[11:08:21] arahael: so haskell is the only language that doesn't let you get away coding imperative OO in it?
2021-07-17 23:58:55	kuribas	[11:09:07] Although imperative style is still quite possible in haskell.  OO on the other hand is pretty hard.
2021-07-17 23:58:55	dibblego	[11:09:35] DigitalKiwi: that's BUMFISH
2021-07-17 23:58:55	DigitalKiwi	[11:10:01] is that a new operator
2021-07-17 23:58:55	dibblego	[11:11:41] no, it's a pre-landing checklist
2021-07-17 23:58:55	arahael	[11:13:08] Heh.
2021-07-17 23:58:55	arahael	[11:13:36] kuribas: If it's subtyping you're referring to, no, I don't think haskell has that.
2021-07-17 23:58:55	arahael	[11:13:58] kuribas: It does have classes and instances, though, but they behave quite differently.
2021-07-17 23:58:55	kuribas	[11:14:06] And that's a good thing...
2021-07-17 23:58:55	 *	arahael [11:14:25] thinks so.
2021-07-17 23:58:55	DigitalKiwi	[11:14:37] https://www.parsonsmatt.org/2017/02/17/object_oriented_programming_in_haskell.html
2021-07-17 23:58:55	DigitalKiwi	[11:16:43] https://hackage.haskell.org/package/hoop
2021-07-17 23:58:55	DigitalKiwi	[11:16:56] cue bot "haskell can do that!"
2021-07-17 23:58:55	dibblego	[11:22:23] DigitalKiwi: https://flightscope.gitlab.io/aircraft/checklist/eurofox.pdf page 1, top-right
2021-07-17 23:58:55	kuribas	[11:58:55] I've been accused of being a haskell lanuage zealot.  But actually I am interested in other languages (logic, FP, dependently typed, etc...).  It just doesn't seem to be useful to push for other languages that I know less...
2021-07-17 23:58:55	kuribas	[11:59:21] I could recommend F# instead of haskell, but I don't know it that well, so there is less benefit IMO...
2021-07-17 23:58:55	kuribas	[12:04:48] Every time I come with rational arguments, I get a reply like "But I don't like types, they get in the way".  Or "programming languages don't matter, business logic does".  Or "I don't care it's more robust, we want to move fast and solve bugs as we go".
2021-07-17 23:58:55	dibblego	[12:18:06] get used to it
2021-07-17 23:58:55	tom__	[12:18:47] kuribas: I feel your pain
2021-07-17 23:58:55	tom__	[12:19:43] "Types get in the way" then spends three hours NULL chasing
2021-07-17 23:58:55	kuribas	[12:20:50] tom__: exactly!  I spend far more time thinking about types in clojure than in haskell.
2021-07-17 23:58:55	maerwald	[12:21:11] types can get in the way, especially since haskell lacks structural typing
2021-07-17 23:58:55	tom__	[12:21:34] haha sometimes you want types to get in the way
2021-07-17 23:58:55	maerwald	[12:21:51] I know of at least one Haskell dev who now works full-time with typescript and doesn't regret it
2021-07-17 23:58:55	maerwald	[12:22:09] I probably wouldn't, but it's a valid position
2021-07-17 23:58:55	tom__	[12:22:55] Clojure to me is just javascript with some immutability
2021-07-17 23:58:55	kuribas	[12:23:22] maerwald: I find that often, it just amounts to having a bit more boilerplate.  Or having duplicate type definitions.
2021-07-17 23:58:55	maerwald	[12:23:40] it can be a *lot* of boilerplate
2021-07-17 23:58:55	maerwald	[12:24:00] and prohibits you of expressing certain relationships between data
2021-07-17 23:58:55	tom__	[12:24:19] Haskell, Rust and Julia - desert island stack
2021-07-17 23:58:55	tom__	[12:24:37] Havent tried the latter two :D
2021-07-17 23:58:55	maerwald	[12:24:58] class based solutions don't work well when you need an *actual* data type for serialisation
2021-07-17 23:58:55	maerwald	[12:25:45] typescript is surprisingly simple and powerful on these matters... certainly less elegant and unsound in a few places, but that's the tradeoff the make
2021-07-17 23:58:55	kuribas	[12:26:10] tom__: rust is only my "to learn list" :)
2021-07-17 23:58:55	kuribas	[12:26:42] maerwald: you can be less elegant and unsound in haskell too...
2021-07-17 23:58:55	maerwald	[12:27:02] kuribas: yeah, but that usually involves MORE complexity, not less
2021-07-17 23:58:55	maerwald	[12:27:10] so the opposite of typescript
2021-07-17 23:58:55	tom__	[12:27:22] You can be and then people who don't understand what a theoretical model is say that it must mean Haskell is pointless
2021-07-17 23:58:55	kuribas	[12:28:12] maerwald: I don't agree
2021-07-17 23:58:55	maerwald	[12:28:47] well, you *can* do some forms of structural typing/subtyping, but it all ends in esoteric libraries
2021-07-17 23:58:55	kuribas	[12:29:00] maerwald: so don't do it.
2021-07-17 23:58:55	maerwald	[12:29:03] while you get all that in TS for free without complexity
2021-07-17 23:58:55	maerwald	[12:29:45] well, I'm not commenting on which language is better, I'm just commenting on "types can get in the way", because they can
2021-07-17 23:58:55	kuribas	[12:29:55] maerwald: plenty of ways to get around that: 1) partially applied functions (the Endo trick), create a new type with some of the fields.  3) just make the fields all Maybe.
2021-07-17 23:58:55	kuribas	[12:30:56] maerwald: there is a difference between "the types sometimes get in the way", and "the types always get in the way", the latter is what they seem to be implying.
2021-07-17 23:58:55	maerwald	[12:31:02] 1) difficult for serialisation, Show instances, debugging, ... 2) boilerplate, 3) unexpressive, because now you have two cases of `Maybe`
2021-07-17 23:58:55	kuribas	[12:32:02] You don't need two cases of Maybe
2021-07-17 23:58:55	kuribas	[12:32:44] and 4) just put default values.
2021-07-17 23:58:55	maerwald	[12:33:32] 1. there's no such value, because the computation doesn't return one for the given input, 2. there's no such value, because the computation can *never* return one
2021-07-17 23:58:55	maerwald	[12:33:45] now you also have to wonder: 3. there's a value, but there shouldn't be one
2021-07-17 23:58:55	maerwald	[12:33:47] oops
2021-07-17 23:58:55	kuribas	[12:33:47] IMO, the more you want correctness, the more you are restricted in what you write.  It has nothing to do with types (directly).
2021-07-17 23:58:55	kuribas	[12:34:28] maerwald: if you grab to clojure, you don't care anyway...
2021-07-17 23:58:55	maerwald	[12:34:48] default values.. what's my default account balance? :p
2021-07-17 23:58:55	dibblego	[12:34:54] like I said, get used to it
2021-07-17 23:58:55	tom__	[12:35:20] ^ yes and get used to makeNegative = (*) -1
2021-07-17 23:58:55	kuribas	[12:35:49] Which is my point, haskell can be a nice unsafe language to.  Just make a big sum type, and partial functions over it (don't forget to add error messages though...).
2021-07-17 23:58:55	maerwald	[12:36:21] well, with structural typing you don't need to be partial
2021-07-17 23:58:55	int-e	[12:36:25] Or unsafeCoerce everything and program untyped lambda calculus? :)
2021-07-17 23:58:55	arahael	[12:36:48] kuribas: Mind you, Clojure seems to offer alternative methods to allow you to type ocrrect code.  In particular, Clojure seems to have a fantastic runtime repl.
2021-07-17 23:58:55	arahael	[12:37:15] kuribas: Such that you're running the live program and debugging it and replacing functions on the fly.
2021-07-17 23:58:55	int-e	[12:37:26] I like types, they prevent some of the more embarrassing programming errors from being run as code.
2021-07-17 23:58:55	tom__	[12:37:44] Revenge is forcing them to write a web app in the Lean proof assistant fully verified.
2021-07-17 23:58:55	tom__	[12:37:49] It has IO.
2021-07-17 23:58:55	maerwald	[12:38:25] right... clojure: forget a closing  bracket, code still compiles, but doesn't compute prime numbers... instead it compiles to a chess engine
2021-07-17 23:58:55	tom__	[12:38:42] haha
2021-07-17 23:58:55	maerwald	[12:38:45] type safe? Yeah maybe. But.
2021-07-17 23:58:55	kuribas	[12:38:48] arahael: I think you never actually used clojure?
2021-07-17 23:58:55	int-e	[12:39:03] tom__: That's deep in "overdoing it" territory. At least if the specification is anything more elaborate than "something in, something out", and even that may be tricky if you interpret it as a promise to fulfil request in finite time.
2021-07-17 23:58:55	kuribas	[12:39:26] arahael: it's a very mediocre runtime IMO, compared to java.  Error messages are nearly incomprehensible.  Tracing is nice though...
2021-07-17 23:58:55	tom__	[12:39:39] int-e: Yeah pointless torture :)
2021-07-17 23:58:55	maerwald	[12:39:50] the only upside of clojure is interactive development
2021-07-17 23:58:55	tom__	[12:40:08] The haskell compiler feels pretty interactive
2021-07-17 23:58:55	maerwald	[12:40:29] if HLS works, maybe
2021-07-17 23:58:55	arahael	[12:40:37] kuribas: Seemed to be effective enough.
2021-07-17 23:58:55	arahael	[12:40:53] But no, I haven't personally used it.
2021-07-17 23:58:55	maerwald	[12:41:00] but on the other hand: usually not. Compile times are too slow
2021-07-17 23:58:55	kuribas	[12:41:12] arahael: clojurists just have a different idea of "correct code".
2021-07-17 23:58:55	arahael	[12:41:15] I personally quite like ghcid.
2021-07-17 23:58:55	arahael	[12:41:27] kuribas: Indeed, but I think it's the process of discovery that they like.
2021-07-17 23:58:55	arahael	[12:41:57] kuribas: In haskell, we seem to prefer to test functions in isolation. Clojure people seem to prefer to test functions in the live system.
2021-07-17 23:58:55	maerwald	[12:42:00] if you're working on 300+ modules and your Type module has a whitespace change, you're gonna need to restart cabal a few times, because your machine OOMed due to TH
2021-07-17 23:58:55	tom__	[12:42:18] Which library is recommended for sampling probability distributions?
2021-07-17 23:58:55	arahael	[12:42:42] maerwald: The amount of memory Haskell uses is crazy high.  Sadly, I find it way faster than Swift. :/
2021-07-17 23:58:55	kuribas	[12:45:45] arahael: lispers will boast about how easy it is to hot patch live systems.  They don't tell you that it becomes very hard to see who changed what and when.
2021-07-17 23:58:55	kuribas	[12:46:05] arahael: so you'll end up with CI/CD anyway.  
2021-07-17 23:58:55	kuribas	[12:46:34] However a theoretically, a "live" programming environment with integrated version control could be nice.
2021-07-17 23:58:55	kuribas	[12:46:44] I don't know if that ever has been done.
2021-07-17 23:58:55	maerwald	[12:47:32] https://hackage.haskell.org/package/optics-th-0.4/docs/Optics-TH.html#v:makeClassy
2021-07-17 23:58:55	maerwald	[12:47:34] https://hackage.haskell.org/package/optics-th-0.4/docs/Optics-TH.html#v:makeFieldsNoPrefix
2021-07-17 23:58:55	maerwald	[12:47:36] https://hackage.haskell.org/package/generic-optics-2.2.0.0/docs/Data-Generics-Product-Fields.html#t:HasField
2021-07-17 23:58:55	maerwald	[12:47:38] which one of those to pick?
2021-07-17 23:58:55	maerwald	[12:49:00] HasField is kinda cool with those neat type errors
2021-07-17 23:58:55	boxscape	[15:15:35] maerwald: the TH versions say "This method of optics generation should only be used when migrating an existing codebase from the lens library to optics"
2021-07-17 23:58:55	boxscape	[15:15:51] maerwald: this, my final answer is C
2021-07-17 23:58:55	boxscape	[15:15:56] s/this/thus
2021-07-17 23:58:55	maerwald	[15:16:07] HasField?
2021-07-17 23:58:55	boxscape	[15:16:46] yeah.. though I thought there was a version of that which uses OverloadedLabels
2021-07-17 23:58:55	maerwald	[15:17:20] HasField though doesn't allow arbitrary subtyping... it's a simple getter
2021-07-17 23:58:55	maerwald	[15:17:54] with makeClassy style classes you could descend deeper into the structure with the same getter
2021-07-17 23:58:55	boxscape	[15:18:30] maerwald: oh actually the TH version links to https://hackage.haskell.org/package/optics-core-0.4/docs/Optics-Label.html as preferred solution
2021-07-17 23:58:55	boxscape	[15:19:03] that's the OverloadedLabels version I was remembering
2021-07-17 23:58:55	maerwald	[15:22:44] so there you could also define custom LabelOptic instances that descend into a structure?
2021-07-17 23:58:55	boxscape	[15:23:27] that seems plausible but I haven't tried doing it
2021-07-17 23:58:55	maerwald	[15:23:47] I'm leaning towards makeClassy, but I'm not sure
2021-07-17 23:58:55	boxscape	[15:24:25] I like makeClassy, the main reason I would avoid it personally is that the documentation advises against it
2021-07-17 23:58:55	maerwald	[15:25:40] so what does LabelOptic give over HasField?
2021-07-17 23:58:55	texasmynsted	[15:26:17] What is the modern answer to haskell records? Lens?
2021-07-17 23:58:55	maerwald	[15:26:49] only difference I see is labelOptic is `Optic` and HasField is a `Lens`
2021-07-17 23:58:55	boxscape	[15:28:24] hm I'm not sure what the concrete differences are
2021-07-17 23:58:55	boxscape	[15:30:52] texasmynsted: there are a few answers to this: In the next version, OverloadedRecordDot is being introduces, which allows one to write something like `personA.company.name`. (Updates are a bit iffy but will improve over time.) In the meantime, lens is definitely still widely used, though optics is a replacement which aims to have better error messages. There is also some research going into row types, but that's further out.
2021-07-17 23:58:55	boxscape	[15:30:55] s/next version/next version of GHC
2021-07-17 23:58:55	boxscape	[15:32:08] (though regarding row types, the vinyl records package allows something similar today)
2021-07-17 23:58:55	Guest14	[16:03:05] Hello :)
2021-07-17 23:58:55	Guest14	[16:03:40] I am new to Haskell and am working through the Real World Haskell Book
2021-07-17 23:58:55	Guest14	[16:04:27] I have a basic question if anyone would care to listen
2021-07-17 23:58:55	allbery_b	[16:06:02] best to just ask it rather than asking to ask
2021-07-17 23:58:55	davean	[16:06:23] asking to ask is why I wasn't helping
2021-07-17 23:58:55	Guest14	[16:07:44] splitWith _ [] = []
2021-07-17 23:58:55	Guest14	[16:07:45] splitWith a xs = [pre ++ [x]] ++ next
2021-07-17 23:58:55	Guest14	[16:07:45]     where 
2021-07-17 23:58:55	Guest14	[16:07:46]         (pre, x:suf) = span a xs
2021-07-17 23:58:55	Guest14	[16:07:46]         next = splitWith a suf
2021-07-17 23:58:55	Guest14	[16:08:10] I have this program and I run into a problem with x:suf when span a xs is [] becuase there is no head
2021-07-17 23:58:55	int-e	[16:09:34] > let f = splitAt 1 in (f "abc", f "")
2021-07-17 23:58:55	lambdabot	[16:09:36]  (("a","bc"),("",""))
2021-07-17 23:58:55	int-e	[16:11:31] (So maybe use splitAt instead of the x:suf pattern.)
2021-07-17 23:58:55	maerwald	[16:11:39] was there a question yet?
2021-07-17 23:58:55	davean	[16:11:45] No
2021-07-17 23:58:55	Guest14	[16:12:09] Ok I will give that a try thanks
2021-07-17 23:58:55	int-e	[16:12:10] They described a problem, close enough.
2021-07-17 23:58:55	maerwald	[16:12:35] They also described the answer
2021-07-17 23:58:55	maerwald	[16:12:38] "there is no head"
2021-07-17 23:58:55	int-e	[16:12:47] @where paste
2021-07-17 23:58:55	lambdabot	[16:12:47] Help us help you: please paste full code, input and/or output at e.g. https://paste.tomsmeding.com
2021-07-17 23:58:55	int-e	[16:13:04] maerwald: That's the reason, but not a solution for the problem?
2021-07-17 23:58:55	 *	int-e [16:13:06] shrugs
2021-07-17 23:58:55	maerwald	[16:13:10] So my answer is: yes
2021-07-17 23:58:55	int-e	[16:13:28] Well, so sorry for trying to be helpful.
2021-07-17 23:58:55	davean	[16:14:09] int-e: oh do be helpful
2021-07-17 23:58:55	Guest14	[16:15:14] int-e that worked thank you
2021-07-17 23:58:55	texasmynsted	[16:20:42] thank you boxscape 
2021-07-17 23:58:55	texasmynsted	[16:21:29] Sounds like optics or vinyl for now
2021-07-17 23:58:55	sm	[16:31:11] g'day all. Speaking of optics.. you experienced [lens] coders, do you find it good or bad for (a) fields and (b) lenses to be visually disctinct from other kinds of bindings (functions, "variables") ? As in eg _field/lens_, field_/lens__, _field/lensL, .... ?
2021-07-17 23:58:55	sm	[16:32:24] I feel it would be good overall, for avoiding collisions and for human comprehension . But I don't have a lot of lens experience
2021-07-17 23:58:55	maerwald	[16:40:10] can you derive LabelOptic with deriving via for an inner type? 
2021-07-17 23:58:55	oso	[16:42:50] xpost from #haskell-beginners:
2021-07-17 23:58:55	oso	[16:42:52] I'm passing around a type synonym for Int, but in reality the only constraint it needs to  follow is that it's hashable. what constructor do i use for this? my brain says go from `type UID = Int` to `data UID a = Hashable a` but that's very not correct, and google isn't helping much
2021-07-17 23:58:55	oso	[16:43:21] nvm sorry got an answer there
2021-07-17 23:58:55	glguy	[16:54:37] oso, if you just need to know that something is hashable you'd use it like: stuff :: Hashable a => a -> b -> c
2021-07-17 23:58:55	glguy	[16:55:19] If a parameter is the uid parameter you can document that like:  stuff :: Hashable uid => uid {- ^ the UID -} -> etc
2021-07-17 23:58:55	oso	[16:55:35] I was trying to do that while also using types to keep my signatures from becoming unwieldy, but first i'll just worry about getting the code working
2021-07-17 23:58:55	glguy	[16:56:22] the documentation for parameters goes in the haddock comments rather than type synonyms
2021-07-17 23:58:55	oso	[16:56:43] mmk
2021-07-17 23:58:55	dsal	[17:05:40] oso: It's tempting to put constraints in the type definitions, but if you take a look at, for example, `Data.Map.Strict` you'll see the type definition is just `data Map k a`.  You'd think k would always have to be ordered, but that's not the case.  You can create and work on maps that have unorderable keys when you don't do things that require ordering.  e.g.:
2021-07-17 23:58:55	dsal	[17:05:42] > M.elems $ (* 2) <$> M.singleton id 3
2021-07-17 23:58:55	lambdabot	[17:05:43]  [6]
2021-07-17 23:58:55	dsal	[17:07:10] The idea is that you only have to constrain things where they actually need to be constrained.  The Functor instance, e.g., doesn't care about the keys at all, so why should it require they're ordered?
2021-07-17 23:58:55	oso	[17:13:45] got it working \o/
2021-07-17 23:58:55	oso	[17:13:47] thank you
2021-07-17 23:58:55	hololeap	[17:46:09] so, I figured out a way to make a function with an arbitrary number of arguments using type families and type-level lists. but, I have to wonder ... has someone already made this and put it on hackage?
2021-07-17 23:58:55	texasmynsted	[17:47:46] wait, why do you want a function with an arbitrary number of arguments?
2021-07-17 23:58:55	c_wraith	[17:49:03] usually to cover for a lack of other expressiveness
2021-07-17 23:58:55	c_wraith	[17:49:09] printf is a common example
2021-07-17 23:58:55	texasmynsted	[17:49:12] Seems to me ideally a function should have exactly one argument
2021-07-17 23:58:55	c_wraith	[17:49:19] We can't write the type it actually has in Haskell
2021-07-17 23:58:55	c_wraith	[17:49:25] Because it's a dependent type
2021-07-17 23:58:55	c_wraith	[17:49:51] So varargs lets us do it anyway and fail at runtime if the programmer got it wrong
2021-07-17 23:58:55	texasmynsted	[17:50:07] printf solves a problem in a particular way that I think could be solved better, differently 
2021-07-17 23:58:55	c_wraith	[17:50:18] differently?  sure.  Better?  Not really.
2021-07-17 23:58:55	hololeap	[17:50:21] the motivation was because I had a typeclass with a function, and I encountered some outliers that needed extra arguments passed to that function
2021-07-17 23:58:55	texasmynsted	[17:50:47] c_wraith: I am not convinced 
2021-07-17 23:58:55	hololeap	[17:50:48] I'd have to write up a blog post or something to get into all the details
2021-07-17 23:58:55	Rembane	[17:50:57] hololeap: Do it! :D
2021-07-17 23:58:55	texasmynsted	[17:51:08] yes, that would be a good read
2021-07-17 23:58:55	c_wraith	[17:51:15] printf is *really* good at doing exactly what it's intended for.  Compactly specifying output formatted for monospace devices.
2021-07-17 23:58:55	texasmynsted	[17:51:32] like regular expressions?
2021-07-17 23:58:55	c_wraith	[17:51:42] honestly, it's more useful
2021-07-17 23:58:55	c_wraith	[17:52:01] regular expressions have to involve things like capturing group to really be useful, and those complicate APIs tremendously
2021-07-17 23:58:55	c_wraith	[17:52:05] printf has no such problems
2021-07-17 23:58:55	texasmynsted	[17:52:20] Right. I think regular expressions work great but are terrible and the problem is better solved differently 
2021-07-17 23:58:55	EvanR	[17:52:46] compare and contrast serious uses of printf with the expanded version, replicate that across a code base like 50 times and compare xD
2021-07-17 23:58:55	EvanR	[17:53:12] also, printf for debugging
2021-07-17 23:58:55	EvanR	[17:53:25] debugging would be harsher without it
2021-07-17 23:58:55	EvanR	[17:54:27] I'm more interested with this case of some function sometimes needing more arguments
2021-07-17 23:58:55	texasmynsted	[17:56:04] I am still going with functions should have exactly one argument 
2021-07-17 23:58:55	hololeap	[17:56:30] I mean... they do, technically.
2021-07-17 23:58:55	texasmynsted	[17:57:38] yes
2021-07-17 23:58:55	EvanR	[17:58:02] if the difference is between argument type (A,B) and (A,B,C) it's about argument type and not number
2021-07-17 23:58:55	texasmynsted	[17:58:23] Okay now we are getting somewhere
2021-07-17 23:58:55	***	Playback Complete.
2021-07-17 23:59:01	--	Channel created on Sun, 25 Apr 2021 01:04:39
2021-07-18 00:00:14	<--	merijn (~merijn@83-160-49-249.ip.xs4all.nl) has quit (Ping timeout: 268 seconds)
2021-07-18 00:00:42	--	irc: disconnected from server
2021-07-18 00:01:23	-->	amanr (~therojjha@20.204.87.0) has joined #haskell
2021-07-18 00:01:23	--	Topic for #haskell is "https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org | Paste code/errors: https://paste.tomsmeding.com | tunes.org-style logging should be coming soon | Logs: https://ircbrowse.tomsmeding.com/browse/lchaskell"
2021-07-18 00:01:23	--	Topic set by geekosaur (~geekosaur@xmonad/geekosaur) on Mon, 14 Jun 2021 05:16:14
2021-07-18 00:01:23	--	Channel #haskell: 711 nicks (1 op, 0 voices, 710 normals)
2021-07-18 00:01:23	***	Buffer Playback...
2021-07-18 00:01:23	arkanoid	[10:23:16] the Error monad link is broken https://wiki.haskell.org/Errormonad.html
2021-07-18 00:01:23	kuribas	[10:45:22] How does haskell compare to other functional languages?  Looking a bit at SML and OCaml, it seems that haskell has far more libraries, and is more practical for real world projects (other than compilers etc).
2021-07-18 00:01:23	kuribas	[10:46:31] Of course scala and clojure are also popular, but I don't consider clojure a real functional language, it's more a lisp derivative.  And Scala is mostly multiparadigm, and also complex and overengineerd.
2021-07-18 00:01:23	arahael	[10:47:48] kuribas: I use haskell for most of my private hobby/side projects.  It's awesule, but I've used F# and Swift, which are somewhat OCaml-inspired.
2021-07-18 00:01:23	arahael	[10:48:25] kuribas: The biggest most profound difference with Haskell is that it's *lazy*, and has a really really good type system, but in practice that it's lazy makes a big difference to how you use haskell.
2021-07-18 00:01:23	kuribas	[10:48:54] arahael: how much libraries are there for F#?  Or does it just use the C# ecosystem?
2021-07-18 00:01:23	arahael	[10:49:05] F# is just another .NET language, really, yeah.
2021-07-18 00:01:23	arahael	[10:49:17] As is C#. :)
2021-07-18 00:01:23	kuribas	[10:49:20] doesn't that mean that most libraries aren't really made for FP?
2021-07-18 00:01:23	arahael	[10:50:00] Kinda.  The way F# copes with nulls is interesting. (It assumes there aren't any).
2021-07-18 00:01:23	kuribas	[10:50:41] then how do you test if a function returns null?
2021-07-18 00:01:23	arahael	[10:51:33] kuribas: That's a trap, yeah.  In earlier versions, you'd check for it explicitly, and the compiler lets you. But then, the compiler *elides* that check because it thinks better.
2021-07-18 00:01:23	arahael	[10:51:44] Hopefully they've changed that now.
2021-07-18 00:01:23	arahael	[10:53:33] Looks like they've changed it - suggesting instead to use pattern matching.  Far better: https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/values/null-values
2021-07-18 00:01:23	arahael	[10:53:59] But anyway, one difference is that Haskell is lazy, so your functions must not have side effects.
2021-07-18 00:01:23	arahael	[10:54:30] And since that practice is so strictly encouraged (otherwise you risk loosing your sanity), that has a flow-on effect to all of haskell's libraries, too.
2021-07-18 00:01:23	DigitalKiwi	[10:55:34] haskell is non-strict
2021-07-18 00:01:23	DigitalKiwi	[10:55:52] https://wiki.haskell.org/Lazy_vs._non-strict
2021-07-18 00:01:23	arahael	[10:56:01] Yeah - more accurate - thanks for that.
2021-07-18 00:01:23	DigitalKiwi	[10:56:34] speaking only for myself haskell programmers are lazy ;)
2021-07-18 00:01:23	arahael	[10:58:05] Hmm. :)
2021-07-18 00:01:23	DigitalKiwi	[11:01:36] and obsesssed with bottoms
2021-07-18 00:01:23	 *	DigitalKiwi [11:02:01] drops mic
2021-07-18 00:01:23	Rembane	[11:03:21] I like lazy bottoms and I cannot lie.
2021-07-18 00:01:23	 *	arahael [11:05:07] suddenly realises why bottom is drawn like _|_
2021-07-18 00:01:23	DigitalKiwi	[11:06:04] dibblego twitter avatar lolol
2021-07-18 00:01:23	kuribas	[11:08:21] arahael: so haskell is the only language that doesn't let you get away coding imperative OO in it?
2021-07-18 00:01:23	kuribas	[11:09:07] Although imperative style is still quite possible in haskell.  OO on the other hand is pretty hard.
2021-07-18 00:01:23	dibblego	[11:09:35] DigitalKiwi: that's BUMFISH
2021-07-18 00:01:23	DigitalKiwi	[11:10:01] is that a new operator
2021-07-18 00:01:23	dibblego	[11:11:41] no, it's a pre-landing checklist
2021-07-18 00:01:23	arahael	[11:13:08] Heh.
2021-07-18 00:01:23	arahael	[11:13:36] kuribas: If it's subtyping you're referring to, no, I don't think haskell has that.
2021-07-18 00:01:23	arahael	[11:13:58] kuribas: It does have classes and instances, though, but they behave quite differently.
2021-07-18 00:01:23	kuribas	[11:14:06] And that's a good thing...
2021-07-18 00:01:23	 *	arahael [11:14:25] thinks so.
2021-07-18 00:01:23	DigitalKiwi	[11:14:37] https://www.parsonsmatt.org/2017/02/17/object_oriented_programming_in_haskell.html
2021-07-18 00:01:23	DigitalKiwi	[11:16:43] https://hackage.haskell.org/package/hoop
2021-07-18 00:01:23	DigitalKiwi	[11:16:56] cue bot "haskell can do that!"
2021-07-18 00:01:23	dibblego	[11:22:23] DigitalKiwi: https://flightscope.gitlab.io/aircraft/checklist/eurofox.pdf page 1, top-right
2021-07-18 00:01:23	kuribas	[11:58:55] I've been accused of being a haskell lanuage zealot.  But actually I am interested in other languages (logic, FP, dependently typed, etc...).  It just doesn't seem to be useful to push for other languages that I know less...
2021-07-18 00:01:23	kuribas	[11:59:21] I could recommend F# instead of haskell, but I don't know it that well, so there is less benefit IMO...
2021-07-18 00:01:23	kuribas	[12:04:48] Every time I come with rational arguments, I get a reply like "But I don't like types, they get in the way".  Or "programming languages don't matter, business logic does".  Or "I don't care it's more robust, we want to move fast and solve bugs as we go".
2021-07-18 00:01:23	dibblego	[12:18:06] get used to it
2021-07-18 00:01:23	tom__	[12:18:47] kuribas: I feel your pain
2021-07-18 00:01:23	tom__	[12:19:43] "Types get in the way" then spends three hours NULL chasing
2021-07-18 00:01:23	kuribas	[12:20:50] tom__: exactly!  I spend far more time thinking about types in clojure than in haskell.
2021-07-18 00:01:23	maerwald	[12:21:11] types can get in the way, especially since haskell lacks structural typing
2021-07-18 00:01:23	tom__	[12:21:34] haha sometimes you want types to get in the way
2021-07-18 00:01:23	maerwald	[12:21:51] I know of at least one Haskell dev who now works full-time with typescript and doesn't regret it
2021-07-18 00:01:23	maerwald	[12:22:09] I probably wouldn't, but it's a valid position
2021-07-18 00:01:23	tom__	[12:22:55] Clojure to me is just javascript with some immutability
2021-07-18 00:01:23	kuribas	[12:23:22] maerwald: I find that often, it just amounts to having a bit more boilerplate.  Or having duplicate type definitions.
2021-07-18 00:01:23	maerwald	[12:23:40] it can be a *lot* of boilerplate
2021-07-18 00:01:23	maerwald	[12:24:00] and prohibits you of expressing certain relationships between data
2021-07-18 00:01:23	tom__	[12:24:19] Haskell, Rust and Julia - desert island stack
2021-07-18 00:01:23	tom__	[12:24:37] Havent tried the latter two :D
2021-07-18 00:01:23	maerwald	[12:24:58] class based solutions don't work well when you need an *actual* data type for serialisation
2021-07-18 00:01:23	maerwald	[12:25:45] typescript is surprisingly simple and powerful on these matters... certainly less elegant and unsound in a few places, but that's the tradeoff the make
2021-07-18 00:01:23	kuribas	[12:26:10] tom__: rust is only my "to learn list" :)
2021-07-18 00:01:23	kuribas	[12:26:42] maerwald: you can be less elegant and unsound in haskell too...
2021-07-18 00:01:23	maerwald	[12:27:02] kuribas: yeah, but that usually involves MORE complexity, not less
2021-07-18 00:01:23	maerwald	[12:27:10] so the opposite of typescript
2021-07-18 00:01:23	tom__	[12:27:22] You can be and then people who don't understand what a theoretical model is say that it must mean Haskell is pointless
2021-07-18 00:01:23	kuribas	[12:28:12] maerwald: I don't agree
2021-07-18 00:01:23	maerwald	[12:28:47] well, you *can* do some forms of structural typing/subtyping, but it all ends in esoteric libraries
2021-07-18 00:01:23	kuribas	[12:29:00] maerwald: so don't do it.
2021-07-18 00:01:23	maerwald	[12:29:03] while you get all that in TS for free without complexity
2021-07-18 00:01:23	maerwald	[12:29:45] well, I'm not commenting on which language is better, I'm just commenting on "types can get in the way", because they can
2021-07-18 00:01:23	kuribas	[12:29:55] maerwald: plenty of ways to get around that: 1) partially applied functions (the Endo trick), create a new type with some of the fields.  3) just make the fields all Maybe.
2021-07-18 00:01:23	kuribas	[12:30:56] maerwald: there is a difference between "the types sometimes get in the way", and "the types always get in the way", the latter is what they seem to be implying.
2021-07-18 00:01:23	maerwald	[12:31:02] 1) difficult for serialisation, Show instances, debugging, ... 2) boilerplate, 3) unexpressive, because now you have two cases of `Maybe`
2021-07-18 00:01:23	kuribas	[12:32:02] You don't need two cases of Maybe
2021-07-18 00:01:23	kuribas	[12:32:44] and 4) just put default values.
2021-07-18 00:01:23	maerwald	[12:33:32] 1. there's no such value, because the computation doesn't return one for the given input, 2. there's no such value, because the computation can *never* return one
2021-07-18 00:01:23	maerwald	[12:33:45] now you also have to wonder: 3. there's a value, but there shouldn't be one
2021-07-18 00:01:23	maerwald	[12:33:47] oops
2021-07-18 00:01:23	kuribas	[12:33:47] IMO, the more you want correctness, the more you are restricted in what you write.  It has nothing to do with types (directly).
2021-07-18 00:01:23	kuribas	[12:34:28] maerwald: if you grab to clojure, you don't care anyway...
2021-07-18 00:01:23	maerwald	[12:34:48] default values.. what's my default account balance? :p
2021-07-18 00:01:23	dibblego	[12:34:54] like I said, get used to it
2021-07-18 00:01:23	tom__	[12:35:20] ^ yes and get used to makeNegative = (*) -1
2021-07-18 00:01:23	kuribas	[12:35:49] Which is my point, haskell can be a nice unsafe language to.  Just make a big sum type, and partial functions over it (don't forget to add error messages though...).
2021-07-18 00:01:23	maerwald	[12:36:21] well, with structural typing you don't need to be partial
2021-07-18 00:01:23	int-e	[12:36:25] Or unsafeCoerce everything and program untyped lambda calculus? :)
2021-07-18 00:01:23	arahael	[12:36:48] kuribas: Mind you, Clojure seems to offer alternative methods to allow you to type ocrrect code.  In particular, Clojure seems to have a fantastic runtime repl.
2021-07-18 00:01:23	arahael	[12:37:15] kuribas: Such that you're running the live program and debugging it and replacing functions on the fly.
2021-07-18 00:01:23	int-e	[12:37:26] I like types, they prevent some of the more embarrassing programming errors from being run as code.
2021-07-18 00:01:23	tom__	[12:37:44] Revenge is forcing them to write a web app in the Lean proof assistant fully verified.
2021-07-18 00:01:23	tom__	[12:37:49] It has IO.
2021-07-18 00:01:23	maerwald	[12:38:25] right... clojure: forget a closing  bracket, code still compiles, but doesn't compute prime numbers... instead it compiles to a chess engine
2021-07-18 00:01:23	tom__	[12:38:42] haha
2021-07-18 00:01:23	maerwald	[12:38:45] type safe? Yeah maybe. But.
2021-07-18 00:01:23	kuribas	[12:38:48] arahael: I think you never actually used clojure?
2021-07-18 00:01:23	int-e	[12:39:03] tom__: That's deep in "overdoing it" territory. At least if the specification is anything more elaborate than "something in, something out", and even that may be tricky if you interpret it as a promise to fulfil request in finite time.
2021-07-18 00:01:23	kuribas	[12:39:26] arahael: it's a very mediocre runtime IMO, compared to java.  Error messages are nearly incomprehensible.  Tracing is nice though...
2021-07-18 00:01:23	tom__	[12:39:39] int-e: Yeah pointless torture :)
2021-07-18 00:01:23	maerwald	[12:39:50] the only upside of clojure is interactive development
2021-07-18 00:01:23	tom__	[12:40:08] The haskell compiler feels pretty interactive
2021-07-18 00:01:23	maerwald	[12:40:29] if HLS works, maybe
2021-07-18 00:01:23	arahael	[12:40:37] kuribas: Seemed to be effective enough.
2021-07-18 00:01:23	arahael	[12:40:53] But no, I haven't personally used it.
2021-07-18 00:01:23	maerwald	[12:41:00] but on the other hand: usually not. Compile times are too slow
2021-07-18 00:01:23	kuribas	[12:41:12] arahael: clojurists just have a different idea of "correct code".
2021-07-18 00:01:23	arahael	[12:41:15] I personally quite like ghcid.
2021-07-18 00:01:23	arahael	[12:41:27] kuribas: Indeed, but I think it's the process of discovery that they like.
2021-07-18 00:01:23	arahael	[12:41:57] kuribas: In haskell, we seem to prefer to test functions in isolation. Clojure people seem to prefer to test functions in the live system.
2021-07-18 00:01:23	maerwald	[12:42:00] if you're working on 300+ modules and your Type module has a whitespace change, you're gonna need to restart cabal a few times, because your machine OOMed due to TH
2021-07-18 00:01:23	tom__	[12:42:18] Which library is recommended for sampling probability distributions?
2021-07-18 00:01:23	arahael	[12:42:42] maerwald: The amount of memory Haskell uses is crazy high.  Sadly, I find it way faster than Swift. :/
2021-07-18 00:01:23	kuribas	[12:45:45] arahael: lispers will boast about how easy it is to hot patch live systems.  They don't tell you that it becomes very hard to see who changed what and when.
2021-07-18 00:01:23	kuribas	[12:46:05] arahael: so you'll end up with CI/CD anyway.  
2021-07-18 00:01:23	kuribas	[12:46:34] However a theoretically, a "live" programming environment with integrated version control could be nice.
2021-07-18 00:01:23	kuribas	[12:46:44] I don't know if that ever has been done.
2021-07-18 00:01:23	maerwald	[12:47:32] https://hackage.haskell.org/package/optics-th-0.4/docs/Optics-TH.html#v:makeClassy
2021-07-18 00:01:23	maerwald	[12:47:34] https://hackage.haskell.org/package/optics-th-0.4/docs/Optics-TH.html#v:makeFieldsNoPrefix
2021-07-18 00:01:23	maerwald	[12:47:36] https://hackage.haskell.org/package/generic-optics-2.2.0.0/docs/Data-Generics-Product-Fields.html#t:HasField
2021-07-18 00:01:23	maerwald	[12:47:38] which one of those to pick?
2021-07-18 00:01:23	maerwald	[12:49:00] HasField is kinda cool with those neat type errors
2021-07-18 00:01:23	boxscape	[15:15:35] maerwald: the TH versions say "This method of optics generation should only be used when migrating an existing codebase from the lens library to optics"
2021-07-18 00:01:23	boxscape	[15:15:51] maerwald: this, my final answer is C
2021-07-18 00:01:23	boxscape	[15:15:56] s/this/thus
2021-07-18 00:01:23	maerwald	[15:16:07] HasField?
2021-07-18 00:01:23	boxscape	[15:16:46] yeah.. though I thought there was a version of that which uses OverloadedLabels
2021-07-18 00:01:23	maerwald	[15:17:20] HasField though doesn't allow arbitrary subtyping... it's a simple getter
2021-07-18 00:01:23	maerwald	[15:17:54] with makeClassy style classes you could descend deeper into the structure with the same getter
2021-07-18 00:01:23	boxscape	[15:18:30] maerwald: oh actually the TH version links to https://hackage.haskell.org/package/optics-core-0.4/docs/Optics-Label.html as preferred solution
2021-07-18 00:01:23	boxscape	[15:19:03] that's the OverloadedLabels version I was remembering
2021-07-18 00:01:23	maerwald	[15:22:44] so there you could also define custom LabelOptic instances that descend into a structure?
2021-07-18 00:01:23	boxscape	[15:23:27] that seems plausible but I haven't tried doing it
2021-07-18 00:01:23	maerwald	[15:23:47] I'm leaning towards makeClassy, but I'm not sure
2021-07-18 00:01:23	boxscape	[15:24:25] I like makeClassy, the main reason I would avoid it personally is that the documentation advises against it
2021-07-18 00:01:23	maerwald	[15:25:40] so what does LabelOptic give over HasField?
2021-07-18 00:01:23	texasmynsted	[15:26:17] What is the modern answer to haskell records? Lens?
2021-07-18 00:01:23	maerwald	[15:26:49] only difference I see is labelOptic is `Optic` and HasField is a `Lens`
2021-07-18 00:01:23	boxscape	[15:28:24] hm I'm not sure what the concrete differences are
2021-07-18 00:01:23	boxscape	[15:30:52] texasmynsted: there are a few answers to this: In the next version, OverloadedRecordDot is being introduces, which allows one to write something like `personA.company.name`. (Updates are a bit iffy but will improve over time.) In the meantime, lens is definitely still widely used, though optics is a replacement which aims to have better error messages. There is also some research going into row types, but that's further out.
2021-07-18 00:01:23	boxscape	[15:30:55] s/next version/next version of GHC
2021-07-18 00:01:23	boxscape	[15:32:08] (though regarding row types, the vinyl records package allows something similar today)
2021-07-18 00:01:23	Guest14	[16:03:05] Hello :)
2021-07-18 00:01:23	Guest14	[16:03:40] I am new to Haskell and am working through the Real World Haskell Book
2021-07-18 00:01:23	Guest14	[16:04:27] I have a basic question if anyone would care to listen
2021-07-18 00:01:23	allbery_b	[16:06:02] best to just ask it rather than asking to ask
2021-07-18 00:01:23	davean	[16:06:23] asking to ask is why I wasn't helping
2021-07-18 00:01:23	Guest14	[16:07:44] splitWith _ [] = []
2021-07-18 00:01:23	Guest14	[16:07:45] splitWith a xs = [pre ++ [x]] ++ next
2021-07-18 00:01:23	Guest14	[16:07:45]     where 
2021-07-18 00:01:23	Guest14	[16:07:46]         (pre, x:suf) = span a xs
2021-07-18 00:01:23	Guest14	[16:07:46]         next = splitWith a suf
2021-07-18 00:01:23	Guest14	[16:08:10] I have this program and I run into a problem with x:suf when span a xs is [] becuase there is no head
2021-07-18 00:01:23	int-e	[16:09:34] > let f = splitAt 1 in (f "abc", f "")
2021-07-18 00:01:23	lambdabot	[16:09:36]  (("a","bc"),("",""))
2021-07-18 00:01:23	int-e	[16:11:31] (So maybe use splitAt instead of the x:suf pattern.)
2021-07-18 00:01:23	maerwald	[16:11:39] was there a question yet?
2021-07-18 00:01:23	davean	[16:11:45] No
2021-07-18 00:01:23	Guest14	[16:12:09] Ok I will give that a try thanks
2021-07-18 00:01:23	int-e	[16:12:10] They described a problem, close enough.
2021-07-18 00:01:23	maerwald	[16:12:35] They also described the answer
2021-07-18 00:01:23	maerwald	[16:12:38] "there is no head"
2021-07-18 00:01:23	int-e	[16:12:47] @where paste
2021-07-18 00:01:23	lambdabot	[16:12:47] Help us help you: please paste full code, input and/or output at e.g. https://paste.tomsmeding.com
2021-07-18 00:01:23	int-e	[16:13:04] maerwald: That's the reason, but not a solution for the problem?
2021-07-18 00:01:23	 *	int-e [16:13:06] shrugs
2021-07-18 00:01:23	maerwald	[16:13:10] So my answer is: yes
2021-07-18 00:01:23	int-e	[16:13:28] Well, so sorry for trying to be helpful.
2021-07-18 00:01:23	davean	[16:14:09] int-e: oh do be helpful
2021-07-18 00:01:23	Guest14	[16:15:14] int-e that worked thank you
2021-07-18 00:01:23	texasmynsted	[16:20:42] thank you boxscape 
2021-07-18 00:01:23	texasmynsted	[16:21:29] Sounds like optics or vinyl for now
2021-07-18 00:01:23	sm	[16:31:11] g'day all. Speaking of optics.. you experienced [lens] coders, do you find it good or bad for (a) fields and (b) lenses to be visually disctinct from other kinds of bindings (functions, "variables") ? As in eg _field/lens_, field_/lens__, _field/lensL, .... ?
2021-07-18 00:01:23	sm	[16:32:24] I feel it would be good overall, for avoiding collisions and for human comprehension . But I don't have a lot of lens experience
2021-07-18 00:01:23	maerwald	[16:40:10] can you derive LabelOptic with deriving via for an inner type? 
2021-07-18 00:01:23	oso	[16:42:50] xpost from #haskell-beginners:
2021-07-18 00:01:23	oso	[16:42:52] I'm passing around a type synonym for Int, but in reality the only constraint it needs to  follow is that it's hashable. what constructor do i use for this? my brain says go from `type UID = Int` to `data UID a = Hashable a` but that's very not correct, and google isn't helping much
2021-07-18 00:01:23	oso	[16:43:21] nvm sorry got an answer there
2021-07-18 00:01:23	glguy	[16:54:37] oso, if you just need to know that something is hashable you'd use it like: stuff :: Hashable a => a -> b -> c
2021-07-18 00:01:23	glguy	[16:55:19] If a parameter is the uid parameter you can document that like:  stuff :: Hashable uid => uid {- ^ the UID -} -> etc
2021-07-18 00:01:23	oso	[16:55:35] I was trying to do that while also using types to keep my signatures from becoming unwieldy, but first i'll just worry about getting the code working
2021-07-18 00:01:23	glguy	[16:56:22] the documentation for parameters goes in the haddock comments rather than type synonyms
2021-07-18 00:01:23	oso	[16:56:43] mmk
2021-07-18 00:01:23	dsal	[17:05:40] oso: It's tempting to put constraints in the type definitions, but if you take a look at, for example, `Data.Map.Strict` you'll see the type definition is just `data Map k a`.  You'd think k would always have to be ordered, but that's not the case.  You can create and work on maps that have unorderable keys when you don't do things that require ordering.  e.g.:
2021-07-18 00:01:23	dsal	[17:05:42] > M.elems $ (* 2) <$> M.singleton id 3
2021-07-18 00:01:23	lambdabot	[17:05:43]  [6]
2021-07-18 00:01:23	dsal	[17:07:10] The idea is that you only have to constrain things where they actually need to be constrained.  The Functor instance, e.g., doesn't care about the keys at all, so why should it require they're ordered?
2021-07-18 00:01:23	oso	[17:13:45] got it working \o/
2021-07-18 00:01:23	oso	[17:13:47] thank you
2021-07-18 00:01:23	hololeap	[17:46:09] so, I figured out a way to make a function with an arbitrary number of arguments using type families and type-level lists. but, I have to wonder ... has someone already made this and put it on hackage?
2021-07-18 00:01:23	texasmynsted	[17:47:46] wait, why do you want a function with an arbitrary number of arguments?
2021-07-18 00:01:23	c_wraith	[17:49:03] usually to cover for a lack of other expressiveness
2021-07-18 00:01:23	c_wraith	[17:49:09] printf is a common example
2021-07-18 00:01:23	texasmynsted	[17:49:12] Seems to me ideally a function should have exactly one argument
2021-07-18 00:01:23	c_wraith	[17:49:19] We can't write the type it actually has in Haskell
2021-07-18 00:01:23	c_wraith	[17:49:25] Because it's a dependent type
2021-07-18 00:01:23	c_wraith	[17:49:51] So varargs lets us do it anyway and fail at runtime if the programmer got it wrong
2021-07-18 00:01:23	texasmynsted	[17:50:07] printf solves a problem in a particular way that I think could be solved better, differently 
2021-07-18 00:01:23	c_wraith	[17:50:18] differently?  sure.  Better?  Not really.
2021-07-18 00:01:23	hololeap	[17:50:21] the motivation was because I had a typeclass with a function, and I encountered some outliers that needed extra arguments passed to that function
2021-07-18 00:01:23	texasmynsted	[17:50:47] c_wraith: I am not convinced 
2021-07-18 00:01:23	hololeap	[17:50:48] I'd have to write up a blog post or something to get into all the details
2021-07-18 00:01:23	Rembane	[17:50:57] hololeap: Do it! :D
2021-07-18 00:01:23	texasmynsted	[17:51:08] yes, that would be a good read
2021-07-18 00:01:23	c_wraith	[17:51:15] printf is *really* good at doing exactly what it's intended for.  Compactly specifying output formatted for monospace devices.
2021-07-18 00:01:23	texasmynsted	[17:51:32] like regular expressions?
2021-07-18 00:01:23	c_wraith	[17:51:42] honestly, it's more useful
2021-07-18 00:01:23	c_wraith	[17:52:01] regular expressions have to involve things like capturing group to really be useful, and those complicate APIs tremendously
2021-07-18 00:01:23	c_wraith	[17:52:05] printf has no such problems
2021-07-18 00:01:23	texasmynsted	[17:52:20] Right. I think regular expressions work great but are terrible and the problem is better solved differently 
2021-07-18 00:01:23	EvanR	[17:52:46] compare and contrast serious uses of printf with the expanded version, replicate that across a code base like 50 times and compare xD
2021-07-18 00:01:23	EvanR	[17:53:12] also, printf for debugging
2021-07-18 00:01:23	EvanR	[17:53:25] debugging would be harsher without it
2021-07-18 00:01:23	EvanR	[17:54:27] I'm more interested with this case of some function sometimes needing more arguments
2021-07-18 00:01:23	texasmynsted	[17:56:04] I am still going with functions should have exactly one argument 
2021-07-18 00:01:23	hololeap	[17:56:30] I mean... they do, technically.
2021-07-18 00:01:23	texasmynsted	[17:57:38] yes
2021-07-18 00:01:23	EvanR	[17:58:02] if the difference is between argument type (A,B) and (A,B,C) it's about argument type and not number
2021-07-18 00:01:23	texasmynsted	[17:58:23] Okay now we are getting somewhere
2021-07-18 00:01:23	***	Playback Complete.
2021-07-18 00:01:32	--	Channel created on Sun, 25 Apr 2021 01:04:39
2021-07-18 00:06:47	--	irc: disconnected from server
2021-07-18 01:15:18	-->	amanr (~therojjha@20.204.87.0) has joined #haskell
2021-07-18 01:15:18	--	Topic for #haskell is "https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org | Paste code/errors: https://paste.tomsmeding.com | tunes.org-style logging should be coming soon | Logs: https://ircbrowse.tomsmeding.com/browse/lchaskell"
2021-07-18 01:15:18	--	Topic set by geekosaur (~geekosaur@xmonad/geekosaur) on Mon, 14 Jun 2021 05:16:14
2021-07-18 01:15:18	--	Channel #haskell: 702 nicks (1 op, 0 voices, 701 normals)
2021-07-18 01:15:18	***	Buffer Playback...
2021-07-18 01:15:18	arkanoid	[10:23:16] the Error monad link is broken https://wiki.haskell.org/Errormonad.html
2021-07-18 01:15:18	kuribas	[10:45:22] How does haskell compare to other functional languages?  Looking a bit at SML and OCaml, it seems that haskell has far more libraries, and is more practical for real world projects (other than compilers etc).
2021-07-18 01:15:18	kuribas	[10:46:31] Of course scala and clojure are also popular, but I don't consider clojure a real functional language, it's more a lisp derivative.  And Scala is mostly multiparadigm, and also complex and overengineerd.
2021-07-18 01:15:18	arahael	[10:47:48] kuribas: I use haskell for most of my private hobby/side projects.  It's awesule, but I've used F# and Swift, which are somewhat OCaml-inspired.
2021-07-18 01:15:18	arahael	[10:48:25] kuribas: The biggest most profound difference with Haskell is that it's *lazy*, and has a really really good type system, but in practice that it's lazy makes a big difference to how you use haskell.
2021-07-18 01:15:18	kuribas	[10:48:54] arahael: how much libraries are there for F#?  Or does it just use the C# ecosystem?
2021-07-18 01:15:18	arahael	[10:49:05] F# is just another .NET language, really, yeah.
2021-07-18 01:15:18	arahael	[10:49:17] As is C#. :)
2021-07-18 01:15:18	kuribas	[10:49:20] doesn't that mean that most libraries aren't really made for FP?
2021-07-18 01:15:18	arahael	[10:50:00] Kinda.  The way F# copes with nulls is interesting. (It assumes there aren't any).
2021-07-18 01:15:18	kuribas	[10:50:41] then how do you test if a function returns null?
2021-07-18 01:15:18	arahael	[10:51:33] kuribas: That's a trap, yeah.  In earlier versions, you'd check for it explicitly, and the compiler lets you. But then, the compiler *elides* that check because it thinks better.
2021-07-18 01:15:18	arahael	[10:51:44] Hopefully they've changed that now.
2021-07-18 01:15:18	arahael	[10:53:33] Looks like they've changed it - suggesting instead to use pattern matching.  Far better: https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/values/null-values
2021-07-18 01:15:18	arahael	[10:53:59] But anyway, one difference is that Haskell is lazy, so your functions must not have side effects.
2021-07-18 01:15:18	arahael	[10:54:30] And since that practice is so strictly encouraged (otherwise you risk loosing your sanity), that has a flow-on effect to all of haskell's libraries, too.
2021-07-18 01:15:18	DigitalKiwi	[10:55:34] haskell is non-strict
2021-07-18 01:15:18	DigitalKiwi	[10:55:52] https://wiki.haskell.org/Lazy_vs._non-strict
2021-07-18 01:15:18	arahael	[10:56:01] Yeah - more accurate - thanks for that.
2021-07-18 01:15:18	DigitalKiwi	[10:56:34] speaking only for myself haskell programmers are lazy ;)
2021-07-18 01:15:18	arahael	[10:58:05] Hmm. :)
2021-07-18 01:15:18	DigitalKiwi	[11:01:36] and obsesssed with bottoms
2021-07-18 01:15:18	 *	DigitalKiwi [11:02:01] drops mic
2021-07-18 01:15:18	Rembane	[11:03:21] I like lazy bottoms and I cannot lie.
2021-07-18 01:15:18	 *	arahael [11:05:07] suddenly realises why bottom is drawn like _|_
2021-07-18 01:15:18	DigitalKiwi	[11:06:04] dibblego twitter avatar lolol
2021-07-18 01:15:18	kuribas	[11:08:21] arahael: so haskell is the only language that doesn't let you get away coding imperative OO in it?
2021-07-18 01:15:18	kuribas	[11:09:07] Although imperative style is still quite possible in haskell.  OO on the other hand is pretty hard.
2021-07-18 01:15:18	dibblego	[11:09:35] DigitalKiwi: that's BUMFISH
2021-07-18 01:15:18	DigitalKiwi	[11:10:01] is that a new operator
2021-07-18 01:15:18	dibblego	[11:11:41] no, it's a pre-landing checklist
2021-07-18 01:15:18	arahael	[11:13:08] Heh.
2021-07-18 01:15:18	arahael	[11:13:36] kuribas: If it's subtyping you're referring to, no, I don't think haskell has that.
2021-07-18 01:15:18	arahael	[11:13:58] kuribas: It does have classes and instances, though, but they behave quite differently.
2021-07-18 01:15:18	kuribas	[11:14:06] And that's a good thing...
2021-07-18 01:15:18	 *	arahael [11:14:25] thinks so.
2021-07-18 01:15:18	DigitalKiwi	[11:14:37] https://www.parsonsmatt.org/2017/02/17/object_oriented_programming_in_haskell.html
2021-07-18 01:15:18	DigitalKiwi	[11:16:43] https://hackage.haskell.org/package/hoop
2021-07-18 01:15:18	DigitalKiwi	[11:16:56] cue bot "haskell can do that!"
2021-07-18 01:15:18	dibblego	[11:22:23] DigitalKiwi: https://flightscope.gitlab.io/aircraft/checklist/eurofox.pdf page 1, top-right
2021-07-18 01:15:18	kuribas	[11:58:55] I've been accused of being a haskell lanuage zealot.  But actually I am interested in other languages (logic, FP, dependently typed, etc...).  It just doesn't seem to be useful to push for other languages that I know less...
2021-07-18 01:15:18	kuribas	[11:59:21] I could recommend F# instead of haskell, but I don't know it that well, so there is less benefit IMO...
2021-07-18 01:15:18	kuribas	[12:04:48] Every time I come with rational arguments, I get a reply like "But I don't like types, they get in the way".  Or "programming languages don't matter, business logic does".  Or "I don't care it's more robust, we want to move fast and solve bugs as we go".
2021-07-18 01:15:18	dibblego	[12:18:06] get used to it
2021-07-18 01:15:18	tom__	[12:18:47] kuribas: I feel your pain
2021-07-18 01:15:18	tom__	[12:19:43] "Types get in the way" then spends three hours NULL chasing
2021-07-18 01:15:18	kuribas	[12:20:50] tom__: exactly!  I spend far more time thinking about types in clojure than in haskell.
2021-07-18 01:15:18	maerwald	[12:21:11] types can get in the way, especially since haskell lacks structural typing
2021-07-18 01:15:18	tom__	[12:21:34] haha sometimes you want types to get in the way
2021-07-18 01:15:18	maerwald	[12:21:51] I know of at least one Haskell dev who now works full-time with typescript and doesn't regret it
2021-07-18 01:15:18	maerwald	[12:22:09] I probably wouldn't, but it's a valid position
2021-07-18 01:15:18	tom__	[12:22:55] Clojure to me is just javascript with some immutability
2021-07-18 01:15:18	kuribas	[12:23:22] maerwald: I find that often, it just amounts to having a bit more boilerplate.  Or having duplicate type definitions.
2021-07-18 01:15:18	maerwald	[12:23:40] it can be a *lot* of boilerplate
2021-07-18 01:15:18	maerwald	[12:24:00] and prohibits you of expressing certain relationships between data
2021-07-18 01:15:18	tom__	[12:24:19] Haskell, Rust and Julia - desert island stack
2021-07-18 01:15:18	tom__	[12:24:37] Havent tried the latter two :D
2021-07-18 01:15:18	maerwald	[12:24:58] class based solutions don't work well when you need an *actual* data type for serialisation
2021-07-18 01:15:18	maerwald	[12:25:45] typescript is surprisingly simple and powerful on these matters... certainly less elegant and unsound in a few places, but that's the tradeoff the make
2021-07-18 01:15:18	kuribas	[12:26:10] tom__: rust is only my "to learn list" :)
2021-07-18 01:15:18	kuribas	[12:26:42] maerwald: you can be less elegant and unsound in haskell too...
2021-07-18 01:15:18	maerwald	[12:27:02] kuribas: yeah, but that usually involves MORE complexity, not less
2021-07-18 01:15:18	maerwald	[12:27:10] so the opposite of typescript
2021-07-18 01:15:18	tom__	[12:27:22] You can be and then people who don't understand what a theoretical model is say that it must mean Haskell is pointless
2021-07-18 01:15:18	kuribas	[12:28:12] maerwald: I don't agree
2021-07-18 01:15:18	maerwald	[12:28:47] well, you *can* do some forms of structural typing/subtyping, but it all ends in esoteric libraries
2021-07-18 01:15:18	kuribas	[12:29:00] maerwald: so don't do it.
2021-07-18 01:15:18	maerwald	[12:29:03] while you get all that in TS for free without complexity
2021-07-18 01:15:18	maerwald	[12:29:45] well, I'm not commenting on which language is better, I'm just commenting on "types can get in the way", because they can
2021-07-18 01:15:18	kuribas	[12:29:55] maerwald: plenty of ways to get around that: 1) partially applied functions (the Endo trick), create a new type with some of the fields.  3) just make the fields all Maybe.
2021-07-18 01:15:18	kuribas	[12:30:56] maerwald: there is a difference between "the types sometimes get in the way", and "the types always get in the way", the latter is what they seem to be implying.
2021-07-18 01:15:18	maerwald	[12:31:02] 1) difficult for serialisation, Show instances, debugging, ... 2) boilerplate, 3) unexpressive, because now you have two cases of `Maybe`
2021-07-18 01:15:18	kuribas	[12:32:02] You don't need two cases of Maybe
2021-07-18 01:15:18	kuribas	[12:32:44] and 4) just put default values.
2021-07-18 01:15:18	maerwald	[12:33:32] 1. there's no such value, because the computation doesn't return one for the given input, 2. there's no such value, because the computation can *never* return one
2021-07-18 01:15:18	maerwald	[12:33:45] now you also have to wonder: 3. there's a value, but there shouldn't be one
2021-07-18 01:15:18	maerwald	[12:33:47] oops
2021-07-18 01:15:18	kuribas	[12:33:47] IMO, the more you want correctness, the more you are restricted in what you write.  It has nothing to do with types (directly).
2021-07-18 01:15:18	kuribas	[12:34:28] maerwald: if you grab to clojure, you don't care anyway...
2021-07-18 01:15:18	maerwald	[12:34:48] default values.. what's my default account balance? :p
2021-07-18 01:15:18	dibblego	[12:34:54] like I said, get used to it
2021-07-18 01:15:18	tom__	[12:35:20] ^ yes and get used to makeNegative = (*) -1
2021-07-18 01:15:18	kuribas	[12:35:49] Which is my point, haskell can be a nice unsafe language to.  Just make a big sum type, and partial functions over it (don't forget to add error messages though...).
2021-07-18 01:15:18	maerwald	[12:36:21] well, with structural typing you don't need to be partial
2021-07-18 01:15:18	int-e	[12:36:25] Or unsafeCoerce everything and program untyped lambda calculus? :)
2021-07-18 01:15:18	arahael	[12:36:48] kuribas: Mind you, Clojure seems to offer alternative methods to allow you to type ocrrect code.  In particular, Clojure seems to have a fantastic runtime repl.
2021-07-18 01:15:18	arahael	[12:37:15] kuribas: Such that you're running the live program and debugging it and replacing functions on the fly.
2021-07-18 01:15:18	int-e	[12:37:26] I like types, they prevent some of the more embarrassing programming errors from being run as code.
2021-07-18 01:15:18	tom__	[12:37:44] Revenge is forcing them to write a web app in the Lean proof assistant fully verified.
2021-07-18 01:15:18	tom__	[12:37:49] It has IO.
2021-07-18 01:15:18	maerwald	[12:38:25] right... clojure: forget a closing  bracket, code still compiles, but doesn't compute prime numbers... instead it compiles to a chess engine
2021-07-18 01:15:18	tom__	[12:38:42] haha
2021-07-18 01:15:18	maerwald	[12:38:45] type safe? Yeah maybe. But.
2021-07-18 01:15:18	kuribas	[12:38:48] arahael: I think you never actually used clojure?
2021-07-18 01:15:18	int-e	[12:39:03] tom__: That's deep in "overdoing it" territory. At least if the specification is anything more elaborate than "something in, something out", and even that may be tricky if you interpret it as a promise to fulfil request in finite time.
2021-07-18 01:15:18	kuribas	[12:39:26] arahael: it's a very mediocre runtime IMO, compared to java.  Error messages are nearly incomprehensible.  Tracing is nice though...
2021-07-18 01:15:18	tom__	[12:39:39] int-e: Yeah pointless torture :)
2021-07-18 01:15:18	maerwald	[12:39:50] the only upside of clojure is interactive development
2021-07-18 01:15:18	tom__	[12:40:08] The haskell compiler feels pretty interactive
2021-07-18 01:15:18	maerwald	[12:40:29] if HLS works, maybe
2021-07-18 01:15:18	arahael	[12:40:37] kuribas: Seemed to be effective enough.
2021-07-18 01:15:18	arahael	[12:40:53] But no, I haven't personally used it.
2021-07-18 01:15:18	maerwald	[12:41:00] but on the other hand: usually not. Compile times are too slow
2021-07-18 01:15:18	kuribas	[12:41:12] arahael: clojurists just have a different idea of "correct code".
2021-07-18 01:15:18	arahael	[12:41:15] I personally quite like ghcid.
2021-07-18 01:15:18	arahael	[12:41:27] kuribas: Indeed, but I think it's the process of discovery that they like.
2021-07-18 01:15:18	arahael	[12:41:57] kuribas: In haskell, we seem to prefer to test functions in isolation. Clojure people seem to prefer to test functions in the live system.
2021-07-18 01:15:18	maerwald	[12:42:00] if you're working on 300+ modules and your Type module has a whitespace change, you're gonna need to restart cabal a few times, because your machine OOMed due to TH
2021-07-18 01:15:18	tom__	[12:42:18] Which library is recommended for sampling probability distributions?
2021-07-18 01:15:18	arahael	[12:42:42] maerwald: The amount of memory Haskell uses is crazy high.  Sadly, I find it way faster than Swift. :/
2021-07-18 01:15:18	kuribas	[12:45:45] arahael: lispers will boast about how easy it is to hot patch live systems.  They don't tell you that it becomes very hard to see who changed what and when.
2021-07-18 01:15:18	kuribas	[12:46:05] arahael: so you'll end up with CI/CD anyway.  
2021-07-18 01:15:18	kuribas	[12:46:34] However a theoretically, a "live" programming environment with integrated version control could be nice.
2021-07-18 01:15:18	kuribas	[12:46:44] I don't know if that ever has been done.
2021-07-18 01:15:18	maerwald	[12:47:32] https://hackage.haskell.org/package/optics-th-0.4/docs/Optics-TH.html#v:makeClassy
2021-07-18 01:15:18	maerwald	[12:47:34] https://hackage.haskell.org/package/optics-th-0.4/docs/Optics-TH.html#v:makeFieldsNoPrefix
2021-07-18 01:15:18	maerwald	[12:47:36] https://hackage.haskell.org/package/generic-optics-2.2.0.0/docs/Data-Generics-Product-Fields.html#t:HasField
2021-07-18 01:15:18	maerwald	[12:47:38] which one of those to pick?
2021-07-18 01:15:18	maerwald	[12:49:00] HasField is kinda cool with those neat type errors
2021-07-18 01:15:18	boxscape	[15:15:35] maerwald: the TH versions say "This method of optics generation should only be used when migrating an existing codebase from the lens library to optics"
2021-07-18 01:15:18	boxscape	[15:15:51] maerwald: this, my final answer is C
2021-07-18 01:15:18	boxscape	[15:15:56] s/this/thus
2021-07-18 01:15:18	maerwald	[15:16:07] HasField?
2021-07-18 01:15:18	boxscape	[15:16:46] yeah.. though I thought there was a version of that which uses OverloadedLabels
2021-07-18 01:15:18	maerwald	[15:17:20] HasField though doesn't allow arbitrary subtyping... it's a simple getter
2021-07-18 01:15:18	maerwald	[15:17:54] with makeClassy style classes you could descend deeper into the structure with the same getter
2021-07-18 01:15:18	boxscape	[15:18:30] maerwald: oh actually the TH version links to https://hackage.haskell.org/package/optics-core-0.4/docs/Optics-Label.html as preferred solution
2021-07-18 01:15:18	boxscape	[15:19:03] that's the OverloadedLabels version I was remembering
2021-07-18 01:15:18	maerwald	[15:22:44] so there you could also define custom LabelOptic instances that descend into a structure?
2021-07-18 01:15:18	boxscape	[15:23:27] that seems plausible but I haven't tried doing it
2021-07-18 01:15:18	maerwald	[15:23:47] I'm leaning towards makeClassy, but I'm not sure
2021-07-18 01:15:18	boxscape	[15:24:25] I like makeClassy, the main reason I would avoid it personally is that the documentation advises against it
2021-07-18 01:15:18	maerwald	[15:25:40] so what does LabelOptic give over HasField?
2021-07-18 01:15:18	texasmynsted	[15:26:17] What is the modern answer to haskell records? Lens?
2021-07-18 01:15:18	maerwald	[15:26:49] only difference I see is labelOptic is `Optic` and HasField is a `Lens`
2021-07-18 01:15:18	boxscape	[15:28:24] hm I'm not sure what the concrete differences are
2021-07-18 01:15:18	boxscape	[15:30:52] texasmynsted: there are a few answers to this: In the next version, OverloadedRecordDot is being introduces, which allows one to write something like `personA.company.name`. (Updates are a bit iffy but will improve over time.) In the meantime, lens is definitely still widely used, though optics is a replacement which aims to have better error messages. There is also some research going into row types, but that's further out.
2021-07-18 01:15:18	boxscape	[15:30:55] s/next version/next version of GHC
2021-07-18 01:15:18	boxscape	[15:32:08] (though regarding row types, the vinyl records package allows something similar today)
2021-07-18 01:15:18	Guest14	[16:03:05] Hello :)
2021-07-18 01:15:18	Guest14	[16:03:40] I am new to Haskell and am working through the Real World Haskell Book
2021-07-18 01:15:18	Guest14	[16:04:27] I have a basic question if anyone would care to listen
2021-07-18 01:15:18	allbery_b	[16:06:02] best to just ask it rather than asking to ask
2021-07-18 01:15:18	davean	[16:06:23] asking to ask is why I wasn't helping
2021-07-18 01:15:18	Guest14	[16:07:44] splitWith _ [] = []
2021-07-18 01:15:18	Guest14	[16:07:45] splitWith a xs = [pre ++ [x]] ++ next
2021-07-18 01:15:18	Guest14	[16:07:45]     where 
2021-07-18 01:15:18	Guest14	[16:07:46]         (pre, x:suf) = span a xs
2021-07-18 01:15:18	Guest14	[16:07:46]         next = splitWith a suf
2021-07-18 01:15:18	Guest14	[16:08:10] I have this program and I run into a problem with x:suf when span a xs is [] becuase there is no head
2021-07-18 01:15:18	int-e	[16:09:34] > let f = splitAt 1 in (f "abc", f "")
2021-07-18 01:15:18	lambdabot	[16:09:36]  (("a","bc"),("",""))
2021-07-18 01:15:18	int-e	[16:11:31] (So maybe use splitAt instead of the x:suf pattern.)
2021-07-18 01:15:18	maerwald	[16:11:39] was there a question yet?
2021-07-18 01:15:18	davean	[16:11:45] No
2021-07-18 01:15:18	Guest14	[16:12:09] Ok I will give that a try thanks
2021-07-18 01:15:18	int-e	[16:12:10] They described a problem, close enough.
2021-07-18 01:15:18	maerwald	[16:12:35] They also described the answer
2021-07-18 01:15:18	maerwald	[16:12:38] "there is no head"
2021-07-18 01:15:18	int-e	[16:12:47] @where paste
2021-07-18 01:15:18	lambdabot	[16:12:47] Help us help you: please paste full code, input and/or output at e.g. https://paste.tomsmeding.com
2021-07-18 01:15:18	int-e	[16:13:04] maerwald: That's the reason, but not a solution for the problem?
2021-07-18 01:15:18	 *	int-e [16:13:06] shrugs
2021-07-18 01:15:18	maerwald	[16:13:10] So my answer is: yes
2021-07-18 01:15:18	int-e	[16:13:28] Well, so sorry for trying to be helpful.
2021-07-18 01:15:18	davean	[16:14:09] int-e: oh do be helpful
2021-07-18 01:15:18	Guest14	[16:15:14] int-e that worked thank you
2021-07-18 01:15:18	texasmynsted	[16:20:42] thank you boxscape 
2021-07-18 01:15:18	texasmynsted	[16:21:29] Sounds like optics or vinyl for now
2021-07-18 01:15:18	sm	[16:31:11] g'day all. Speaking of optics.. you experienced [lens] coders, do you find it good or bad for (a) fields and (b) lenses to be visually disctinct from other kinds of bindings (functions, "variables") ? As in eg _field/lens_, field_/lens__, _field/lensL, .... ?
2021-07-18 01:15:18	sm	[16:32:24] I feel it would be good overall, for avoiding collisions and for human comprehension . But I don't have a lot of lens experience
2021-07-18 01:15:18	maerwald	[16:40:10] can you derive LabelOptic with deriving via for an inner type? 
2021-07-18 01:15:18	oso	[16:42:50] xpost from #haskell-beginners:
2021-07-18 01:15:18	oso	[16:42:52] I'm passing around a type synonym for Int, but in reality the only constraint it needs to  follow is that it's hashable. what constructor do i use for this? my brain says go from `type UID = Int` to `data UID a = Hashable a` but that's very not correct, and google isn't helping much
2021-07-18 01:15:18	oso	[16:43:21] nvm sorry got an answer there
2021-07-18 01:15:18	glguy	[16:54:37] oso, if you just need to know that something is hashable you'd use it like: stuff :: Hashable a => a -> b -> c
2021-07-18 01:15:18	glguy	[16:55:19] If a parameter is the uid parameter you can document that like:  stuff :: Hashable uid => uid {- ^ the UID -} -> etc
2021-07-18 01:15:18	oso	[16:55:35] I was trying to do that while also using types to keep my signatures from becoming unwieldy, but first i'll just worry about getting the code working
2021-07-18 01:15:18	glguy	[16:56:22] the documentation for parameters goes in the haddock comments rather than type synonyms
2021-07-18 01:15:18	oso	[16:56:43] mmk
2021-07-18 01:15:18	dsal	[17:05:40] oso: It's tempting to put constraints in the type definitions, but if you take a look at, for example, `Data.Map.Strict` you'll see the type definition is just `data Map k a`.  You'd think k would always have to be ordered, but that's not the case.  You can create and work on maps that have unorderable keys when you don't do things that require ordering.  e.g.:
2021-07-18 01:15:18	dsal	[17:05:42] > M.elems $ (* 2) <$> M.singleton id 3
2021-07-18 01:15:18	lambdabot	[17:05:43]  [6]
2021-07-18 01:15:18	dsal	[17:07:10] The idea is that you only have to constrain things where they actually need to be constrained.  The Functor instance, e.g., doesn't care about the keys at all, so why should it require they're ordered?
2021-07-18 01:15:18	oso	[17:13:45] got it working \o/
2021-07-18 01:15:18	oso	[17:13:47] thank you
2021-07-18 01:15:18	hololeap	[17:46:09] so, I figured out a way to make a function with an arbitrary number of arguments using type families and type-level lists. but, I have to wonder ... has someone already made this and put it on hackage?
2021-07-18 01:15:18	texasmynsted	[17:47:46] wait, why do you want a function with an arbitrary number of arguments?
2021-07-18 01:15:18	c_wraith	[17:49:03] usually to cover for a lack of other expressiveness
2021-07-18 01:15:18	c_wraith	[17:49:09] printf is a common example
2021-07-18 01:15:18	texasmynsted	[17:49:12] Seems to me ideally a function should have exactly one argument
2021-07-18 01:15:18	c_wraith	[17:49:19] We can't write the type it actually has in Haskell
2021-07-18 01:15:18	c_wraith	[17:49:25] Because it's a dependent type
2021-07-18 01:15:18	c_wraith	[17:49:51] So varargs lets us do it anyway and fail at runtime if the programmer got it wrong
2021-07-18 01:15:18	texasmynsted	[17:50:07] printf solves a problem in a particular way that I think could be solved better, differently 
2021-07-18 01:15:18	c_wraith	[17:50:18] differently?  sure.  Better?  Not really.
2021-07-18 01:15:18	hololeap	[17:50:21] the motivation was because I had a typeclass with a function, and I encountered some outliers that needed extra arguments passed to that function
2021-07-18 01:15:18	texasmynsted	[17:50:47] c_wraith: I am not convinced 
2021-07-18 01:15:18	hololeap	[17:50:48] I'd have to write up a blog post or something to get into all the details
2021-07-18 01:15:18	Rembane	[17:50:57] hololeap: Do it! :D
2021-07-18 01:15:18	texasmynsted	[17:51:08] yes, that would be a good read
2021-07-18 01:15:18	c_wraith	[17:51:15] printf is *really* good at doing exactly what it's intended for.  Compactly specifying output formatted for monospace devices.
2021-07-18 01:15:18	texasmynsted	[17:51:32] like regular expressions?
2021-07-18 01:15:18	c_wraith	[17:51:42] honestly, it's more useful
2021-07-18 01:15:18	c_wraith	[17:52:01] regular expressions have to involve things like capturing group to really be useful, and those complicate APIs tremendously
2021-07-18 01:15:18	c_wraith	[17:52:05] printf has no such problems
2021-07-18 01:15:18	texasmynsted	[17:52:20] Right. I think regular expressions work great but are terrible and the problem is better solved differently 
2021-07-18 01:15:18	EvanR	[17:52:46] compare and contrast serious uses of printf with the expanded version, replicate that across a code base like 50 times and compare xD
2021-07-18 01:15:18	EvanR	[17:53:12] also, printf for debugging
2021-07-18 01:15:18	EvanR	[17:53:25] debugging would be harsher without it
2021-07-18 01:15:18	EvanR	[17:54:27] I'm more interested with this case of some function sometimes needing more arguments
2021-07-18 01:15:18	texasmynsted	[17:56:04] I am still going with functions should have exactly one argument 
2021-07-18 01:15:18	hololeap	[17:56:30] I mean... they do, technically.
2021-07-18 01:15:18	texasmynsted	[17:57:38] yes
2021-07-18 01:15:18	EvanR	[17:58:02] if the difference is between argument type (A,B) and (A,B,C) it's about argument type and not number
2021-07-18 01:15:18	texasmynsted	[17:58:23] Okay now we are getting somewhere
2021-07-18 01:15:18	texasmynsted	[19:06:50] sigh.
2021-07-18 01:15:18	oso	[19:07:39] seconded
2021-07-18 01:15:18	texasmynsted	[19:08:52] +1 oso
2021-07-18 01:15:18	monochrom	[19:32:57] Why so grim?
2021-07-18 01:15:18	boxscape	[19:33:18] hololeap: one of rae's latest videos is also about varargs https://youtu.be/iGSKqcebhfs
2021-07-18 01:15:18	monochrom	[19:33:22] You know "grim" and "grin" are just one curvy stroke apart. :)
2021-07-18 01:15:18	boxscape	[19:33:55] you can't spell slaughter without laughter, you can't spell grim without grin
2021-07-18 01:15:18	monochrom	[19:34:33] hee hee
2021-07-18 01:15:18	oso	[19:35:57] idk why texas is feeling grim but i'm extremely anxious about a work trip and trying to stuff the feelings down by adding documentation to my heretofore undocumented code
2021-07-18 01:15:18	monochrom	[19:36:32] My gripe about printf is I will be writing "%d %d %d %d %d %d %d" and then it's the same issue with (Int,Int,Int,Int,Int,Int). And I'm deliberately demonstrating an miscounting error for starters. But this issue is not about vararg, it's about losing structure.
2021-07-18 01:15:18	***	Playback Complete.
2021-07-18 01:15:25	--	Channel created on Sun, 25 Apr 2021 01:04:39
2021-07-18 01:16:21	<--	favonia (~favonia@user/favonia) has quit (Ping timeout: 255 seconds)
2021-07-18 01:17:45	-->	favonia (~favonia@user/favonia) has joined #haskell
2021-07-18 01:18:09	-->	wroathe (~wroathe@c-68-54-25-135.hsd1.mn.comcast.net) has joined #haskell
2021-07-18 01:20:23	-->	alx741 (~alx741@186.178.109.120) has joined #haskell
2021-07-18 01:21:08	maerwald	can you implement varargs in haskell without ambiguitiy due to partial application?
2021-07-18 01:21:18	maerwald	(and I'm not talking about the typeclass trick)
2021-07-18 01:21:27	-->	dmwit (~dmwit@pool-108-18-198-142.washdc.fios.verizon.net) has joined #haskell
2021-07-18 01:21:55	-->	burnsidesLlama (~burnsides@dhcp168-011.wadham.ox.ac.uk) has joined #haskell
2021-07-18 01:22:19	geekosaur	I think there's a typesafe varargs via TH somewhere on hackage
2021-07-18 01:22:48	geekosaur	probably relies on the format string being literal, but you have other problems if it's not anyway
2021-07-18 01:23:46	c_wraith	In the general case, there's true ambiguity.  There's no general way to distinguish between providing all the arguments that will be provided and partially applying the function.
2021-07-18 01:24:25	geekosaur	^
2021-07-18 01:25:06	-->	finsternis (~X@23.226.237.192) has joined #haskell
2021-07-18 01:25:11	--	irc: disconnected from server
2021-07-18 04:51:00	-->	amanr (~therojjha@20.204.87.0) has joined #haskell
2021-07-18 04:51:00	--	Topic for #haskell is "https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org | Paste code/errors: https://paste.tomsmeding.com | tunes.org-style logging should be coming soon | Logs: https://ircbrowse.tomsmeding.com/browse/lchaskell"
2021-07-18 04:51:00	--	Topic set by geekosaur (~geekosaur@xmonad/geekosaur) on Mon, 14 Jun 2021 05:16:14
2021-07-18 04:51:01	--	Channel #haskell: 697 nicks (1 op, 0 voices, 696 normals)
2021-07-18 04:51:01	***	Buffer Playback...
2021-07-18 04:51:01	arkanoid	[10:23:16] the Error monad link is broken https://wiki.haskell.org/Errormonad.html
2021-07-18 04:51:01	kuribas	[10:45:22] How does haskell compare to other functional languages?  Looking a bit at SML and OCaml, it seems that haskell has far more libraries, and is more practical for real world projects (other than compilers etc).
2021-07-18 04:51:01	kuribas	[10:46:31] Of course scala and clojure are also popular, but I don't consider clojure a real functional language, it's more a lisp derivative.  And Scala is mostly multiparadigm, and also complex and overengineerd.
2021-07-18 04:51:01	arahael	[10:47:48] kuribas: I use haskell for most of my private hobby/side projects.  It's awesule, but I've used F# and Swift, which are somewhat OCaml-inspired.
2021-07-18 04:51:01	arahael	[10:48:25] kuribas: The biggest most profound difference with Haskell is that it's *lazy*, and has a really really good type system, but in practice that it's lazy makes a big difference to how you use haskell.
2021-07-18 04:51:01	kuribas	[10:48:54] arahael: how much libraries are there for F#?  Or does it just use the C# ecosystem?
2021-07-18 04:51:01	arahael	[10:49:05] F# is just another .NET language, really, yeah.
2021-07-18 04:51:01	arahael	[10:49:17] As is C#. :)
2021-07-18 04:51:01	kuribas	[10:49:20] doesn't that mean that most libraries aren't really made for FP?
2021-07-18 04:51:01	arahael	[10:50:00] Kinda.  The way F# copes with nulls is interesting. (It assumes there aren't any).
2021-07-18 04:51:01	kuribas	[10:50:41] then how do you test if a function returns null?
2021-07-18 04:51:01	arahael	[10:51:33] kuribas: That's a trap, yeah.  In earlier versions, you'd check for it explicitly, and the compiler lets you. But then, the compiler *elides* that check because it thinks better.
2021-07-18 04:51:01	arahael	[10:51:44] Hopefully they've changed that now.
2021-07-18 04:51:01	arahael	[10:53:33] Looks like they've changed it - suggesting instead to use pattern matching.  Far better: https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/values/null-values
2021-07-18 04:51:01	arahael	[10:53:59] But anyway, one difference is that Haskell is lazy, so your functions must not have side effects.
2021-07-18 04:51:01	arahael	[10:54:30] And since that practice is so strictly encouraged (otherwise you risk loosing your sanity), that has a flow-on effect to all of haskell's libraries, too.
2021-07-18 04:51:01	DigitalKiwi	[10:55:34] haskell is non-strict
2021-07-18 04:51:01	DigitalKiwi	[10:55:52] https://wiki.haskell.org/Lazy_vs._non-strict
2021-07-18 04:51:01	arahael	[10:56:01] Yeah - more accurate - thanks for that.
2021-07-18 04:51:01	DigitalKiwi	[10:56:34] speaking only for myself haskell programmers are lazy ;)
2021-07-18 04:51:01	arahael	[10:58:05] Hmm. :)
2021-07-18 04:51:01	DigitalKiwi	[11:01:36] and obsesssed with bottoms
2021-07-18 04:51:01	 *	DigitalKiwi [11:02:01] drops mic
2021-07-18 04:51:01	Rembane	[11:03:21] I like lazy bottoms and I cannot lie.
2021-07-18 04:51:01	 *	arahael [11:05:07] suddenly realises why bottom is drawn like _|_
2021-07-18 04:51:01	DigitalKiwi	[11:06:04] dibblego twitter avatar lolol
2021-07-18 04:51:01	kuribas	[11:08:21] arahael: so haskell is the only language that doesn't let you get away coding imperative OO in it?
2021-07-18 04:51:01	kuribas	[11:09:07] Although imperative style is still quite possible in haskell.  OO on the other hand is pretty hard.
2021-07-18 04:51:01	dibblego	[11:09:35] DigitalKiwi: that's BUMFISH
2021-07-18 04:51:01	DigitalKiwi	[11:10:01] is that a new operator
2021-07-18 04:51:01	dibblego	[11:11:41] no, it's a pre-landing checklist
2021-07-18 04:51:01	arahael	[11:13:08] Heh.
2021-07-18 04:51:01	arahael	[11:13:36] kuribas: If it's subtyping you're referring to, no, I don't think haskell has that.
2021-07-18 04:51:01	arahael	[11:13:58] kuribas: It does have classes and instances, though, but they behave quite differently.
2021-07-18 04:51:01	kuribas	[11:14:06] And that's a good thing...
2021-07-18 04:51:01	 *	arahael [11:14:25] thinks so.
2021-07-18 04:51:01	DigitalKiwi	[11:14:37] https://www.parsonsmatt.org/2017/02/17/object_oriented_programming_in_haskell.html
2021-07-18 04:51:01	DigitalKiwi	[11:16:43] https://hackage.haskell.org/package/hoop
2021-07-18 04:51:01	DigitalKiwi	[11:16:56] cue bot "haskell can do that!"
2021-07-18 04:51:01	dibblego	[11:22:23] DigitalKiwi: https://flightscope.gitlab.io/aircraft/checklist/eurofox.pdf page 1, top-right
2021-07-18 04:51:01	kuribas	[11:58:55] I've been accused of being a haskell lanuage zealot.  But actually I am interested in other languages (logic, FP, dependently typed, etc...).  It just doesn't seem to be useful to push for other languages that I know less...
2021-07-18 04:51:01	kuribas	[11:59:21] I could recommend F# instead of haskell, but I don't know it that well, so there is less benefit IMO...
2021-07-18 04:51:01	kuribas	[12:04:48] Every time I come with rational arguments, I get a reply like "But I don't like types, they get in the way".  Or "programming languages don't matter, business logic does".  Or "I don't care it's more robust, we want to move fast and solve bugs as we go".
2021-07-18 04:51:01	dibblego	[12:18:06] get used to it
2021-07-18 04:51:01	tom__	[12:18:47] kuribas: I feel your pain
2021-07-18 04:51:01	tom__	[12:19:43] "Types get in the way" then spends three hours NULL chasing
2021-07-18 04:51:01	kuribas	[12:20:50] tom__: exactly!  I spend far more time thinking about types in clojure than in haskell.
2021-07-18 04:51:01	maerwald	[12:21:11] types can get in the way, especially since haskell lacks structural typing
2021-07-18 04:51:01	tom__	[12:21:34] haha sometimes you want types to get in the way
2021-07-18 04:51:01	maerwald	[12:21:51] I know of at least one Haskell dev who now works full-time with typescript and doesn't regret it
2021-07-18 04:51:01	maerwald	[12:22:09] I probably wouldn't, but it's a valid position
2021-07-18 04:51:01	tom__	[12:22:55] Clojure to me is just javascript with some immutability
2021-07-18 04:51:01	kuribas	[12:23:22] maerwald: I find that often, it just amounts to having a bit more boilerplate.  Or having duplicate type definitions.
2021-07-18 04:51:01	maerwald	[12:23:40] it can be a *lot* of boilerplate
2021-07-18 04:51:01	maerwald	[12:24:00] and prohibits you of expressing certain relationships between data
2021-07-18 04:51:01	tom__	[12:24:19] Haskell, Rust and Julia - desert island stack
2021-07-18 04:51:01	tom__	[12:24:37] Havent tried the latter two :D
2021-07-18 04:51:01	maerwald	[12:24:58] class based solutions don't work well when you need an *actual* data type for serialisation
2021-07-18 04:51:01	maerwald	[12:25:45] typescript is surprisingly simple and powerful on these matters... certainly less elegant and unsound in a few places, but that's the tradeoff the make
2021-07-18 04:51:01	kuribas	[12:26:10] tom__: rust is only my "to learn list" :)
2021-07-18 04:51:01	kuribas	[12:26:42] maerwald: you can be less elegant and unsound in haskell too...
2021-07-18 04:51:01	maerwald	[12:27:02] kuribas: yeah, but that usually involves MORE complexity, not less
2021-07-18 04:51:01	maerwald	[12:27:10] so the opposite of typescript
2021-07-18 04:51:01	tom__	[12:27:22] You can be and then people who don't understand what a theoretical model is say that it must mean Haskell is pointless
2021-07-18 04:51:01	kuribas	[12:28:12] maerwald: I don't agree
2021-07-18 04:51:01	maerwald	[12:28:47] well, you *can* do some forms of structural typing/subtyping, but it all ends in esoteric libraries
2021-07-18 04:51:01	kuribas	[12:29:00] maerwald: so don't do it.
2021-07-18 04:51:01	maerwald	[12:29:03] while you get all that in TS for free without complexity
2021-07-18 04:51:01	maerwald	[12:29:45] well, I'm not commenting on which language is better, I'm just commenting on "types can get in the way", because they can
2021-07-18 04:51:01	kuribas	[12:29:55] maerwald: plenty of ways to get around that: 1) partially applied functions (the Endo trick), create a new type with some of the fields.  3) just make the fields all Maybe.
2021-07-18 04:51:01	kuribas	[12:30:56] maerwald: there is a difference between "the types sometimes get in the way", and "the types always get in the way", the latter is what they seem to be implying.
2021-07-18 04:51:01	maerwald	[12:31:02] 1) difficult for serialisation, Show instances, debugging, ... 2) boilerplate, 3) unexpressive, because now you have two cases of `Maybe`
2021-07-18 04:51:01	kuribas	[12:32:02] You don't need two cases of Maybe
2021-07-18 04:51:01	kuribas	[12:32:44] and 4) just put default values.
2021-07-18 04:51:01	maerwald	[12:33:32] 1. there's no such value, because the computation doesn't return one for the given input, 2. there's no such value, because the computation can *never* return one
2021-07-18 04:51:01	maerwald	[12:33:45] now you also have to wonder: 3. there's a value, but there shouldn't be one
2021-07-18 04:51:01	maerwald	[12:33:47] oops
2021-07-18 04:51:01	kuribas	[12:33:47] IMO, the more you want correctness, the more you are restricted in what you write.  It has nothing to do with types (directly).
2021-07-18 04:51:01	kuribas	[12:34:28] maerwald: if you grab to clojure, you don't care anyway...
2021-07-18 04:51:01	maerwald	[12:34:48] default values.. what's my default account balance? :p
2021-07-18 04:51:01	dibblego	[12:34:54] like I said, get used to it
2021-07-18 04:51:01	tom__	[12:35:20] ^ yes and get used to makeNegative = (*) -1
2021-07-18 04:51:01	kuribas	[12:35:49] Which is my point, haskell can be a nice unsafe language to.  Just make a big sum type, and partial functions over it (don't forget to add error messages though...).
2021-07-18 04:51:01	maerwald	[12:36:21] well, with structural typing you don't need to be partial
2021-07-18 04:51:01	int-e	[12:36:25] Or unsafeCoerce everything and program untyped lambda calculus? :)
2021-07-18 04:51:01	arahael	[12:36:48] kuribas: Mind you, Clojure seems to offer alternative methods to allow you to type ocrrect code.  In particular, Clojure seems to have a fantastic runtime repl.
2021-07-18 04:51:01	arahael	[12:37:15] kuribas: Such that you're running the live program and debugging it and replacing functions on the fly.
2021-07-18 04:51:01	int-e	[12:37:26] I like types, they prevent some of the more embarrassing programming errors from being run as code.
2021-07-18 04:51:01	tom__	[12:37:44] Revenge is forcing them to write a web app in the Lean proof assistant fully verified.
2021-07-18 04:51:01	tom__	[12:37:49] It has IO.
2021-07-18 04:51:01	maerwald	[12:38:25] right... clojure: forget a closing  bracket, code still compiles, but doesn't compute prime numbers... instead it compiles to a chess engine
2021-07-18 04:51:01	tom__	[12:38:42] haha
2021-07-18 04:51:01	maerwald	[12:38:45] type safe? Yeah maybe. But.
2021-07-18 04:51:01	kuribas	[12:38:48] arahael: I think you never actually used clojure?
2021-07-18 04:51:01	int-e	[12:39:03] tom__: That's deep in "overdoing it" territory. At least if the specification is anything more elaborate than "something in, something out", and even that may be tricky if you interpret it as a promise to fulfil request in finite time.
2021-07-18 04:51:01	kuribas	[12:39:26] arahael: it's a very mediocre runtime IMO, compared to java.  Error messages are nearly incomprehensible.  Tracing is nice though...
2021-07-18 04:51:01	tom__	[12:39:39] int-e: Yeah pointless torture :)
2021-07-18 04:51:01	maerwald	[12:39:50] the only upside of clojure is interactive development
2021-07-18 04:51:01	tom__	[12:40:08] The haskell compiler feels pretty interactive
2021-07-18 04:51:01	maerwald	[12:40:29] if HLS works, maybe
2021-07-18 04:51:01	arahael	[12:40:37] kuribas: Seemed to be effective enough.
2021-07-18 04:51:01	arahael	[12:40:53] But no, I haven't personally used it.
2021-07-18 04:51:01	maerwald	[12:41:00] but on the other hand: usually not. Compile times are too slow
2021-07-18 04:51:01	kuribas	[12:41:12] arahael: clojurists just have a different idea of "correct code".
2021-07-18 04:51:01	arahael	[12:41:15] I personally quite like ghcid.
2021-07-18 04:51:01	arahael	[12:41:27] kuribas: Indeed, but I think it's the process of discovery that they like.
2021-07-18 04:51:01	arahael	[12:41:57] kuribas: In haskell, we seem to prefer to test functions in isolation. Clojure people seem to prefer to test functions in the live system.
2021-07-18 04:51:01	maerwald	[12:42:00] if you're working on 300+ modules and your Type module has a whitespace change, you're gonna need to restart cabal a few times, because your machine OOMed due to TH
2021-07-18 04:51:01	tom__	[12:42:18] Which library is recommended for sampling probability distributions?
2021-07-18 04:51:01	arahael	[12:42:42] maerwald: The amount of memory Haskell uses is crazy high.  Sadly, I find it way faster than Swift. :/
2021-07-18 04:51:01	kuribas	[12:45:45] arahael: lispers will boast about how easy it is to hot patch live systems.  They don't tell you that it becomes very hard to see who changed what and when.
2021-07-18 04:51:01	kuribas	[12:46:05] arahael: so you'll end up with CI/CD anyway.  
2021-07-18 04:51:01	kuribas	[12:46:34] However a theoretically, a "live" programming environment with integrated version control could be nice.
2021-07-18 04:51:01	kuribas	[12:46:44] I don't know if that ever has been done.
2021-07-18 04:51:01	maerwald	[12:47:32] https://hackage.haskell.org/package/optics-th-0.4/docs/Optics-TH.html#v:makeClassy
2021-07-18 04:51:01	maerwald	[12:47:34] https://hackage.haskell.org/package/optics-th-0.4/docs/Optics-TH.html#v:makeFieldsNoPrefix
2021-07-18 04:51:01	maerwald	[12:47:36] https://hackage.haskell.org/package/generic-optics-2.2.0.0/docs/Data-Generics-Product-Fields.html#t:HasField
2021-07-18 04:51:01	maerwald	[12:47:38] which one of those to pick?
2021-07-18 04:51:01	maerwald	[12:49:00] HasField is kinda cool with those neat type errors
2021-07-18 04:51:01	boxscape	[15:15:35] maerwald: the TH versions say "This method of optics generation should only be used when migrating an existing codebase from the lens library to optics"
2021-07-18 04:51:01	boxscape	[15:15:51] maerwald: this, my final answer is C
2021-07-18 04:51:01	boxscape	[15:15:56] s/this/thus
2021-07-18 04:51:01	maerwald	[15:16:07] HasField?
2021-07-18 04:51:01	boxscape	[15:16:46] yeah.. though I thought there was a version of that which uses OverloadedLabels
2021-07-18 04:51:01	maerwald	[15:17:20] HasField though doesn't allow arbitrary subtyping... it's a simple getter
2021-07-18 04:51:01	maerwald	[15:17:54] with makeClassy style classes you could descend deeper into the structure with the same getter
2021-07-18 04:51:01	boxscape	[15:18:30] maerwald: oh actually the TH version links to https://hackage.haskell.org/package/optics-core-0.4/docs/Optics-Label.html as preferred solution
2021-07-18 04:51:01	boxscape	[15:19:03] that's the OverloadedLabels version I was remembering
2021-07-18 04:51:01	maerwald	[15:22:44] so there you could also define custom LabelOptic instances that descend into a structure?
2021-07-18 04:51:01	boxscape	[15:23:27] that seems plausible but I haven't tried doing it
2021-07-18 04:51:01	maerwald	[15:23:47] I'm leaning towards makeClassy, but I'm not sure
2021-07-18 04:51:01	boxscape	[15:24:25] I like makeClassy, the main reason I would avoid it personally is that the documentation advises against it
2021-07-18 04:51:01	maerwald	[15:25:40] so what does LabelOptic give over HasField?
2021-07-18 04:51:01	texasmynsted	[15:26:17] What is the modern answer to haskell records? Lens?
2021-07-18 04:51:01	maerwald	[15:26:49] only difference I see is labelOptic is `Optic` and HasField is a `Lens`
2021-07-18 04:51:01	boxscape	[15:28:24] hm I'm not sure what the concrete differences are
2021-07-18 04:51:01	boxscape	[15:30:52] texasmynsted: there are a few answers to this: In the next version, OverloadedRecordDot is being introduces, which allows one to write something like `personA.company.name`. (Updates are a bit iffy but will improve over time.) In the meantime, lens is definitely still widely used, though optics is a replacement which aims to have better error messages. There is also some research going into row types, but that's further out.
2021-07-18 04:51:01	boxscape	[15:30:55] s/next version/next version of GHC
2021-07-18 04:51:01	boxscape	[15:32:08] (though regarding row types, the vinyl records package allows something similar today)
2021-07-18 04:51:01	Guest14	[16:03:05] Hello :)
2021-07-18 04:51:01	Guest14	[16:03:40] I am new to Haskell and am working through the Real World Haskell Book
2021-07-18 04:51:01	Guest14	[16:04:27] I have a basic question if anyone would care to listen
2021-07-18 04:51:01	allbery_b	[16:06:02] best to just ask it rather than asking to ask
2021-07-18 04:51:01	davean	[16:06:23] asking to ask is why I wasn't helping
2021-07-18 04:51:01	Guest14	[16:07:44] splitWith _ [] = []
2021-07-18 04:51:01	Guest14	[16:07:45] splitWith a xs = [pre ++ [x]] ++ next
2021-07-18 04:51:01	Guest14	[16:07:45]     where 
2021-07-18 04:51:01	Guest14	[16:07:46]         (pre, x:suf) = span a xs
2021-07-18 04:51:01	Guest14	[16:07:46]         next = splitWith a suf
2021-07-18 04:51:01	Guest14	[16:08:10] I have this program and I run into a problem with x:suf when span a xs is [] becuase there is no head
2021-07-18 04:51:01	int-e	[16:09:34] > let f = splitAt 1 in (f "abc", f "")
2021-07-18 04:51:01	lambdabot	[16:09:36]  (("a","bc"),("",""))
2021-07-18 04:51:01	int-e	[16:11:31] (So maybe use splitAt instead of the x:suf pattern.)
2021-07-18 04:51:01	maerwald	[16:11:39] was there a question yet?
2021-07-18 04:51:01	davean	[16:11:45] No
2021-07-18 04:51:01	Guest14	[16:12:09] Ok I will give that a try thanks
2021-07-18 04:51:01	int-e	[16:12:10] They described a problem, close enough.
2021-07-18 04:51:01	maerwald	[16:12:35] They also described the answer
2021-07-18 04:51:01	maerwald	[16:12:38] "there is no head"
2021-07-18 04:51:01	int-e	[16:12:47] @where paste
2021-07-18 04:51:01	lambdabot	[16:12:47] Help us help you: please paste full code, input and/or output at e.g. https://paste.tomsmeding.com
2021-07-18 04:51:01	int-e	[16:13:04] maerwald: That's the reason, but not a solution for the problem?
2021-07-18 04:51:01	 *	int-e [16:13:06] shrugs
2021-07-18 04:51:01	maerwald	[16:13:10] So my answer is: yes
2021-07-18 04:51:01	int-e	[16:13:28] Well, so sorry for trying to be helpful.
2021-07-18 04:51:01	davean	[16:14:09] int-e: oh do be helpful
2021-07-18 04:51:01	Guest14	[16:15:14] int-e that worked thank you
2021-07-18 04:51:01	texasmynsted	[16:20:42] thank you boxscape 
2021-07-18 04:51:01	texasmynsted	[16:21:29] Sounds like optics or vinyl for now
2021-07-18 04:51:01	sm	[16:31:11] g'day all. Speaking of optics.. you experienced [lens] coders, do you find it good or bad for (a) fields and (b) lenses to be visually disctinct from other kinds of bindings (functions, "variables") ? As in eg _field/lens_, field_/lens__, _field/lensL, .... ?
2021-07-18 04:51:01	sm	[16:32:24] I feel it would be good overall, for avoiding collisions and for human comprehension . But I don't have a lot of lens experience
2021-07-18 04:51:01	maerwald	[16:40:10] can you derive LabelOptic with deriving via for an inner type? 
2021-07-18 04:51:01	oso	[16:42:50] xpost from #haskell-beginners:
2021-07-18 04:51:01	oso	[16:42:52] I'm passing around a type synonym for Int, but in reality the only constraint it needs to  follow is that it's hashable. what constructor do i use for this? my brain says go from `type UID = Int` to `data UID a = Hashable a` but that's very not correct, and google isn't helping much
2021-07-18 04:51:01	oso	[16:43:21] nvm sorry got an answer there
2021-07-18 04:51:01	glguy	[16:54:37] oso, if you just need to know that something is hashable you'd use it like: stuff :: Hashable a => a -> b -> c
2021-07-18 04:51:01	glguy	[16:55:19] If a parameter is the uid parameter you can document that like:  stuff :: Hashable uid => uid {- ^ the UID -} -> etc
2021-07-18 04:51:01	oso	[16:55:35] I was trying to do that while also using types to keep my signatures from becoming unwieldy, but first i'll just worry about getting the code working
2021-07-18 04:51:01	glguy	[16:56:22] the documentation for parameters goes in the haddock comments rather than type synonyms
2021-07-18 04:51:01	oso	[16:56:43] mmk
2021-07-18 04:51:01	dsal	[17:05:40] oso: It's tempting to put constraints in the type definitions, but if you take a look at, for example, `Data.Map.Strict` you'll see the type definition is just `data Map k a`.  You'd think k would always have to be ordered, but that's not the case.  You can create and work on maps that have unorderable keys when you don't do things that require ordering.  e.g.:
2021-07-18 04:51:01	dsal	[17:05:42] > M.elems $ (* 2) <$> M.singleton id 3
2021-07-18 04:51:01	lambdabot	[17:05:43]  [6]
2021-07-18 04:51:01	dsal	[17:07:10] The idea is that you only have to constrain things where they actually need to be constrained.  The Functor instance, e.g., doesn't care about the keys at all, so why should it require they're ordered?
2021-07-18 04:51:01	oso	[17:13:45] got it working \o/
2021-07-18 04:51:01	oso	[17:13:47] thank you
2021-07-18 04:51:01	hololeap	[17:46:09] so, I figured out a way to make a function with an arbitrary number of arguments using type families and type-level lists. but, I have to wonder ... has someone already made this and put it on hackage?
2021-07-18 04:51:01	texasmynsted	[17:47:46] wait, why do you want a function with an arbitrary number of arguments?
2021-07-18 04:51:01	c_wraith	[17:49:03] usually to cover for a lack of other expressiveness
2021-07-18 04:51:01	c_wraith	[17:49:09] printf is a common example
2021-07-18 04:51:01	texasmynsted	[17:49:12] Seems to me ideally a function should have exactly one argument
2021-07-18 04:51:01	c_wraith	[17:49:19] We can't write the type it actually has in Haskell
2021-07-18 04:51:01	c_wraith	[17:49:25] Because it's a dependent type
2021-07-18 04:51:01	c_wraith	[17:49:51] So varargs lets us do it anyway and fail at runtime if the programmer got it wrong
2021-07-18 04:51:01	texasmynsted	[17:50:07] printf solves a problem in a particular way that I think could be solved better, differently 
2021-07-18 04:51:01	c_wraith	[17:50:18] differently?  sure.  Better?  Not really.
2021-07-18 04:51:01	hololeap	[17:50:21] the motivation was because I had a typeclass with a function, and I encountered some outliers that needed extra arguments passed to that function
2021-07-18 04:51:01	texasmynsted	[17:50:47] c_wraith: I am not convinced 
2021-07-18 04:51:01	hololeap	[17:50:48] I'd have to write up a blog post or something to get into all the details
2021-07-18 04:51:01	Rembane	[17:50:57] hololeap: Do it! :D
2021-07-18 04:51:01	texasmynsted	[17:51:08] yes, that would be a good read
2021-07-18 04:51:01	c_wraith	[17:51:15] printf is *really* good at doing exactly what it's intended for.  Compactly specifying output formatted for monospace devices.
2021-07-18 04:51:01	texasmynsted	[17:51:32] like regular expressions?
2021-07-18 04:51:01	c_wraith	[17:51:42] honestly, it's more useful
2021-07-18 04:51:01	c_wraith	[17:52:01] regular expressions have to involve things like capturing group to really be useful, and those complicate APIs tremendously
2021-07-18 04:51:01	c_wraith	[17:52:05] printf has no such problems
2021-07-18 04:51:01	texasmynsted	[17:52:20] Right. I think regular expressions work great but are terrible and the problem is better solved differently 
2021-07-18 04:51:01	EvanR	[17:52:46] compare and contrast serious uses of printf with the expanded version, replicate that across a code base like 50 times and compare xD
2021-07-18 04:51:01	EvanR	[17:53:12] also, printf for debugging
2021-07-18 04:51:01	EvanR	[17:53:25] debugging would be harsher without it
2021-07-18 04:51:01	EvanR	[17:54:27] I'm more interested with this case of some function sometimes needing more arguments
2021-07-18 04:51:01	texasmynsted	[17:56:04] I am still going with functions should have exactly one argument 
2021-07-18 04:51:01	hololeap	[17:56:30] I mean... they do, technically.
2021-07-18 04:51:01	texasmynsted	[17:57:38] yes
2021-07-18 04:51:01	EvanR	[17:58:02] if the difference is between argument type (A,B) and (A,B,C) it's about argument type and not number
2021-07-18 04:51:01	texasmynsted	[17:58:23] Okay now we are getting somewhere
2021-07-18 04:51:01	texasmynsted	[19:06:50] sigh.
2021-07-18 04:51:01	oso	[19:07:39] seconded
2021-07-18 04:51:01	texasmynsted	[19:08:52] +1 oso
2021-07-18 04:51:01	monochrom	[19:32:57] Why so grim?
2021-07-18 04:51:01	boxscape	[19:33:18] hololeap: one of rae's latest videos is also about varargs https://youtu.be/iGSKqcebhfs
2021-07-18 04:51:01	monochrom	[19:33:22] You know "grim" and "grin" are just one curvy stroke apart. :)
2021-07-18 04:51:01	boxscape	[19:33:55] you can't spell slaughter without laughter, you can't spell grim without grin
2021-07-18 04:51:01	monochrom	[19:34:33] hee hee
2021-07-18 04:51:01	oso	[19:35:57] idk why texas is feeling grim but i'm extremely anxious about a work trip and trying to stuff the feelings down by adding documentation to my heretofore undocumented code
2021-07-18 04:51:01	monochrom	[19:36:32] My gripe about printf is I will be writing "%d %d %d %d %d %d %d" and then it's the same issue with (Int,Int,Int,Int,Int,Int). And I'm deliberately demonstrating an miscounting error for starters. But this issue is not about vararg, it's about losing structure.
2021-07-18 04:51:01	maerwald	[19:51:08] can you implement varargs in haskell without ambiguitiy due to partial application?
2021-07-18 04:51:01	maerwald	[19:51:18] (and I'm not talking about the typeclass trick)
2021-07-18 04:51:01	geekosaur	[19:52:19] I think there's a typesafe varargs via TH somewhere on hackage
2021-07-18 04:51:01	geekosaur	[19:52:48] probably relies on the format string being literal, but you have other problems if it's not anyway
2021-07-18 04:51:01	c_wraith	[19:53:46] In the general case, there's true ambiguity.  There's no general way to distinguish between providing all the arguments that will be provided and partially applying the function.
2021-07-18 04:51:01	geekosaur	[19:54:25] ^
2021-07-18 04:51:01	c_wraith	[19:55:20] this is why I described varargs as a workaround, not something worth having for itself :)
2021-07-18 04:51:01	Franciman	[19:56:21] Hi, does cabal support literate haskell?
2021-07-18 04:51:01	c_wraith	[19:56:38] if you put an .lhs extension on the files, it should find and compile them
2021-07-18 04:51:01	Franciman	[19:56:56] I have a project using .lhs files, but I get errors 
2021-07-18 04:51:01	Franciman	[19:56:58] wait 
2021-07-18 04:51:01	Franciman	[19:57:19]     `unlit' failed in phase `Literate pre-processor'. (Exit code: 1)
2021-07-18 04:51:01	c_wraith	[19:57:31] so it's trying!
2021-07-18 04:51:01	Franciman	[19:57:36] it is a module I specified in the other-modules
2021-07-18 04:51:01	Franciman	[19:57:45] so I wrote ListCursor
2021-07-18 04:51:01	Franciman	[19:57:49] instead of ListCursor.lhs
2021-07-18 04:51:01	Franciman	[19:58:08] I am really temped to ignore cabal and automatically go with ghc
2021-07-18 04:51:01	Franciman	[19:58:11] let me see what I can do
2021-07-18 04:51:01	geekosaur	[19:58:35] so it ran unlit, so it correctly found it was literate haskell. yoou could try running unlit manually and see what it choked on
2021-07-18 04:51:01	c_wraith	[19:58:40] that error doesn't look like you left out an extension
2021-07-18 04:51:01	c_wraith	[19:58:50] that error looks like it was incorrect literate haskell
2021-07-18 04:51:01	Franciman	[19:59:28] uhm
2021-07-18 04:51:01	Franciman	[20:00:10] geekosaur: how do I call unlit?
2021-07-18 04:51:01	Franciman	[20:00:16] I don't have an unlit program
2021-07-18 04:51:01	geekosaur	[20:00:32] it's in the library directory
2021-07-18 04:51:01	Franciman	[20:01:09] c_wraith: here is my code: https://bpa.st/A7JA
2021-07-18 04:51:01	geekosaur	[20:01:11] ghc --print-libdir
2021-07-18 04:51:01	geekosaur	[20:01:29] then unlit < yoursourcefile
2021-07-18 04:51:01	geekosaur	[20:01:48] with the fukll path to the unlit binary in the libdir
2021-07-18 04:51:01	Franciman	[20:02:36] geekosaur: sorry to bother again
2021-07-18 04:51:01	Franciman	[20:02:38] but I get
2021-07-18 04:51:01	Franciman	[20:02:43] usage: unlit [-q] [-n] [-c] [-#] [-P] [-h label] file1 file2
2021-07-18 04:51:01	Franciman	[20:02:47] and there is no help :D
2021-07-18 04:51:01	Franciman	[20:02:59] oh I am stupid
2021-07-18 04:51:01	Franciman	[20:03:01] sorry
2021-07-18 04:51:01	c_wraith	[20:03:03] I don't know if you can mix bird tracks and tex-style literate haskell in one file
2021-07-18 04:51:01	Franciman	[20:03:10] no ok, same problem
2021-07-18 04:51:01	Franciman	[20:03:31] c_wraith: uhm let me see
2021-07-18 04:51:01	geekosaur	[20:04:24] I don't think you can
2021-07-18 04:51:01	Franciman	[20:04:31] and in fact!
2021-07-18 04:51:01	Franciman	[20:04:35] thank you all
2021-07-18 04:51:01	Franciman	[20:05:10] only sad thing is that I can't use the # for markdown titles
2021-07-18 04:51:01	geekosaur	[20:05:26] unlit could use more documentation but I think it's largely fallen out of use
2021-07-18 04:51:01	Franciman	[20:05:38] nobody likes literate haskell?
2021-07-18 04:51:01	oso	[20:05:53] you could use the === underline in place of the # for header
2021-07-18 04:51:01	Franciman	[20:05:56] I mean, I understand, it does not even sync with haddock
2021-07-18 04:51:01	c_wraith	[20:06:01] in very broad terms, nobody likes literate programming
2021-07-18 04:51:01	Franciman	[20:06:08] yup, thanks oso 
2021-07-18 04:51:01	maerwald	[20:08:19] Franciman: no, it's not even bidirectional
2021-07-18 04:51:01	maerwald	[20:08:37] there's a project that fixes that
2021-07-18 04:51:01	maerwald	[20:08:43] but even then, not sure
2021-07-18 04:51:01	maerwald	[20:09:09] https://blog.esciencecenter.nl/entangled-1744448f4b9f
2021-07-18 04:51:01	maerwald	[20:09:25] https://github.com/entangled/entangled
2021-07-18 04:51:01	Franciman	[20:09:30] entangled is cool, I use it at my job
2021-07-18 04:51:01	Franciman	[20:09:36] it has some sore points
2021-07-18 04:51:01	Franciman	[20:09:39] and a lit of bugs
2021-07-18 04:51:01	Franciman	[20:09:50] lot* lol
2021-07-18 04:51:01	maerwald	[20:09:52] that's why it's LITerate
2021-07-18 04:51:01	maerwald	[20:09:54] lol
2021-07-18 04:51:01	Franciman	[20:09:57] LOL
2021-07-18 04:51:01	Franciman	[20:10:07] but it does not integrate well with ghc etc
2021-07-18 04:51:01	dsal	[20:16:13] Franciman: the last time I wrote literate Haskell, it was in markdown.  It's not bad.
2021-07-18 04:51:01	Franciman	[20:18:01] it is cool yeah
2021-07-18 04:51:01	Franciman	[20:18:25] only thing is, as it seems, it does not mix well with haddock
2021-07-18 04:51:01	Franciman	[20:18:32] you still have to add haddock special comments
2021-07-18 04:51:01	dsal	[20:21:13] Yeah, haddock is lacking in a few ways. I also want TH to work with it.
2021-07-18 04:51:01	dmj`	[20:22:54] an alternative haddock could be nice, could call it koi pond
2021-07-18 04:51:01	geekosaur	[20:24:15] there was at some point a discussion on cafe about incompatibilities between haddock markup and markdown that would make supporting both difficult
2021-07-18 04:51:01	monochrom	[20:35:56] It is sad that we now have to add "bi-directional" to refer to actual literate programming.
2021-07-18 04:51:01	monochrom	[20:36:33] Candidly, lhs is merely a nicer syntax for vanilla comments.
2021-07-18 04:51:01	monochrom	[20:38:15] Literate programming needed to be invented as a thing distinct from mere comments because the biggest part is to present your code in an order the computer doesn't expect. If a system can't do this, it is not literate programming.
2021-07-18 04:51:01	dmj`	[20:52:14] It would be really nice if Haskell abided by industry standards instead of custom stuff, like use toml, markdown, LLVM instead of cabal files, haddock syntax, Cmm 
2021-07-18 04:51:01	geekosaur	[20:55:29] llvm's not gonna happen unless you want to try to upstream a bunch of stuff so ghc can inform llvm of cps-ed stuff
2021-07-18 04:51:01	geekosaur	[20:56:01] and then arrange for ghc to be able to do so, but nobody's going to do that until there's somewhere for it to go
2021-07-18 04:51:01	Rembane	[20:57:04] Sounds like a moment 22
2021-07-18 04:51:01	geekosaur	[20:57:45] no, they know what needs to change and how, but it would require a bunch of llvm changes that are more or less ghc-specific
2021-07-18 04:51:01	geekosaur	[20:57:54] so they're unlikely to ever happen
2021-07-18 04:51:01	Rembane	[20:58:33] Got it! Then I misread, thank you for the clarification.
2021-07-18 04:51:01	noctux	[20:58:48] dmj`: industry standards? do you mean XML, more XML and visual-C? :P
2021-07-18 04:51:01	dmj`	[20:59:16] noctux: yes, XML over SOAP.
2021-07-18 04:51:01	maerwald	[20:59:30] dmj`: afair someone was actually working on providing a toml interface to cabal?
2021-07-18 04:51:01	maerwald	[20:59:41] or maybe I just imagined that
2021-07-18 04:51:01	dmj`	[21:00:33] geekosaur: what are your thoughts on GRIN as a backend for GHC
2021-07-18 04:51:01	geekosaur	[21:05:18] looks to me like it really wants to be a whole-program compiler? which ghc kinda doesn't
2021-07-18 04:51:01	geekosaur	[21:05:42] (and yet kinda does since it "fakes it" via exporting cidode in .hi files)
2021-07-18 04:51:01	geekosaur	[21:05:55] *code
2021-07-18 04:51:01	geekosaur	[21:07:27] still, makes me wonder how well grin would work if used thye way ghc would use it instead of whole-program
2021-07-18 04:51:01	geekosaur	[21:09:43] would really need to write out IR files instead of object files and let the backend take it from there, but I'm not sure how well ghc would work with that setup given it doesn't e.g. do that with llvm IR
2021-07-18 04:51:01	geekosaur	[21:11:06] and you couldn't mix grin backend objects with non-grin backend, like you currently can with llvm vs. asm
2021-07-18 04:51:01	geekosaur	[21:13:22] I think ghc would have to treat grin not as a backend but as a "way" (e.g. static vs. dynamic, or profiled vs. non-profiled)
2021-07-18 04:51:01	monochrom	[21:13:37] cabal was invented long before "industry standard" existed.
2021-07-18 04:51:01	monochrom	[21:14:02] Apart from XML.
2021-07-18 04:51:01	Rembane	[21:14:22] I wonder why industry didn't go with cabal's format. 
2021-07-18 04:51:01	monochrom	[21:15:23] And JVM bytecode.
2021-07-18 04:51:01	geekosaur	[21:15:50] because it's only friendly to haskell, since haskell is friendly to parsers?
2021-07-18 04:51:01	dmj`	[21:16:18] ghc-grin forks ghc it seems, exports *all* of the STG somewhere, does the analysis, brings it back and continues on in the pipeline, to great effect. Suppose we went the nuclear option and replaced STG with GRIN. GRIN would inline the eval function (which is currently hardcoded in the RTS), then perform the WPO, then emit LLVM. 
2021-07-18 04:51:01	geekosaur	[21:16:19] and the syntax is at least reminiscent of haskell
2021-07-18 04:51:01	dmj`	[21:16:34] We could even compile the RTS to GRIN and include it in the optimization phases, which would have the effect of dead code eliminating parts of the RTS that were unused, like GC for example. 
2021-07-18 04:51:01	geekosaur	[21:16:52] interesting
2021-07-18 04:51:01	dmj`	[21:20:33] benefits from WPO are so large even naive pointer analysis (steensgaard) is an enormous win, would still need a fast interpreter though
2021-07-18 04:51:01	dmj`	[21:21:12] thomas johnson created STG, then his final work was GRIN, but it never saw prominence in GHC, I wonder why that is
2021-07-18 04:51:01	geekosaur	[21:23:53] probably because ghc's architecture makes intervening at the stg layer more difficult than it should be
2021-07-18 04:51:01	dmj`	[21:30:54] exactly, too much code at that point
2021-07-18 04:51:01	dmj`	[21:35:03] realizing that GRIN's eval inlining is the first step in undoing the overhead of lazy evaluation (while preserving semantics) was pretty mind-blowing
2021-07-18 04:51:01	danso	[23:02:36] is there a typeclass that generalizes fromMaybe and fromRight? 
2021-07-18 04:51:01	danso	[23:02:53] it seems closely related to Alternative, like <|> 
2021-07-18 04:51:01	danso	[23:03:29] but (<|>) :: f a -> f a -> f a
2021-07-18 04:51:01	hpc	[23:03:31] :t traverse
2021-07-18 04:51:01	lambdabot	[23:03:32] (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
2021-07-18 04:51:01	danso	[23:03:41] i'm looking for f a -> f a -> a 
2021-07-18 04:51:01	geekosaur	[23:04:44] danso, what should such a typeclass do if it would fail?
2021-07-18 04:51:01	hpc	[23:04:55] maybe you want Foldable? https://hackage.haskell.org/package/base-4.15.0.0/docs/Prelude.html#t:Foldable
2021-07-18 04:51:01	danso	[23:05:10] oh you're right geekosaur 
2021-07-18 04:51:01	danso	[23:05:18] i made a mistake; i want f a -> a -> a 
2021-07-18 04:51:01	hpc	[23:05:36] % sum (Just 5)
2021-07-18 04:51:01	yahb	[23:05:36] hpc: 5
2021-07-18 04:51:01	hpc	[23:05:40] % sum Nothing
2021-07-18 04:51:01	yahb	[23:05:41] hpc: 0
2021-07-18 04:51:01	hpc	[23:05:52] % :t sum
2021-07-18 04:51:01	yahb	[23:05:53] hpc: (Foldable t, Num a) => t a -> a
2021-07-18 04:51:01	danso	[23:06:26] something like foldr (const id) is close maybe
2021-07-18 04:51:01	hpc	[23:07:03] :t foldMap
2021-07-18 04:51:01	lambdabot	[23:07:04] (Foldable t, Monoid m) => (a -> m) -> t a -> m
2021-07-18 04:51:01	danso	[23:07:54] wow, TIL Maybe is Foldable 
2021-07-18 04:51:01	hpc	[23:09:37] speaking of, TIL Complex is Foldable
2021-07-18 04:51:01	hpc	[23:09:59] % sum (5 :+ 10)
2021-07-18 04:51:01	yahb	[23:09:59] hpc: 15
2021-07-18 04:51:01	hpc	[23:10:15] and it... just combines the numbers
2021-07-18 04:51:01	hpc	[23:10:19] i don't know what i was expecting
2021-07-18 04:51:01	geekosaur	[23:14:30] o.O
2021-07-18 04:51:01	***	Playback Complete.
2021-07-18 04:51:07	--	Channel created on Sun, 25 Apr 2021 01:04:39
2021-07-18 04:51:57	xsperry	that's.. interesting
2021-07-18 04:52:18	-->	Maxdamantus (~Maxdamant@user/maxdamantus) has joined #haskell
2021-07-18 04:52:32	<--	acidjnk (~acidjnk@p200300d0c72b9505d437a5269bf657ec.dip0.t-ipconnect.de) has quit (Ping timeout: 255 seconds)
2021-07-18 04:52:59	-->	silverwhitefish (~hidden@47.202.102.10) has joined #haskell
2021-07-18 04:53:49	<--	aallen (~aallen@072-182-074-253.res.spectrum.com) has quit (Ping timeout: 246 seconds)
2021-07-18 04:57:26	-->	alphabeta (~kilolympu@cpc92710-cmbg20-2-0-cust265.5-4.cable.virginm.net) has joined #haskell
2021-07-18 04:59:41	-->	Guest18 (~Guest18@2603-8080-6d0d-35bb-0000-0000-0000-0004.res6.spectrum.com) has joined #haskell
2021-07-18 05:00:33	<--	kilolympus (~kilolympu@cpc92710-cmbg20-2-0-cust265.5-4.cable.virginm.net) has quit (Ping timeout: 276 seconds)
2021-07-18 05:02:24	<--	mcfrdy (~mcfrdy@user/mcfrdy) has quit (Ping timeout: 268 seconds)
2021-07-18 05:04:25	-->	spruit11 (~quassel@2a02:a467:ccd6:1:b030:6032:2190:671b) has joined #haskell
2021-07-18 05:05:07	monochrom	That's the natural answer to someone who expects length (x,y) = 2.  Use length (x :+ y) instead.  >:)
2021-07-18 05:06:48	geekosaur	> length (1,2) -- "natural"
2021-07-18 05:06:49	lambdabot	 1
2021-07-18 05:07:05	-->	mcfrdy (~mcfrdy@45.67.96.175) has joined #haskell
2021-07-18 05:07:05	<--	mcfrdy (~mcfrdy@45.67.96.175) has quit (Changing host)
2021-07-18 05:07:06	-->	mcfrdy (~mcfrdy@user/mcfrdy) has joined #haskell
2021-07-18 05:07:13	 *	geekosaur originally typoed "notural"
2021-07-18 05:07:28	<--	Ariakenom__ (~Ariakenom@c83-255-154-140.bredband.tele2.se) has quit (Read error: Connection reset by peer)
2021-07-18 05:09:11	<--	favonia (~favonia@user/favonia) has quit (Ping timeout: 255 seconds)
2021-07-18 05:09:13	<--	euandreh (~euandreh@2804:14c:33:9fe5:9d95:c71:11e4:3e0f) has quit (Quit: WeeChat 3.2)
2021-07-18 05:09:15	-->	merijn (~merijn@83-160-49-249.ip.xs4all.nl) has joined #haskell
2021-07-18 05:09:17	monochrom	And haha someone was ahead of me, Complex is a Monad too.
2021-07-18 05:09:19	<--	ph88 (~ph88@ip5f5af6fd.dynamic.kabel-deutschland.de) has quit (Remote host closed the connection)
2021-07-18 05:09:27	<--	spruit11 (~quassel@2a02:a467:ccd6:1:b030:6032:2190:671b) has quit (Ping timeout: 255 seconds)
2021-07-18 05:09:42	-->	ph88 (~ph88@2a02:8109:9e00:7e5c:f938:d06a:9ad7:b39c) has joined #haskell
2021-07-18 05:09:43	-->	dajoer (~david@user/gvx) has joined #haskell
2021-07-18 05:10:38	-->	favonia (~favonia@user/favonia) has joined #haskell
2021-07-18 05:12:15	--	irc: disconnected from server
2021-07-18 05:12:20	-->	amanr (~therojjha@20.204.87.0) has joined #haskell
2021-07-18 05:12:20	--	Topic for #haskell is "https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org | Paste code/errors: https://paste.tomsmeding.com | tunes.org-style logging should be coming soon | Logs: https://ircbrowse.tomsmeding.com/browse/lchaskell"
2021-07-18 05:12:20	--	Topic set by geekosaur (~geekosaur@xmonad/geekosaur) on Mon, 14 Jun 2021 05:16:14
2021-07-18 05:12:20	--	Channel #haskell: 698 nicks (1 op, 0 voices, 697 normals)
2021-07-18 05:12:20	***	Buffer Playback...
2021-07-18 05:12:20	arkanoid	[10:23:16] the Error monad link is broken https://wiki.haskell.org/Errormonad.html
2021-07-18 05:12:20	kuribas	[10:45:22] How does haskell compare to other functional languages?  Looking a bit at SML and OCaml, it seems that haskell has far more libraries, and is more practical for real world projects (other than compilers etc).
2021-07-18 05:12:20	kuribas	[10:46:31] Of course scala and clojure are also popular, but I don't consider clojure a real functional language, it's more a lisp derivative.  And Scala is mostly multiparadigm, and also complex and overengineerd.
2021-07-18 05:12:20	arahael	[10:47:48] kuribas: I use haskell for most of my private hobby/side projects.  It's awesule, but I've used F# and Swift, which are somewhat OCaml-inspired.
2021-07-18 05:12:20	arahael	[10:48:25] kuribas: The biggest most profound difference with Haskell is that it's *lazy*, and has a really really good type system, but in practice that it's lazy makes a big difference to how you use haskell.
2021-07-18 05:12:20	kuribas	[10:48:54] arahael: how much libraries are there for F#?  Or does it just use the C# ecosystem?
2021-07-18 05:12:20	arahael	[10:49:05] F# is just another .NET language, really, yeah.
2021-07-18 05:12:20	arahael	[10:49:17] As is C#. :)
2021-07-18 05:12:20	kuribas	[10:49:20] doesn't that mean that most libraries aren't really made for FP?
2021-07-18 05:12:20	arahael	[10:50:00] Kinda.  The way F# copes with nulls is interesting. (It assumes there aren't any).
2021-07-18 05:12:20	kuribas	[10:50:41] then how do you test if a function returns null?
2021-07-18 05:12:20	arahael	[10:51:33] kuribas: That's a trap, yeah.  In earlier versions, you'd check for it explicitly, and the compiler lets you. But then, the compiler *elides* that check because it thinks better.
2021-07-18 05:12:20	arahael	[10:51:44] Hopefully they've changed that now.
2021-07-18 05:12:20	arahael	[10:53:33] Looks like they've changed it - suggesting instead to use pattern matching.  Far better: https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/values/null-values
2021-07-18 05:12:20	arahael	[10:53:59] But anyway, one difference is that Haskell is lazy, so your functions must not have side effects.
2021-07-18 05:12:20	arahael	[10:54:30] And since that practice is so strictly encouraged (otherwise you risk loosing your sanity), that has a flow-on effect to all of haskell's libraries, too.
2021-07-18 05:12:20	DigitalKiwi	[10:55:34] haskell is non-strict
2021-07-18 05:12:20	DigitalKiwi	[10:55:52] https://wiki.haskell.org/Lazy_vs._non-strict
2021-07-18 05:12:20	arahael	[10:56:01] Yeah - more accurate - thanks for that.
2021-07-18 05:12:20	DigitalKiwi	[10:56:34] speaking only for myself haskell programmers are lazy ;)
2021-07-18 05:12:20	arahael	[10:58:05] Hmm. :)
2021-07-18 05:12:20	DigitalKiwi	[11:01:36] and obsesssed with bottoms
2021-07-18 05:12:20	 *	DigitalKiwi [11:02:01] drops mic
2021-07-18 05:12:20	Rembane	[11:03:21] I like lazy bottoms and I cannot lie.
2021-07-18 05:12:20	 *	arahael [11:05:07] suddenly realises why bottom is drawn like _|_
2021-07-18 05:12:20	DigitalKiwi	[11:06:04] dibblego twitter avatar lolol
2021-07-18 05:12:20	kuribas	[11:08:21] arahael: so haskell is the only language that doesn't let you get away coding imperative OO in it?
2021-07-18 05:12:20	kuribas	[11:09:07] Although imperative style is still quite possible in haskell.  OO on the other hand is pretty hard.
2021-07-18 05:12:20	dibblego	[11:09:35] DigitalKiwi: that's BUMFISH
2021-07-18 05:12:20	DigitalKiwi	[11:10:01] is that a new operator
2021-07-18 05:12:20	dibblego	[11:11:41] no, it's a pre-landing checklist
2021-07-18 05:12:20	arahael	[11:13:08] Heh.
2021-07-18 05:12:20	arahael	[11:13:36] kuribas: If it's subtyping you're referring to, no, I don't think haskell has that.
2021-07-18 05:12:20	arahael	[11:13:58] kuribas: It does have classes and instances, though, but they behave quite differently.
2021-07-18 05:12:20	kuribas	[11:14:06] And that's a good thing...
2021-07-18 05:12:20	 *	arahael [11:14:25] thinks so.
2021-07-18 05:12:20	DigitalKiwi	[11:14:37] https://www.parsonsmatt.org/2017/02/17/object_oriented_programming_in_haskell.html
2021-07-18 05:12:20	DigitalKiwi	[11:16:43] https://hackage.haskell.org/package/hoop
2021-07-18 05:12:20	DigitalKiwi	[11:16:56] cue bot "haskell can do that!"
2021-07-18 05:12:20	dibblego	[11:22:23] DigitalKiwi: https://flightscope.gitlab.io/aircraft/checklist/eurofox.pdf page 1, top-right
2021-07-18 05:12:20	kuribas	[11:58:55] I've been accused of being a haskell lanuage zealot.  But actually I am interested in other languages (logic, FP, dependently typed, etc...).  It just doesn't seem to be useful to push for other languages that I know less...
2021-07-18 05:12:20	kuribas	[11:59:21] I could recommend F# instead of haskell, but I don't know it that well, so there is less benefit IMO...
2021-07-18 05:12:20	kuribas	[12:04:48] Every time I come with rational arguments, I get a reply like "But I don't like types, they get in the way".  Or "programming languages don't matter, business logic does".  Or "I don't care it's more robust, we want to move fast and solve bugs as we go".
2021-07-18 05:12:20	dibblego	[12:18:06] get used to it
2021-07-18 05:12:20	tom__	[12:18:47] kuribas: I feel your pain
2021-07-18 05:12:20	tom__	[12:19:43] "Types get in the way" then spends three hours NULL chasing
2021-07-18 05:12:20	kuribas	[12:20:50] tom__: exactly!  I spend far more time thinking about types in clojure than in haskell.
2021-07-18 05:12:20	maerwald	[12:21:11] types can get in the way, especially since haskell lacks structural typing
2021-07-18 05:12:20	tom__	[12:21:34] haha sometimes you want types to get in the way
2021-07-18 05:12:20	maerwald	[12:21:51] I know of at least one Haskell dev who now works full-time with typescript and doesn't regret it
2021-07-18 05:12:20	maerwald	[12:22:09] I probably wouldn't, but it's a valid position
2021-07-18 05:12:20	tom__	[12:22:55] Clojure to me is just javascript with some immutability
2021-07-18 05:12:20	kuribas	[12:23:22] maerwald: I find that often, it just amounts to having a bit more boilerplate.  Or having duplicate type definitions.
2021-07-18 05:12:20	maerwald	[12:23:40] it can be a *lot* of boilerplate
2021-07-18 05:12:20	maerwald	[12:24:00] and prohibits you of expressing certain relationships between data
2021-07-18 05:12:20	tom__	[12:24:19] Haskell, Rust and Julia - desert island stack
2021-07-18 05:12:20	tom__	[12:24:37] Havent tried the latter two :D
2021-07-18 05:12:20	maerwald	[12:24:58] class based solutions don't work well when you need an *actual* data type for serialisation
2021-07-18 05:12:20	maerwald	[12:25:45] typescript is surprisingly simple and powerful on these matters... certainly less elegant and unsound in a few places, but that's the tradeoff the make
2021-07-18 05:12:20	kuribas	[12:26:10] tom__: rust is only my "to learn list" :)
2021-07-18 05:12:20	kuribas	[12:26:42] maerwald: you can be less elegant and unsound in haskell too...
2021-07-18 05:12:20	maerwald	[12:27:02] kuribas: yeah, but that usually involves MORE complexity, not less
2021-07-18 05:12:20	maerwald	[12:27:10] so the opposite of typescript
2021-07-18 05:12:20	tom__	[12:27:22] You can be and then people who don't understand what a theoretical model is say that it must mean Haskell is pointless
2021-07-18 05:12:20	kuribas	[12:28:12] maerwald: I don't agree
2021-07-18 05:12:20	maerwald	[12:28:47] well, you *can* do some forms of structural typing/subtyping, but it all ends in esoteric libraries
2021-07-18 05:12:20	kuribas	[12:29:00] maerwald: so don't do it.
2021-07-18 05:12:20	maerwald	[12:29:03] while you get all that in TS for free without complexity
2021-07-18 05:12:20	maerwald	[12:29:45] well, I'm not commenting on which language is better, I'm just commenting on "types can get in the way", because they can
2021-07-18 05:12:20	kuribas	[12:29:55] maerwald: plenty of ways to get around that: 1) partially applied functions (the Endo trick), create a new type with some of the fields.  3) just make the fields all Maybe.
2021-07-18 05:12:20	kuribas	[12:30:56] maerwald: there is a difference between "the types sometimes get in the way", and "the types always get in the way", the latter is what they seem to be implying.
2021-07-18 05:12:20	maerwald	[12:31:02] 1) difficult for serialisation, Show instances, debugging, ... 2) boilerplate, 3) unexpressive, because now you have two cases of `Maybe`
2021-07-18 05:12:20	kuribas	[12:32:02] You don't need two cases of Maybe
2021-07-18 05:12:20	kuribas	[12:32:44] and 4) just put default values.
2021-07-18 05:12:20	maerwald	[12:33:32] 1. there's no such value, because the computation doesn't return one for the given input, 2. there's no such value, because the computation can *never* return one
2021-07-18 05:12:20	maerwald	[12:33:45] now you also have to wonder: 3. there's a value, but there shouldn't be one
2021-07-18 05:12:20	maerwald	[12:33:47] oops
2021-07-18 05:12:20	kuribas	[12:33:47] IMO, the more you want correctness, the more you are restricted in what you write.  It has nothing to do with types (directly).
2021-07-18 05:12:20	kuribas	[12:34:28] maerwald: if you grab to clojure, you don't care anyway...
2021-07-18 05:12:20	maerwald	[12:34:48] default values.. what's my default account balance? :p
2021-07-18 05:12:20	dibblego	[12:34:54] like I said, get used to it
2021-07-18 05:12:20	tom__	[12:35:20] ^ yes and get used to makeNegative = (*) -1
2021-07-18 05:12:20	kuribas	[12:35:49] Which is my point, haskell can be a nice unsafe language to.  Just make a big sum type, and partial functions over it (don't forget to add error messages though...).
2021-07-18 05:12:20	maerwald	[12:36:21] well, with structural typing you don't need to be partial
2021-07-18 05:12:20	int-e	[12:36:25] Or unsafeCoerce everything and program untyped lambda calculus? :)
2021-07-18 05:12:20	arahael	[12:36:48] kuribas: Mind you, Clojure seems to offer alternative methods to allow you to type ocrrect code.  In particular, Clojure seems to have a fantastic runtime repl.
2021-07-18 05:12:20	arahael	[12:37:15] kuribas: Such that you're running the live program and debugging it and replacing functions on the fly.
2021-07-18 05:12:20	int-e	[12:37:26] I like types, they prevent some of the more embarrassing programming errors from being run as code.
2021-07-18 05:12:20	tom__	[12:37:44] Revenge is forcing them to write a web app in the Lean proof assistant fully verified.
2021-07-18 05:12:20	tom__	[12:37:49] It has IO.
2021-07-18 05:12:20	maerwald	[12:38:25] right... clojure: forget a closing  bracket, code still compiles, but doesn't compute prime numbers... instead it compiles to a chess engine
2021-07-18 05:12:20	tom__	[12:38:42] haha
2021-07-18 05:12:20	maerwald	[12:38:45] type safe? Yeah maybe. But.
2021-07-18 05:12:20	kuribas	[12:38:48] arahael: I think you never actually used clojure?
2021-07-18 05:12:20	int-e	[12:39:03] tom__: That's deep in "overdoing it" territory. At least if the specification is anything more elaborate than "something in, something out", and even that may be tricky if you interpret it as a promise to fulfil request in finite time.
2021-07-18 05:12:20	kuribas	[12:39:26] arahael: it's a very mediocre runtime IMO, compared to java.  Error messages are nearly incomprehensible.  Tracing is nice though...
2021-07-18 05:12:20	tom__	[12:39:39] int-e: Yeah pointless torture :)
2021-07-18 05:12:20	maerwald	[12:39:50] the only upside of clojure is interactive development
2021-07-18 05:12:20	tom__	[12:40:08] The haskell compiler feels pretty interactive
2021-07-18 05:12:20	maerwald	[12:40:29] if HLS works, maybe
2021-07-18 05:12:20	arahael	[12:40:37] kuribas: Seemed to be effective enough.
2021-07-18 05:12:20	arahael	[12:40:53] But no, I haven't personally used it.
2021-07-18 05:12:20	maerwald	[12:41:00] but on the other hand: usually not. Compile times are too slow
2021-07-18 05:12:20	kuribas	[12:41:12] arahael: clojurists just have a different idea of "correct code".
2021-07-18 05:12:20	arahael	[12:41:15] I personally quite like ghcid.
2021-07-18 05:12:20	arahael	[12:41:27] kuribas: Indeed, but I think it's the process of discovery that they like.
2021-07-18 05:12:20	arahael	[12:41:57] kuribas: In haskell, we seem to prefer to test functions in isolation. Clojure people seem to prefer to test functions in the live system.
2021-07-18 05:12:20	maerwald	[12:42:00] if you're working on 300+ modules and your Type module has a whitespace change, you're gonna need to restart cabal a few times, because your machine OOMed due to TH
2021-07-18 05:12:20	tom__	[12:42:18] Which library is recommended for sampling probability distributions?
2021-07-18 05:12:20	arahael	[12:42:42] maerwald: The amount of memory Haskell uses is crazy high.  Sadly, I find it way faster than Swift. :/
2021-07-18 05:12:20	kuribas	[12:45:45] arahael: lispers will boast about how easy it is to hot patch live systems.  They don't tell you that it becomes very hard to see who changed what and when.
2021-07-18 05:12:20	kuribas	[12:46:05] arahael: so you'll end up with CI/CD anyway.  
2021-07-18 05:12:20	kuribas	[12:46:34] However a theoretically, a "live" programming environment with integrated version control could be nice.
2021-07-18 05:12:20	kuribas	[12:46:44] I don't know if that ever has been done.
2021-07-18 05:12:20	maerwald	[12:47:32] https://hackage.haskell.org/package/optics-th-0.4/docs/Optics-TH.html#v:makeClassy
2021-07-18 05:12:20	maerwald	[12:47:34] https://hackage.haskell.org/package/optics-th-0.4/docs/Optics-TH.html#v:makeFieldsNoPrefix
2021-07-18 05:12:20	maerwald	[12:47:36] https://hackage.haskell.org/package/generic-optics-2.2.0.0/docs/Data-Generics-Product-Fields.html#t:HasField
2021-07-18 05:12:20	maerwald	[12:47:38] which one of those to pick?
2021-07-18 05:12:20	maerwald	[12:49:00] HasField is kinda cool with those neat type errors
2021-07-18 05:12:20	boxscape	[15:15:35] maerwald: the TH versions say "This method of optics generation should only be used when migrating an existing codebase from the lens library to optics"
2021-07-18 05:12:20	boxscape	[15:15:51] maerwald: this, my final answer is C
2021-07-18 05:12:20	boxscape	[15:15:56] s/this/thus
2021-07-18 05:12:20	maerwald	[15:16:07] HasField?
2021-07-18 05:12:20	boxscape	[15:16:46] yeah.. though I thought there was a version of that which uses OverloadedLabels
2021-07-18 05:12:20	maerwald	[15:17:20] HasField though doesn't allow arbitrary subtyping... it's a simple getter
2021-07-18 05:12:20	maerwald	[15:17:54] with makeClassy style classes you could descend deeper into the structure with the same getter
2021-07-18 05:12:20	boxscape	[15:18:30] maerwald: oh actually the TH version links to https://hackage.haskell.org/package/optics-core-0.4/docs/Optics-Label.html as preferred solution
2021-07-18 05:12:20	boxscape	[15:19:03] that's the OverloadedLabels version I was remembering
2021-07-18 05:12:20	maerwald	[15:22:44] so there you could also define custom LabelOptic instances that descend into a structure?
2021-07-18 05:12:20	boxscape	[15:23:27] that seems plausible but I haven't tried doing it
2021-07-18 05:12:20	maerwald	[15:23:47] I'm leaning towards makeClassy, but I'm not sure
2021-07-18 05:12:20	boxscape	[15:24:25] I like makeClassy, the main reason I would avoid it personally is that the documentation advises against it
2021-07-18 05:12:20	maerwald	[15:25:40] so what does LabelOptic give over HasField?
2021-07-18 05:12:20	texasmynsted	[15:26:17] What is the modern answer to haskell records? Lens?
2021-07-18 05:12:20	maerwald	[15:26:49] only difference I see is labelOptic is `Optic` and HasField is a `Lens`
2021-07-18 05:12:20	boxscape	[15:28:24] hm I'm not sure what the concrete differences are
2021-07-18 05:12:20	boxscape	[15:30:52] texasmynsted: there are a few answers to this: In the next version, OverloadedRecordDot is being introduces, which allows one to write something like `personA.company.name`. (Updates are a bit iffy but will improve over time.) In the meantime, lens is definitely still widely used, though optics is a replacement which aims to have better error messages. There is also some research going into row types, but that's further out.
2021-07-18 05:12:20	boxscape	[15:30:55] s/next version/next version of GHC
2021-07-18 05:12:20	boxscape	[15:32:08] (though regarding row types, the vinyl records package allows something similar today)
2021-07-18 05:12:20	Guest14	[16:03:05] Hello :)
2021-07-18 05:12:20	Guest14	[16:03:40] I am new to Haskell and am working through the Real World Haskell Book
2021-07-18 05:12:20	Guest14	[16:04:27] I have a basic question if anyone would care to listen
2021-07-18 05:12:20	allbery_b	[16:06:02] best to just ask it rather than asking to ask
2021-07-18 05:12:20	davean	[16:06:23] asking to ask is why I wasn't helping
2021-07-18 05:12:20	Guest14	[16:07:44] splitWith _ [] = []
2021-07-18 05:12:20	Guest14	[16:07:45] splitWith a xs = [pre ++ [x]] ++ next
2021-07-18 05:12:20	Guest14	[16:07:45]     where 
2021-07-18 05:12:20	Guest14	[16:07:46]         (pre, x:suf) = span a xs
2021-07-18 05:12:20	Guest14	[16:07:46]         next = splitWith a suf
2021-07-18 05:12:20	Guest14	[16:08:10] I have this program and I run into a problem with x:suf when span a xs is [] becuase there is no head
2021-07-18 05:12:20	int-e	[16:09:34] > let f = splitAt 1 in (f "abc", f "")
2021-07-18 05:12:20	lambdabot	[16:09:36]  (("a","bc"),("",""))
2021-07-18 05:12:20	int-e	[16:11:31] (So maybe use splitAt instead of the x:suf pattern.)
2021-07-18 05:12:20	maerwald	[16:11:39] was there a question yet?
2021-07-18 05:12:20	davean	[16:11:45] No
2021-07-18 05:12:20	Guest14	[16:12:09] Ok I will give that a try thanks
2021-07-18 05:12:20	int-e	[16:12:10] They described a problem, close enough.
2021-07-18 05:12:20	maerwald	[16:12:35] They also described the answer
2021-07-18 05:12:20	maerwald	[16:12:38] "there is no head"
2021-07-18 05:12:20	int-e	[16:12:47] @where paste
2021-07-18 05:12:20	lambdabot	[16:12:47] Help us help you: please paste full code, input and/or output at e.g. https://paste.tomsmeding.com
2021-07-18 05:12:20	int-e	[16:13:04] maerwald: That's the reason, but not a solution for the problem?
2021-07-18 05:12:20	 *	int-e [16:13:06] shrugs
2021-07-18 05:12:20	maerwald	[16:13:10] So my answer is: yes
2021-07-18 05:12:20	int-e	[16:13:28] Well, so sorry for trying to be helpful.
2021-07-18 05:12:20	davean	[16:14:09] int-e: oh do be helpful
2021-07-18 05:12:20	Guest14	[16:15:14] int-e that worked thank you
2021-07-18 05:12:20	texasmynsted	[16:20:42] thank you boxscape 
2021-07-18 05:12:20	texasmynsted	[16:21:29] Sounds like optics or vinyl for now
2021-07-18 05:12:20	sm	[16:31:11] g'day all. Speaking of optics.. you experienced [lens] coders, do you find it good or bad for (a) fields and (b) lenses to be visually disctinct from other kinds of bindings (functions, "variables") ? As in eg _field/lens_, field_/lens__, _field/lensL, .... ?
2021-07-18 05:12:20	sm	[16:32:24] I feel it would be good overall, for avoiding collisions and for human comprehension . But I don't have a lot of lens experience
2021-07-18 05:12:20	maerwald	[16:40:10] can you derive LabelOptic with deriving via for an inner type? 
2021-07-18 05:12:20	oso	[16:42:50] xpost from #haskell-beginners:
2021-07-18 05:12:20	oso	[16:42:52] I'm passing around a type synonym for Int, but in reality the only constraint it needs to  follow is that it's hashable. what constructor do i use for this? my brain says go from `type UID = Int` to `data UID a = Hashable a` but that's very not correct, and google isn't helping much
2021-07-18 05:12:20	oso	[16:43:21] nvm sorry got an answer there
2021-07-18 05:12:20	glguy	[16:54:37] oso, if you just need to know that something is hashable you'd use it like: stuff :: Hashable a => a -> b -> c
2021-07-18 05:12:20	glguy	[16:55:19] If a parameter is the uid parameter you can document that like:  stuff :: Hashable uid => uid {- ^ the UID -} -> etc
2021-07-18 05:12:20	oso	[16:55:35] I was trying to do that while also using types to keep my signatures from becoming unwieldy, but first i'll just worry about getting the code working
2021-07-18 05:12:20	glguy	[16:56:22] the documentation for parameters goes in the haddock comments rather than type synonyms
2021-07-18 05:12:20	oso	[16:56:43] mmk
2021-07-18 05:12:20	dsal	[17:05:40] oso: It's tempting to put constraints in the type definitions, but if you take a look at, for example, `Data.Map.Strict` you'll see the type definition is just `data Map k a`.  You'd think k would always have to be ordered, but that's not the case.  You can create and work on maps that have unorderable keys when you don't do things that require ordering.  e.g.:
2021-07-18 05:12:20	dsal	[17:05:42] > M.elems $ (* 2) <$> M.singleton id 3
2021-07-18 05:12:20	lambdabot	[17:05:43]  [6]
2021-07-18 05:12:20	dsal	[17:07:10] The idea is that you only have to constrain things where they actually need to be constrained.  The Functor instance, e.g., doesn't care about the keys at all, so why should it require they're ordered?
2021-07-18 05:12:20	oso	[17:13:45] got it working \o/
2021-07-18 05:12:20	oso	[17:13:47] thank you
2021-07-18 05:12:20	hololeap	[17:46:09] so, I figured out a way to make a function with an arbitrary number of arguments using type families and type-level lists. but, I have to wonder ... has someone already made this and put it on hackage?
2021-07-18 05:12:20	texasmynsted	[17:47:46] wait, why do you want a function with an arbitrary number of arguments?
2021-07-18 05:12:20	c_wraith	[17:49:03] usually to cover for a lack of other expressiveness
2021-07-18 05:12:20	c_wraith	[17:49:09] printf is a common example
2021-07-18 05:12:20	texasmynsted	[17:49:12] Seems to me ideally a function should have exactly one argument
2021-07-18 05:12:20	c_wraith	[17:49:19] We can't write the type it actually has in Haskell
2021-07-18 05:12:20	c_wraith	[17:49:25] Because it's a dependent type
2021-07-18 05:12:20	c_wraith	[17:49:51] So varargs lets us do it anyway and fail at runtime if the programmer got it wrong
2021-07-18 05:12:20	texasmynsted	[17:50:07] printf solves a problem in a particular way that I think could be solved better, differently 
2021-07-18 05:12:20	c_wraith	[17:50:18] differently?  sure.  Better?  Not really.
2021-07-18 05:12:20	hololeap	[17:50:21] the motivation was because I had a typeclass with a function, and I encountered some outliers that needed extra arguments passed to that function
2021-07-18 05:12:20	texasmynsted	[17:50:47] c_wraith: I am not convinced 
2021-07-18 05:12:20	hololeap	[17:50:48] I'd have to write up a blog post or something to get into all the details
2021-07-18 05:12:20	Rembane	[17:50:57] hololeap: Do it! :D
2021-07-18 05:12:20	texasmynsted	[17:51:08] yes, that would be a good read
2021-07-18 05:12:20	c_wraith	[17:51:15] printf is *really* good at doing exactly what it's intended for.  Compactly specifying output formatted for monospace devices.
2021-07-18 05:12:20	texasmynsted	[17:51:32] like regular expressions?
2021-07-18 05:12:20	c_wraith	[17:51:42] honestly, it's more useful
2021-07-18 05:12:20	c_wraith	[17:52:01] regular expressions have to involve things like capturing group to really be useful, and those complicate APIs tremendously
2021-07-18 05:12:20	c_wraith	[17:52:05] printf has no such problems
2021-07-18 05:12:20	texasmynsted	[17:52:20] Right. I think regular expressions work great but are terrible and the problem is better solved differently 
2021-07-18 05:12:20	EvanR	[17:52:46] compare and contrast serious uses of printf with the expanded version, replicate that across a code base like 50 times and compare xD
2021-07-18 05:12:20	EvanR	[17:53:12] also, printf for debugging
2021-07-18 05:12:20	EvanR	[17:53:25] debugging would be harsher without it
2021-07-18 05:12:20	EvanR	[17:54:27] I'm more interested with this case of some function sometimes needing more arguments
2021-07-18 05:12:20	texasmynsted	[17:56:04] I am still going with functions should have exactly one argument 
2021-07-18 05:12:20	hololeap	[17:56:30] I mean... they do, technically.
2021-07-18 05:12:20	texasmynsted	[17:57:38] yes
2021-07-18 05:12:20	EvanR	[17:58:02] if the difference is between argument type (A,B) and (A,B,C) it's about argument type and not number
2021-07-18 05:12:20	texasmynsted	[17:58:23] Okay now we are getting somewhere
2021-07-18 05:12:20	texasmynsted	[19:06:50] sigh.
2021-07-18 05:12:20	oso	[19:07:39] seconded
2021-07-18 05:12:20	texasmynsted	[19:08:52] +1 oso
2021-07-18 05:12:20	monochrom	[19:32:57] Why so grim?
2021-07-18 05:12:20	boxscape	[19:33:18] hololeap: one of rae's latest videos is also about varargs https://youtu.be/iGSKqcebhfs
2021-07-18 05:12:20	monochrom	[19:33:22] You know "grim" and "grin" are just one curvy stroke apart. :)
2021-07-18 05:12:20	boxscape	[19:33:55] you can't spell slaughter without laughter, you can't spell grim without grin
2021-07-18 05:12:20	monochrom	[19:34:33] hee hee
2021-07-18 05:12:20	oso	[19:35:57] idk why texas is feeling grim but i'm extremely anxious about a work trip and trying to stuff the feelings down by adding documentation to my heretofore undocumented code
2021-07-18 05:12:20	monochrom	[19:36:32] My gripe about printf is I will be writing "%d %d %d %d %d %d %d" and then it's the same issue with (Int,Int,Int,Int,Int,Int). And I'm deliberately demonstrating an miscounting error for starters. But this issue is not about vararg, it's about losing structure.
2021-07-18 05:12:20	maerwald	[19:51:08] can you implement varargs in haskell without ambiguitiy due to partial application?
2021-07-18 05:12:20	maerwald	[19:51:18] (and I'm not talking about the typeclass trick)
2021-07-18 05:12:20	geekosaur	[19:52:19] I think there's a typesafe varargs via TH somewhere on hackage
2021-07-18 05:12:20	geekosaur	[19:52:48] probably relies on the format string being literal, but you have other problems if it's not anyway
2021-07-18 05:12:20	c_wraith	[19:53:46] In the general case, there's true ambiguity.  There's no general way to distinguish between providing all the arguments that will be provided and partially applying the function.
2021-07-18 05:12:20	geekosaur	[19:54:25] ^
2021-07-18 05:12:20	c_wraith	[19:55:20] this is why I described varargs as a workaround, not something worth having for itself :)
2021-07-18 05:12:20	Franciman	[19:56:21] Hi, does cabal support literate haskell?
2021-07-18 05:12:20	c_wraith	[19:56:38] if you put an .lhs extension on the files, it should find and compile them
2021-07-18 05:12:20	Franciman	[19:56:56] I have a project using .lhs files, but I get errors 
2021-07-18 05:12:20	Franciman	[19:56:58] wait 
2021-07-18 05:12:20	Franciman	[19:57:19]     `unlit' failed in phase `Literate pre-processor'. (Exit code: 1)
2021-07-18 05:12:20	c_wraith	[19:57:31] so it's trying!
2021-07-18 05:12:20	Franciman	[19:57:36] it is a module I specified in the other-modules
2021-07-18 05:12:20	Franciman	[19:57:45] so I wrote ListCursor
2021-07-18 05:12:20	Franciman	[19:57:49] instead of ListCursor.lhs
2021-07-18 05:12:20	Franciman	[19:58:08] I am really temped to ignore cabal and automatically go with ghc
2021-07-18 05:12:20	Franciman	[19:58:11] let me see what I can do
2021-07-18 05:12:20	geekosaur	[19:58:35] so it ran unlit, so it correctly found it was literate haskell. yoou could try running unlit manually and see what it choked on
2021-07-18 05:12:20	c_wraith	[19:58:40] that error doesn't look like you left out an extension
2021-07-18 05:12:20	c_wraith	[19:58:50] that error looks like it was incorrect literate haskell
2021-07-18 05:12:20	Franciman	[19:59:28] uhm
2021-07-18 05:12:20	Franciman	[20:00:10] geekosaur: how do I call unlit?
2021-07-18 05:12:20	Franciman	[20:00:16] I don't have an unlit program
2021-07-18 05:12:20	geekosaur	[20:00:32] it's in the library directory
2021-07-18 05:12:20	Franciman	[20:01:09] c_wraith: here is my code: https://bpa.st/A7JA
2021-07-18 05:12:20	geekosaur	[20:01:11] ghc --print-libdir
2021-07-18 05:12:20	geekosaur	[20:01:29] then unlit < yoursourcefile
2021-07-18 05:12:20	geekosaur	[20:01:48] with the fukll path to the unlit binary in the libdir
2021-07-18 05:12:20	Franciman	[20:02:36] geekosaur: sorry to bother again
2021-07-18 05:12:20	Franciman	[20:02:38] but I get
2021-07-18 05:12:20	Franciman	[20:02:43] usage: unlit [-q] [-n] [-c] [-#] [-P] [-h label] file1 file2
2021-07-18 05:12:20	Franciman	[20:02:47] and there is no help :D
2021-07-18 05:12:20	Franciman	[20:02:59] oh I am stupid
2021-07-18 05:12:20	Franciman	[20:03:01] sorry
2021-07-18 05:12:20	c_wraith	[20:03:03] I don't know if you can mix bird tracks and tex-style literate haskell in one file
2021-07-18 05:12:20	Franciman	[20:03:10] no ok, same problem
2021-07-18 05:12:20	Franciman	[20:03:31] c_wraith: uhm let me see
2021-07-18 05:12:20	geekosaur	[20:04:24] I don't think you can
2021-07-18 05:12:20	Franciman	[20:04:31] and in fact!
2021-07-18 05:12:20	Franciman	[20:04:35] thank you all
2021-07-18 05:12:20	Franciman	[20:05:10] only sad thing is that I can't use the # for markdown titles
2021-07-18 05:12:20	geekosaur	[20:05:26] unlit could use more documentation but I think it's largely fallen out of use
2021-07-18 05:12:20	Franciman	[20:05:38] nobody likes literate haskell?
2021-07-18 05:12:20	oso	[20:05:53] you could use the === underline in place of the # for header
2021-07-18 05:12:20	Franciman	[20:05:56] I mean, I understand, it does not even sync with haddock
2021-07-18 05:12:20	c_wraith	[20:06:01] in very broad terms, nobody likes literate programming
2021-07-18 05:12:20	Franciman	[20:06:08] yup, thanks oso 
2021-07-18 05:12:20	maerwald	[20:08:19] Franciman: no, it's not even bidirectional
2021-07-18 05:12:20	maerwald	[20:08:37] there's a project that fixes that
2021-07-18 05:12:20	maerwald	[20:08:43] but even then, not sure
2021-07-18 05:12:20	maerwald	[20:09:09] https://blog.esciencecenter.nl/entangled-1744448f4b9f
2021-07-18 05:12:20	maerwald	[20:09:25] https://github.com/entangled/entangled
2021-07-18 05:12:20	Franciman	[20:09:30] entangled is cool, I use it at my job
2021-07-18 05:12:20	Franciman	[20:09:36] it has some sore points
2021-07-18 05:12:20	Franciman	[20:09:39] and a lit of bugs
2021-07-18 05:12:20	Franciman	[20:09:50] lot* lol
2021-07-18 05:12:20	maerwald	[20:09:52] that's why it's LITerate
2021-07-18 05:12:20	maerwald	[20:09:54] lol
2021-07-18 05:12:20	Franciman	[20:09:57] LOL
2021-07-18 05:12:20	Franciman	[20:10:07] but it does not integrate well with ghc etc
2021-07-18 05:12:20	dsal	[20:16:13] Franciman: the last time I wrote literate Haskell, it was in markdown.  It's not bad.
2021-07-18 05:12:20	Franciman	[20:18:01] it is cool yeah
2021-07-18 05:12:20	Franciman	[20:18:25] only thing is, as it seems, it does not mix well with haddock
2021-07-18 05:12:20	Franciman	[20:18:32] you still have to add haddock special comments
2021-07-18 05:12:20	dsal	[20:21:13] Yeah, haddock is lacking in a few ways. I also want TH to work with it.
2021-07-18 05:12:20	dmj`	[20:22:54] an alternative haddock could be nice, could call it koi pond
2021-07-18 05:12:20	geekosaur	[20:24:15] there was at some point a discussion on cafe about incompatibilities between haddock markup and markdown that would make supporting both difficult
2021-07-18 05:12:20	monochrom	[20:35:56] It is sad that we now have to add "bi-directional" to refer to actual literate programming.
2021-07-18 05:12:20	monochrom	[20:36:33] Candidly, lhs is merely a nicer syntax for vanilla comments.
2021-07-18 05:12:20	monochrom	[20:38:15] Literate programming needed to be invented as a thing distinct from mere comments because the biggest part is to present your code in an order the computer doesn't expect. If a system can't do this, it is not literate programming.
2021-07-18 05:12:20	dmj`	[20:52:14] It would be really nice if Haskell abided by industry standards instead of custom stuff, like use toml, markdown, LLVM instead of cabal files, haddock syntax, Cmm 
2021-07-18 05:12:20	geekosaur	[20:55:29] llvm's not gonna happen unless you want to try to upstream a bunch of stuff so ghc can inform llvm of cps-ed stuff
2021-07-18 05:12:20	geekosaur	[20:56:01] and then arrange for ghc to be able to do so, but nobody's going to do that until there's somewhere for it to go
2021-07-18 05:12:20	Rembane	[20:57:04] Sounds like a moment 22
2021-07-18 05:12:20	geekosaur	[20:57:45] no, they know what needs to change and how, but it would require a bunch of llvm changes that are more or less ghc-specific
2021-07-18 05:12:20	geekosaur	[20:57:54] so they're unlikely to ever happen
2021-07-18 05:12:20	Rembane	[20:58:33] Got it! Then I misread, thank you for the clarification.
2021-07-18 05:12:20	noctux	[20:58:48] dmj`: industry standards? do you mean XML, more XML and visual-C? :P
2021-07-18 05:12:20	dmj`	[20:59:16] noctux: yes, XML over SOAP.
2021-07-18 05:12:20	maerwald	[20:59:30] dmj`: afair someone was actually working on providing a toml interface to cabal?
2021-07-18 05:12:20	maerwald	[20:59:41] or maybe I just imagined that
2021-07-18 05:12:20	dmj`	[21:00:33] geekosaur: what are your thoughts on GRIN as a backend for GHC
2021-07-18 05:12:20	geekosaur	[21:05:18] looks to me like it really wants to be a whole-program compiler? which ghc kinda doesn't
2021-07-18 05:12:20	geekosaur	[21:05:42] (and yet kinda does since it "fakes it" via exporting cidode in .hi files)
2021-07-18 05:12:20	geekosaur	[21:05:55] *code
2021-07-18 05:12:20	geekosaur	[21:07:27] still, makes me wonder how well grin would work if used thye way ghc would use it instead of whole-program
2021-07-18 05:12:20	geekosaur	[21:09:43] would really need to write out IR files instead of object files and let the backend take it from there, but I'm not sure how well ghc would work with that setup given it doesn't e.g. do that with llvm IR
2021-07-18 05:12:20	geekosaur	[21:11:06] and you couldn't mix grin backend objects with non-grin backend, like you currently can with llvm vs. asm
2021-07-18 05:12:20	geekosaur	[21:13:22] I think ghc would have to treat grin not as a backend but as a "way" (e.g. static vs. dynamic, or profiled vs. non-profiled)
2021-07-18 05:12:20	monochrom	[21:13:37] cabal was invented long before "industry standard" existed.
2021-07-18 05:12:20	monochrom	[21:14:02] Apart from XML.
2021-07-18 05:12:20	Rembane	[21:14:22] I wonder why industry didn't go with cabal's format. 
2021-07-18 05:12:20	monochrom	[21:15:23] And JVM bytecode.
2021-07-18 05:12:20	geekosaur	[21:15:50] because it's only friendly to haskell, since haskell is friendly to parsers?
2021-07-18 05:12:20	dmj`	[21:16:18] ghc-grin forks ghc it seems, exports *all* of the STG somewhere, does the analysis, brings it back and continues on in the pipeline, to great effect. Suppose we went the nuclear option and replaced STG with GRIN. GRIN would inline the eval function (which is currently hardcoded in the RTS), then perform the WPO, then emit LLVM. 
2021-07-18 05:12:20	geekosaur	[21:16:19] and the syntax is at least reminiscent of haskell
2021-07-18 05:12:20	dmj`	[21:16:34] We could even compile the RTS to GRIN and include it in the optimization phases, which would have the effect of dead code eliminating parts of the RTS that were unused, like GC for example. 
2021-07-18 05:12:20	geekosaur	[21:16:52] interesting
2021-07-18 05:12:20	dmj`	[21:20:33] benefits from WPO are so large even naive pointer analysis (steensgaard) is an enormous win, would still need a fast interpreter though
2021-07-18 05:12:20	dmj`	[21:21:12] thomas johnson created STG, then his final work was GRIN, but it never saw prominence in GHC, I wonder why that is
2021-07-18 05:12:20	geekosaur	[21:23:53] probably because ghc's architecture makes intervening at the stg layer more difficult than it should be
2021-07-18 05:12:20	dmj`	[21:30:54] exactly, too much code at that point
2021-07-18 05:12:20	dmj`	[21:35:03] realizing that GRIN's eval inlining is the first step in undoing the overhead of lazy evaluation (while preserving semantics) was pretty mind-blowing
2021-07-18 05:12:20	danso	[23:02:36] is there a typeclass that generalizes fromMaybe and fromRight? 
2021-07-18 05:12:20	danso	[23:02:53] it seems closely related to Alternative, like <|> 
2021-07-18 05:12:20	danso	[23:03:29] but (<|>) :: f a -> f a -> f a
2021-07-18 05:12:20	hpc	[23:03:31] :t traverse
2021-07-18 05:12:20	lambdabot	[23:03:32] (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
2021-07-18 05:12:20	danso	[23:03:41] i'm looking for f a -> f a -> a 
2021-07-18 05:12:20	geekosaur	[23:04:44] danso, what should such a typeclass do if it would fail?
2021-07-18 05:12:20	hpc	[23:04:55] maybe you want Foldable? https://hackage.haskell.org/package/base-4.15.0.0/docs/Prelude.html#t:Foldable
2021-07-18 05:12:20	danso	[23:05:10] oh you're right geekosaur 
2021-07-18 05:12:20	danso	[23:05:18] i made a mistake; i want f a -> a -> a 
2021-07-18 05:12:20	hpc	[23:05:36] % sum (Just 5)
2021-07-18 05:12:20	yahb	[23:05:36] hpc: 5
2021-07-18 05:12:20	hpc	[23:05:40] % sum Nothing
2021-07-18 05:12:20	yahb	[23:05:41] hpc: 0
2021-07-18 05:12:20	hpc	[23:05:52] % :t sum
2021-07-18 05:12:20	yahb	[23:05:53] hpc: (Foldable t, Num a) => t a -> a
2021-07-18 05:12:20	danso	[23:06:26] something like foldr (const id) is close maybe
2021-07-18 05:12:20	hpc	[23:07:03] :t foldMap
2021-07-18 05:12:20	lambdabot	[23:07:04] (Foldable t, Monoid m) => (a -> m) -> t a -> m
2021-07-18 05:12:20	danso	[23:07:54] wow, TIL Maybe is Foldable 
2021-07-18 05:12:20	hpc	[23:09:37] speaking of, TIL Complex is Foldable
2021-07-18 05:12:20	hpc	[23:09:59] % sum (5 :+ 10)
2021-07-18 05:12:20	yahb	[23:09:59] hpc: 15
2021-07-18 05:12:20	hpc	[23:10:15] and it... just combines the numbers
2021-07-18 05:12:20	hpc	[23:10:19] i don't know what i was expecting
2021-07-18 05:12:20	geekosaur	[23:14:30] o.O
2021-07-18 05:12:20	xsperry	[23:21:57] that's.. interesting
2021-07-18 05:12:20	monochrom	[23:35:07] That's the natural answer to someone who expects length (x,y) = 2.  Use length (x :+ y) instead.  >:)
2021-07-18 05:12:20	geekosaur	[23:36:48] > length (1,2) -- "natural"
2021-07-18 05:12:20	lambdabot	[23:36:49]  1
2021-07-18 05:12:20	 *	geekosaur [23:37:13] originally typoed "notural"
2021-07-18 05:12:20	monochrom	[23:39:17] And haha someone was ahead of me, Complex is a Monad too.
2021-07-18 05:12:20	***	Playback Complete.
2021-07-18 05:12:27	--	Channel created on Sun, 25 Apr 2021 01:04:39
2021-07-18 05:14:07	<--	merijn (~merijn@83-160-49-249.ip.xs4all.nl) has quit (Ping timeout: 268 seconds)
2021-07-18 05:14:42	<--	Tuplanolla (~Tuplanoll@91-159-68-239.elisa-laajakaista.fi) has quit (Quit: Leaving.)
2021-07-18 05:16:58	<--	DNH (~DNH@2a02:8108:1100:16d8:6178:3a47:8c71:dd89) has quit (Quit: Textual IRC Client: www.textualapp.com)
2021-07-18 05:21:39	-->	spruit11 (~quassel@2a02:a467:ccd6:1:b030:6032:2190:671b) has joined #haskell
2021-07-18 05:24:45	<--	machinedgod (~machinedg@24.105.81.50) has quit (Ping timeout: 255 seconds)
2021-07-18 05:26:13	boxscape	% :i Complex
2021-07-18 05:26:13	yahb	boxscape: type Complex :: * -> *; data Complex a = !a :+ !a; -- Defined in `Data.Complex'; instance Applicative Complex -- Defined in `Data.Complex'; instance Eq a => Eq (Complex a) -- Defined in `Data.Complex'; instance Functor Complex -- Defined in `Data.Complex'; instance Monad Complex -- Defined in `Data.Complex'; instance RealFloat a => Floating (Complex a) -- Defined in `Data.Complex'; instance RealFloat a
2021-07-18 05:26:22	<--	spruit11 (~quassel@2a02:a467:ccd6:1:b030:6032:2190:671b) has quit (Ping timeout: 246 seconds)
2021-07-18 05:26:51	boxscape	so Complex is really just `Pair`, with all the behavior you would expect (and then some, for the number stuff)
2021-07-18 05:26:55	-->	Null_A (~null_a@2601:645:8700:2290:b55a:33c2:1e1d:f229) has joined #haskell
2021-07-18 05:27:31	geekosaur	so if you ever need that value with a type that's both Num and Monad…
2021-07-18 05:28:19	boxscape	% (1 :+ 2) >>= (\x -> x :+ x)
2021-07-18 05:28:20	yahb	boxscape: 1 :+ 2
2021-07-18 05:29:23	monochrom	:)
2021-07-18 05:33:04	--	irc: disconnected from server
2021-07-18 16:36:24	-->	amanr (~therojjha@20.204.87.0) has joined #haskell
2021-07-18 16:36:24	--	Topic for #haskell is "https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org | Paste code/errors: https://paste.tomsmeding.com | tunes.org-style logging should be coming soon | Logs: https://ircbrowse.tomsmeding.com/browse/lchaskell"
2021-07-18 16:36:24	--	Topic set by geekosaur (~geekosaur@xmonad/geekosaur) on Mon, 14 Jun 2021 05:16:14
2021-07-18 16:36:24	--	Channel #haskell: 693 nicks (1 op, 0 voices, 692 normals)
2021-07-18 16:36:24	***	Buffer Playback...
2021-07-18 16:36:24	arkanoid	[10:23:16] the Error monad link is broken https://wiki.haskell.org/Errormonad.html
2021-07-18 16:36:24	kuribas	[10:45:22] How does haskell compare to other functional languages?  Looking a bit at SML and OCaml, it seems that haskell has far more libraries, and is more practical for real world projects (other than compilers etc).
2021-07-18 16:36:24	kuribas	[10:46:31] Of course scala and clojure are also popular, but I don't consider clojure a real functional language, it's more a lisp derivative.  And Scala is mostly multiparadigm, and also complex and overengineerd.
2021-07-18 16:36:24	arahael	[10:47:48] kuribas: I use haskell for most of my private hobby/side projects.  It's awesule, but I've used F# and Swift, which are somewhat OCaml-inspired.
2021-07-18 16:36:24	arahael	[10:48:25] kuribas: The biggest most profound difference with Haskell is that it's *lazy*, and has a really really good type system, but in practice that it's lazy makes a big difference to how you use haskell.
2021-07-18 16:36:24	kuribas	[10:48:54] arahael: how much libraries are there for F#?  Or does it just use the C# ecosystem?
2021-07-18 16:36:24	arahael	[10:49:05] F# is just another .NET language, really, yeah.
2021-07-18 16:36:24	arahael	[10:49:17] As is C#. :)
2021-07-18 16:36:24	kuribas	[10:49:20] doesn't that mean that most libraries aren't really made for FP?
2021-07-18 16:36:24	arahael	[10:50:00] Kinda.  The way F# copes with nulls is interesting. (It assumes there aren't any).
2021-07-18 16:36:24	kuribas	[10:50:41] then how do you test if a function returns null?
2021-07-18 16:36:24	arahael	[10:51:33] kuribas: That's a trap, yeah.  In earlier versions, you'd check for it explicitly, and the compiler lets you. But then, the compiler *elides* that check because it thinks better.
2021-07-18 16:36:24	arahael	[10:51:44] Hopefully they've changed that now.
2021-07-18 16:36:24	arahael	[10:53:33] Looks like they've changed it - suggesting instead to use pattern matching.  Far better: https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/values/null-values
2021-07-18 16:36:24	arahael	[10:53:59] But anyway, one difference is that Haskell is lazy, so your functions must not have side effects.
2021-07-18 16:36:24	arahael	[10:54:30] And since that practice is so strictly encouraged (otherwise you risk loosing your sanity), that has a flow-on effect to all of haskell's libraries, too.
2021-07-18 16:36:24	DigitalKiwi	[10:55:34] haskell is non-strict
2021-07-18 16:36:24	DigitalKiwi	[10:55:52] https://wiki.haskell.org/Lazy_vs._non-strict
2021-07-18 16:36:24	arahael	[10:56:01] Yeah - more accurate - thanks for that.
2021-07-18 16:36:24	DigitalKiwi	[10:56:34] speaking only for myself haskell programmers are lazy ;)
2021-07-18 16:36:24	arahael	[10:58:05] Hmm. :)
2021-07-18 16:36:24	DigitalKiwi	[11:01:36] and obsesssed with bottoms
2021-07-18 16:36:24	 *	DigitalKiwi [11:02:01] drops mic
2021-07-18 16:36:24	Rembane	[11:03:21] I like lazy bottoms and I cannot lie.
2021-07-18 16:36:24	 *	arahael [11:05:07] suddenly realises why bottom is drawn like _|_
2021-07-18 16:36:24	DigitalKiwi	[11:06:04] dibblego twitter avatar lolol
2021-07-18 16:36:24	kuribas	[11:08:21] arahael: so haskell is the only language that doesn't let you get away coding imperative OO in it?
2021-07-18 16:36:24	kuribas	[11:09:07] Although imperative style is still quite possible in haskell.  OO on the other hand is pretty hard.
2021-07-18 16:36:24	dibblego	[11:09:35] DigitalKiwi: that's BUMFISH
2021-07-18 16:36:24	DigitalKiwi	[11:10:01] is that a new operator
2021-07-18 16:36:24	dibblego	[11:11:41] no, it's a pre-landing checklist
2021-07-18 16:36:24	arahael	[11:13:08] Heh.
2021-07-18 16:36:24	arahael	[11:13:36] kuribas: If it's subtyping you're referring to, no, I don't think haskell has that.
2021-07-18 16:36:24	arahael	[11:13:58] kuribas: It does have classes and instances, though, but they behave quite differently.
2021-07-18 16:36:24	kuribas	[11:14:06] And that's a good thing...
2021-07-18 16:36:24	 *	arahael [11:14:25] thinks so.
2021-07-18 16:36:24	DigitalKiwi	[11:14:37] https://www.parsonsmatt.org/2017/02/17/object_oriented_programming_in_haskell.html
2021-07-18 16:36:24	DigitalKiwi	[11:16:43] https://hackage.haskell.org/package/hoop
2021-07-18 16:36:24	DigitalKiwi	[11:16:56] cue bot "haskell can do that!"
2021-07-18 16:36:24	dibblego	[11:22:23] DigitalKiwi: https://flightscope.gitlab.io/aircraft/checklist/eurofox.pdf page 1, top-right
2021-07-18 16:36:24	kuribas	[11:58:55] I've been accused of being a haskell lanuage zealot.  But actually I am interested in other languages (logic, FP, dependently typed, etc...).  It just doesn't seem to be useful to push for other languages that I know less...
2021-07-18 16:36:24	kuribas	[11:59:21] I could recommend F# instead of haskell, but I don't know it that well, so there is less benefit IMO...
2021-07-18 16:36:24	kuribas	[12:04:48] Every time I come with rational arguments, I get a reply like "But I don't like types, they get in the way".  Or "programming languages don't matter, business logic does".  Or "I don't care it's more robust, we want to move fast and solve bugs as we go".
2021-07-18 16:36:24	dibblego	[12:18:06] get used to it
2021-07-18 16:36:24	tom__	[12:18:47] kuribas: I feel your pain
2021-07-18 16:36:24	tom__	[12:19:43] "Types get in the way" then spends three hours NULL chasing
2021-07-18 16:36:24	kuribas	[12:20:50] tom__: exactly!  I spend far more time thinking about types in clojure than in haskell.
2021-07-18 16:36:24	maerwald	[12:21:11] types can get in the way, especially since haskell lacks structural typing
2021-07-18 16:36:24	tom__	[12:21:34] haha sometimes you want types to get in the way
2021-07-18 16:36:24	maerwald	[12:21:51] I know of at least one Haskell dev who now works full-time with typescript and doesn't regret it
2021-07-18 16:36:24	maerwald	[12:22:09] I probably wouldn't, but it's a valid position
2021-07-18 16:36:24	tom__	[12:22:55] Clojure to me is just javascript with some immutability
2021-07-18 16:36:24	kuribas	[12:23:22] maerwald: I find that often, it just amounts to having a bit more boilerplate.  Or having duplicate type definitions.
2021-07-18 16:36:24	maerwald	[12:23:40] it can be a *lot* of boilerplate
2021-07-18 16:36:24	maerwald	[12:24:00] and prohibits you of expressing certain relationships between data
2021-07-18 16:36:24	tom__	[12:24:19] Haskell, Rust and Julia - desert island stack
2021-07-18 16:36:24	tom__	[12:24:37] Havent tried the latter two :D
2021-07-18 16:36:24	maerwald	[12:24:58] class based solutions don't work well when you need an *actual* data type for serialisation
2021-07-18 16:36:24	maerwald	[12:25:45] typescript is surprisingly simple and powerful on these matters... certainly less elegant and unsound in a few places, but that's the tradeoff the make
2021-07-18 16:36:24	kuribas	[12:26:10] tom__: rust is only my "to learn list" :)
2021-07-18 16:36:24	kuribas	[12:26:42] maerwald: you can be less elegant and unsound in haskell too...
2021-07-18 16:36:24	maerwald	[12:27:02] kuribas: yeah, but that usually involves MORE complexity, not less
2021-07-18 16:36:24	maerwald	[12:27:10] so the opposite of typescript
2021-07-18 16:36:24	tom__	[12:27:22] You can be and then people who don't understand what a theoretical model is say that it must mean Haskell is pointless
2021-07-18 16:36:24	kuribas	[12:28:12] maerwald: I don't agree
2021-07-18 16:36:24	maerwald	[12:28:47] well, you *can* do some forms of structural typing/subtyping, but it all ends in esoteric libraries
2021-07-18 16:36:24	kuribas	[12:29:00] maerwald: so don't do it.
2021-07-18 16:36:24	maerwald	[12:29:03] while you get all that in TS for free without complexity
2021-07-18 16:36:24	maerwald	[12:29:45] well, I'm not commenting on which language is better, I'm just commenting on "types can get in the way", because they can
2021-07-18 16:36:24	kuribas	[12:29:55] maerwald: plenty of ways to get around that: 1) partially applied functions (the Endo trick), create a new type with some of the fields.  3) just make the fields all Maybe.
2021-07-18 16:36:24	kuribas	[12:30:56] maerwald: there is a difference between "the types sometimes get in the way", and "the types always get in the way", the latter is what they seem to be implying.
2021-07-18 16:36:24	maerwald	[12:31:02] 1) difficult for serialisation, Show instances, debugging, ... 2) boilerplate, 3) unexpressive, because now you have two cases of `Maybe`
2021-07-18 16:36:24	kuribas	[12:32:02] You don't need two cases of Maybe
2021-07-18 16:36:24	kuribas	[12:32:44] and 4) just put default values.
2021-07-18 16:36:24	maerwald	[12:33:32] 1. there's no such value, because the computation doesn't return one for the given input, 2. there's no such value, because the computation can *never* return one
2021-07-18 16:36:24	maerwald	[12:33:45] now you also have to wonder: 3. there's a value, but there shouldn't be one
2021-07-18 16:36:24	maerwald	[12:33:47] oops
2021-07-18 16:36:24	kuribas	[12:33:47] IMO, the more you want correctness, the more you are restricted in what you write.  It has nothing to do with types (directly).
2021-07-18 16:36:24	kuribas	[12:34:28] maerwald: if you grab to clojure, you don't care anyway...
2021-07-18 16:36:24	maerwald	[12:34:48] default values.. what's my default account balance? :p
2021-07-18 16:36:24	dibblego	[12:34:54] like I said, get used to it
2021-07-18 16:36:24	tom__	[12:35:20] ^ yes and get used to makeNegative = (*) -1
2021-07-18 16:36:24	kuribas	[12:35:49] Which is my point, haskell can be a nice unsafe language to.  Just make a big sum type, and partial functions over it (don't forget to add error messages though...).
2021-07-18 16:36:24	maerwald	[12:36:21] well, with structural typing you don't need to be partial
2021-07-18 16:36:24	int-e	[12:36:25] Or unsafeCoerce everything and program untyped lambda calculus? :)
2021-07-18 16:36:24	arahael	[12:36:48] kuribas: Mind you, Clojure seems to offer alternative methods to allow you to type ocrrect code.  In particular, Clojure seems to have a fantastic runtime repl.
2021-07-18 16:36:24	arahael	[12:37:15] kuribas: Such that you're running the live program and debugging it and replacing functions on the fly.
2021-07-18 16:36:24	int-e	[12:37:26] I like types, they prevent some of the more embarrassing programming errors from being run as code.
2021-07-18 16:36:24	tom__	[12:37:44] Revenge is forcing them to write a web app in the Lean proof assistant fully verified.
2021-07-18 16:36:24	tom__	[12:37:49] It has IO.
2021-07-18 16:36:24	maerwald	[12:38:25] right... clojure: forget a closing  bracket, code still compiles, but doesn't compute prime numbers... instead it compiles to a chess engine
2021-07-18 16:36:24	tom__	[12:38:42] haha
2021-07-18 16:36:24	maerwald	[12:38:45] type safe? Yeah maybe. But.
2021-07-18 16:36:24	kuribas	[12:38:48] arahael: I think you never actually used clojure?
2021-07-18 16:36:24	int-e	[12:39:03] tom__: That's deep in "overdoing it" territory. At least if the specification is anything more elaborate than "something in, something out", and even that may be tricky if you interpret it as a promise to fulfil request in finite time.
2021-07-18 16:36:24	kuribas	[12:39:26] arahael: it's a very mediocre runtime IMO, compared to java.  Error messages are nearly incomprehensible.  Tracing is nice though...
2021-07-18 16:36:24	tom__	[12:39:39] int-e: Yeah pointless torture :)
2021-07-18 16:36:24	maerwald	[12:39:50] the only upside of clojure is interactive development
2021-07-18 16:36:24	tom__	[12:40:08] The haskell compiler feels pretty interactive
2021-07-18 16:36:24	maerwald	[12:40:29] if HLS works, maybe
2021-07-18 16:36:24	arahael	[12:40:37] kuribas: Seemed to be effective enough.
2021-07-18 16:36:24	arahael	[12:40:53] But no, I haven't personally used it.
2021-07-18 16:36:24	maerwald	[12:41:00] but on the other hand: usually not. Compile times are too slow
2021-07-18 16:36:24	kuribas	[12:41:12] arahael: clojurists just have a different idea of "correct code".
2021-07-18 16:36:24	arahael	[12:41:15] I personally quite like ghcid.
2021-07-18 16:36:24	arahael	[12:41:27] kuribas: Indeed, but I think it's the process of discovery that they like.
2021-07-18 16:36:24	arahael	[12:41:57] kuribas: In haskell, we seem to prefer to test functions in isolation. Clojure people seem to prefer to test functions in the live system.
2021-07-18 16:36:24	maerwald	[12:42:00] if you're working on 300+ modules and your Type module has a whitespace change, you're gonna need to restart cabal a few times, because your machine OOMed due to TH
2021-07-18 16:36:24	tom__	[12:42:18] Which library is recommended for sampling probability distributions?
2021-07-18 16:36:24	arahael	[12:42:42] maerwald: The amount of memory Haskell uses is crazy high.  Sadly, I find it way faster than Swift. :/
2021-07-18 16:36:24	kuribas	[12:45:45] arahael: lispers will boast about how easy it is to hot patch live systems.  They don't tell you that it becomes very hard to see who changed what and when.
2021-07-18 16:36:24	kuribas	[12:46:05] arahael: so you'll end up with CI/CD anyway.  
2021-07-18 16:36:24	kuribas	[12:46:34] However a theoretically, a "live" programming environment with integrated version control could be nice.
2021-07-18 16:36:24	kuribas	[12:46:44] I don't know if that ever has been done.
2021-07-18 16:36:24	maerwald	[12:47:32] https://hackage.haskell.org/package/optics-th-0.4/docs/Optics-TH.html#v:makeClassy
2021-07-18 16:36:24	maerwald	[12:47:34] https://hackage.haskell.org/package/optics-th-0.4/docs/Optics-TH.html#v:makeFieldsNoPrefix
2021-07-18 16:36:24	maerwald	[12:47:36] https://hackage.haskell.org/package/generic-optics-2.2.0.0/docs/Data-Generics-Product-Fields.html#t:HasField
2021-07-18 16:36:24	maerwald	[12:47:38] which one of those to pick?
2021-07-18 16:36:24	maerwald	[12:49:00] HasField is kinda cool with those neat type errors
2021-07-18 16:36:24	boxscape	[15:15:35] maerwald: the TH versions say "This method of optics generation should only be used when migrating an existing codebase from the lens library to optics"
2021-07-18 16:36:24	boxscape	[15:15:51] maerwald: this, my final answer is C
2021-07-18 16:36:24	boxscape	[15:15:56] s/this/thus
2021-07-18 16:36:24	maerwald	[15:16:07] HasField?
2021-07-18 16:36:24	boxscape	[15:16:46] yeah.. though I thought there was a version of that which uses OverloadedLabels
2021-07-18 16:36:24	maerwald	[15:17:20] HasField though doesn't allow arbitrary subtyping... it's a simple getter
2021-07-18 16:36:24	maerwald	[15:17:54] with makeClassy style classes you could descend deeper into the structure with the same getter
2021-07-18 16:36:24	boxscape	[15:18:30] maerwald: oh actually the TH version links to https://hackage.haskell.org/package/optics-core-0.4/docs/Optics-Label.html as preferred solution
2021-07-18 16:36:24	boxscape	[15:19:03] that's the OverloadedLabels version I was remembering
2021-07-18 16:36:24	maerwald	[15:22:44] so there you could also define custom LabelOptic instances that descend into a structure?
2021-07-18 16:36:24	boxscape	[15:23:27] that seems plausible but I haven't tried doing it
2021-07-18 16:36:24	maerwald	[15:23:47] I'm leaning towards makeClassy, but I'm not sure
2021-07-18 16:36:24	boxscape	[15:24:25] I like makeClassy, the main reason I would avoid it personally is that the documentation advises against it
2021-07-18 16:36:24	maerwald	[15:25:40] so what does LabelOptic give over HasField?
2021-07-18 16:36:24	texasmynsted	[15:26:17] What is the modern answer to haskell records? Lens?
2021-07-18 16:36:24	maerwald	[15:26:49] only difference I see is labelOptic is `Optic` and HasField is a `Lens`
2021-07-18 16:36:24	boxscape	[15:28:24] hm I'm not sure what the concrete differences are
2021-07-18 16:36:24	boxscape	[15:30:52] texasmynsted: there are a few answers to this: In the next version, OverloadedRecordDot is being introduces, which allows one to write something like `personA.company.name`. (Updates are a bit iffy but will improve over time.) In the meantime, lens is definitely still widely used, though optics is a replacement which aims to have better error messages. There is also some research going into row types, but that's further out.
2021-07-18 16:36:24	boxscape	[15:30:55] s/next version/next version of GHC
2021-07-18 16:36:24	boxscape	[15:32:08] (though regarding row types, the vinyl records package allows something similar today)
2021-07-18 16:36:24	Guest14	[16:03:05] Hello :)
2021-07-18 16:36:24	Guest14	[16:03:40] I am new to Haskell and am working through the Real World Haskell Book
2021-07-18 16:36:24	Guest14	[16:04:27] I have a basic question if anyone would care to listen
2021-07-18 16:36:24	allbery_b	[16:06:02] best to just ask it rather than asking to ask
2021-07-18 16:36:24	davean	[16:06:23] asking to ask is why I wasn't helping
2021-07-18 16:36:24	Guest14	[16:07:44] splitWith _ [] = []
2021-07-18 16:36:24	Guest14	[16:07:45] splitWith a xs = [pre ++ [x]] ++ next
2021-07-18 16:36:24	Guest14	[16:07:45]     where 
2021-07-18 16:36:24	Guest14	[16:07:46]         (pre, x:suf) = span a xs
2021-07-18 16:36:24	Guest14	[16:07:46]         next = splitWith a suf
2021-07-18 16:36:24	Guest14	[16:08:10] I have this program and I run into a problem with x:suf when span a xs is [] becuase there is no head
2021-07-18 16:36:24	int-e	[16:09:34] > let f = splitAt 1 in (f "abc", f "")
2021-07-18 16:36:24	lambdabot	[16:09:36]  (("a","bc"),("",""))
2021-07-18 16:36:24	int-e	[16:11:31] (So maybe use splitAt instead of the x:suf pattern.)
2021-07-18 16:36:24	maerwald	[16:11:39] was there a question yet?
2021-07-18 16:36:24	davean	[16:11:45] No
2021-07-18 16:36:24	Guest14	[16:12:09] Ok I will give that a try thanks
2021-07-18 16:36:24	int-e	[16:12:10] They described a problem, close enough.
2021-07-18 16:36:24	maerwald	[16:12:35] They also described the answer
2021-07-18 16:36:24	maerwald	[16:12:38] "there is no head"
2021-07-18 16:36:24	int-e	[16:12:47] @where paste
2021-07-18 16:36:24	lambdabot	[16:12:47] Help us help you: please paste full code, input and/or output at e.g. https://paste.tomsmeding.com
2021-07-18 16:36:24	int-e	[16:13:04] maerwald: That's the reason, but not a solution for the problem?
2021-07-18 16:36:24	 *	int-e [16:13:06] shrugs
2021-07-18 16:36:24	maerwald	[16:13:10] So my answer is: yes
2021-07-18 16:36:24	int-e	[16:13:28] Well, so sorry for trying to be helpful.
2021-07-18 16:36:24	davean	[16:14:09] int-e: oh do be helpful
2021-07-18 16:36:24	Guest14	[16:15:14] int-e that worked thank you
2021-07-18 16:36:24	texasmynsted	[16:20:42] thank you boxscape 
2021-07-18 16:36:24	texasmynsted	[16:21:29] Sounds like optics or vinyl for now
2021-07-18 16:36:24	sm	[16:31:11] g'day all. Speaking of optics.. you experienced [lens] coders, do you find it good or bad for (a) fields and (b) lenses to be visually disctinct from other kinds of bindings (functions, "variables") ? As in eg _field/lens_, field_/lens__, _field/lensL, .... ?
2021-07-18 16:36:24	sm	[16:32:24] I feel it would be good overall, for avoiding collisions and for human comprehension . But I don't have a lot of lens experience
2021-07-18 16:36:24	maerwald	[16:40:10] can you derive LabelOptic with deriving via for an inner type? 
2021-07-18 16:36:24	oso	[16:42:50] xpost from #haskell-beginners:
2021-07-18 16:36:24	oso	[16:42:52] I'm passing around a type synonym for Int, but in reality the only constraint it needs to  follow is that it's hashable. what constructor do i use for this? my brain says go from `type UID = Int` to `data UID a = Hashable a` but that's very not correct, and google isn't helping much
2021-07-18 16:36:24	oso	[16:43:21] nvm sorry got an answer there
2021-07-18 16:36:24	glguy	[16:54:37] oso, if you just need to know that something is hashable you'd use it like: stuff :: Hashable a => a -> b -> c
2021-07-18 16:36:24	glguy	[16:55:19] If a parameter is the uid parameter you can document that like:  stuff :: Hashable uid => uid {- ^ the UID -} -> etc
2021-07-18 16:36:24	oso	[16:55:35] I was trying to do that while also using types to keep my signatures from becoming unwieldy, but first i'll just worry about getting the code working
2021-07-18 16:36:24	glguy	[16:56:22] the documentation for parameters goes in the haddock comments rather than type synonyms
2021-07-18 16:36:24	oso	[16:56:43] mmk
2021-07-18 16:36:24	dsal	[17:05:40] oso: It's tempting to put constraints in the type definitions, but if you take a look at, for example, `Data.Map.Strict` you'll see the type definition is just `data Map k a`.  You'd think k would always have to be ordered, but that's not the case.  You can create and work on maps that have unorderable keys when you don't do things that require ordering.  e.g.:
2021-07-18 16:36:24	dsal	[17:05:42] > M.elems $ (* 2) <$> M.singleton id 3
2021-07-18 16:36:24	lambdabot	[17:05:43]  [6]
2021-07-18 16:36:24	dsal	[17:07:10] The idea is that you only have to constrain things where they actually need to be constrained.  The Functor instance, e.g., doesn't care about the keys at all, so why should it require they're ordered?
2021-07-18 16:36:24	oso	[17:13:45] got it working \o/
2021-07-18 16:36:24	oso	[17:13:47] thank you
2021-07-18 16:36:24	hololeap	[17:46:09] so, I figured out a way to make a function with an arbitrary number of arguments using type families and type-level lists. but, I have to wonder ... has someone already made this and put it on hackage?
2021-07-18 16:36:24	texasmynsted	[17:47:46] wait, why do you want a function with an arbitrary number of arguments?
2021-07-18 16:36:24	c_wraith	[17:49:03] usually to cover for a lack of other expressiveness
2021-07-18 16:36:24	c_wraith	[17:49:09] printf is a common example
2021-07-18 16:36:24	texasmynsted	[17:49:12] Seems to me ideally a function should have exactly one argument
2021-07-18 16:36:24	c_wraith	[17:49:19] We can't write the type it actually has in Haskell
2021-07-18 16:36:24	c_wraith	[17:49:25] Because it's a dependent type
2021-07-18 16:36:24	c_wraith	[17:49:51] So varargs lets us do it anyway and fail at runtime if the programmer got it wrong
2021-07-18 16:36:24	texasmynsted	[17:50:07] printf solves a problem in a particular way that I think could be solved better, differently 
2021-07-18 16:36:24	c_wraith	[17:50:18] differently?  sure.  Better?  Not really.
2021-07-18 16:36:24	hololeap	[17:50:21] the motivation was because I had a typeclass with a function, and I encountered some outliers that needed extra arguments passed to that function
2021-07-18 16:36:24	texasmynsted	[17:50:47] c_wraith: I am not convinced 
2021-07-18 16:36:24	hololeap	[17:50:48] I'd have to write up a blog post or something to get into all the details
2021-07-18 16:36:24	Rembane	[17:50:57] hololeap: Do it! :D
2021-07-18 16:36:24	texasmynsted	[17:51:08] yes, that would be a good read
2021-07-18 16:36:24	c_wraith	[17:51:15] printf is *really* good at doing exactly what it's intended for.  Compactly specifying output formatted for monospace devices.
2021-07-18 16:36:24	texasmynsted	[17:51:32] like regular expressions?
2021-07-18 16:36:24	c_wraith	[17:51:42] honestly, it's more useful
2021-07-18 16:36:24	c_wraith	[17:52:01] regular expressions have to involve things like capturing group to really be useful, and those complicate APIs tremendously
2021-07-18 16:36:24	c_wraith	[17:52:05] printf has no such problems
2021-07-18 16:36:24	texasmynsted	[17:52:20] Right. I think regular expressions work great but are terrible and the problem is better solved differently 
2021-07-18 16:36:24	EvanR	[17:52:46] compare and contrast serious uses of printf with the expanded version, replicate that across a code base like 50 times and compare xD
2021-07-18 16:36:24	EvanR	[17:53:12] also, printf for debugging
2021-07-18 16:36:24	EvanR	[17:53:25] debugging would be harsher without it
2021-07-18 16:36:24	EvanR	[17:54:27] I'm more interested with this case of some function sometimes needing more arguments
2021-07-18 16:36:24	texasmynsted	[17:56:04] I am still going with functions should have exactly one argument 
2021-07-18 16:36:24	hololeap	[17:56:30] I mean... they do, technically.
2021-07-18 16:36:24	texasmynsted	[17:57:38] yes
2021-07-18 16:36:24	EvanR	[17:58:02] if the difference is between argument type (A,B) and (A,B,C) it's about argument type and not number
2021-07-18 16:36:24	texasmynsted	[17:58:23] Okay now we are getting somewhere
2021-07-18 16:36:24	texasmynsted	[19:06:50] sigh.
2021-07-18 16:36:24	oso	[19:07:39] seconded
2021-07-18 16:36:24	texasmynsted	[19:08:52] +1 oso
2021-07-18 16:36:24	monochrom	[19:32:57] Why so grim?
2021-07-18 16:36:24	boxscape	[19:33:18] hololeap: one of rae's latest videos is also about varargs https://youtu.be/iGSKqcebhfs
2021-07-18 16:36:24	monochrom	[19:33:22] You know "grim" and "grin" are just one curvy stroke apart. :)
2021-07-18 16:36:24	boxscape	[19:33:55] you can't spell slaughter without laughter, you can't spell grim without grin
2021-07-18 16:36:24	monochrom	[19:34:33] hee hee
2021-07-18 16:36:24	oso	[19:35:57] idk why texas is feeling grim but i'm extremely anxious about a work trip and trying to stuff the feelings down by adding documentation to my heretofore undocumented code
2021-07-18 16:36:24	monochrom	[19:36:32] My gripe about printf is I will be writing "%d %d %d %d %d %d %d" and then it's the same issue with (Int,Int,Int,Int,Int,Int). And I'm deliberately demonstrating an miscounting error for starters. But this issue is not about vararg, it's about losing structure.
2021-07-18 16:36:24	maerwald	[19:51:08] can you implement varargs in haskell without ambiguitiy due to partial application?
2021-07-18 16:36:24	maerwald	[19:51:18] (and I'm not talking about the typeclass trick)
2021-07-18 16:36:24	geekosaur	[19:52:19] I think there's a typesafe varargs via TH somewhere on hackage
2021-07-18 16:36:24	geekosaur	[19:52:48] probably relies on the format string being literal, but you have other problems if it's not anyway
2021-07-18 16:36:24	c_wraith	[19:53:46] In the general case, there's true ambiguity.  There's no general way to distinguish between providing all the arguments that will be provided and partially applying the function.
2021-07-18 16:36:24	geekosaur	[19:54:25] ^
2021-07-18 16:36:24	c_wraith	[19:55:20] this is why I described varargs as a workaround, not something worth having for itself :)
2021-07-18 16:36:24	Franciman	[19:56:21] Hi, does cabal support literate haskell?
2021-07-18 16:36:24	c_wraith	[19:56:38] if you put an .lhs extension on the files, it should find and compile them
2021-07-18 16:36:24	Franciman	[19:56:56] I have a project using .lhs files, but I get errors 
2021-07-18 16:36:24	Franciman	[19:56:58] wait 
2021-07-18 16:36:24	Franciman	[19:57:19]     `unlit' failed in phase `Literate pre-processor'. (Exit code: 1)
2021-07-18 16:36:24	c_wraith	[19:57:31] so it's trying!
2021-07-18 16:36:24	Franciman	[19:57:36] it is a module I specified in the other-modules
2021-07-18 16:36:24	Franciman	[19:57:45] so I wrote ListCursor
2021-07-18 16:36:24	Franciman	[19:57:49] instead of ListCursor.lhs
2021-07-18 16:36:24	Franciman	[19:58:08] I am really temped to ignore cabal and automatically go with ghc
2021-07-18 16:36:24	Franciman	[19:58:11] let me see what I can do
2021-07-18 16:36:24	geekosaur	[19:58:35] so it ran unlit, so it correctly found it was literate haskell. yoou could try running unlit manually and see what it choked on
2021-07-18 16:36:24	c_wraith	[19:58:40] that error doesn't look like you left out an extension
2021-07-18 16:36:24	c_wraith	[19:58:50] that error looks like it was incorrect literate haskell
2021-07-18 16:36:24	Franciman	[19:59:28] uhm
2021-07-18 16:36:24	Franciman	[20:00:10] geekosaur: how do I call unlit?
2021-07-18 16:36:24	Franciman	[20:00:16] I don't have an unlit program
2021-07-18 16:36:24	geekosaur	[20:00:32] it's in the library directory
2021-07-18 16:36:24	Franciman	[20:01:09] c_wraith: here is my code: https://bpa.st/A7JA
2021-07-18 16:36:24	geekosaur	[20:01:11] ghc --print-libdir
2021-07-18 16:36:24	geekosaur	[20:01:29] then unlit < yoursourcefile
2021-07-18 16:36:24	geekosaur	[20:01:48] with the fukll path to the unlit binary in the libdir
2021-07-18 16:36:24	Franciman	[20:02:36] geekosaur: sorry to bother again
2021-07-18 16:36:24	Franciman	[20:02:38] but I get
2021-07-18 16:36:24	Franciman	[20:02:43] usage: unlit [-q] [-n] [-c] [-#] [-P] [-h label] file1 file2
2021-07-18 16:36:24	Franciman	[20:02:47] and there is no help :D
2021-07-18 16:36:24	Franciman	[20:02:59] oh I am stupid
2021-07-18 16:36:24	Franciman	[20:03:01] sorry
2021-07-18 16:36:24	c_wraith	[20:03:03] I don't know if you can mix bird tracks and tex-style literate haskell in one file
2021-07-18 16:36:24	Franciman	[20:03:10] no ok, same problem
2021-07-18 16:36:24	Franciman	[20:03:31] c_wraith: uhm let me see
2021-07-18 16:36:24	geekosaur	[20:04:24] I don't think you can
2021-07-18 16:36:24	Franciman	[20:04:31] and in fact!
2021-07-18 16:36:24	Franciman	[20:04:35] thank you all
2021-07-18 16:36:24	Franciman	[20:05:10] only sad thing is that I can't use the # for markdown titles
2021-07-18 16:36:24	geekosaur	[20:05:26] unlit could use more documentation but I think it's largely fallen out of use
2021-07-18 16:36:24	Franciman	[20:05:38] nobody likes literate haskell?
2021-07-18 16:36:24	oso	[20:05:53] you could use the === underline in place of the # for header
2021-07-18 16:36:24	Franciman	[20:05:56] I mean, I understand, it does not even sync with haddock
2021-07-18 16:36:24	c_wraith	[20:06:01] in very broad terms, nobody likes literate programming
2021-07-18 16:36:24	Franciman	[20:06:08] yup, thanks oso 
2021-07-18 16:36:24	maerwald	[20:08:19] Franciman: no, it's not even bidirectional
2021-07-18 16:36:24	maerwald	[20:08:37] there's a project that fixes that
2021-07-18 16:36:24	maerwald	[20:08:43] but even then, not sure
2021-07-18 16:36:24	maerwald	[20:09:09] https://blog.esciencecenter.nl/entangled-1744448f4b9f
2021-07-18 16:36:24	maerwald	[20:09:25] https://github.com/entangled/entangled
2021-07-18 16:36:24	Franciman	[20:09:30] entangled is cool, I use it at my job
2021-07-18 16:36:24	Franciman	[20:09:36] it has some sore points
2021-07-18 16:36:24	Franciman	[20:09:39] and a lit of bugs
2021-07-18 16:36:24	Franciman	[20:09:50] lot* lol
2021-07-18 16:36:24	maerwald	[20:09:52] that's why it's LITerate
2021-07-18 16:36:24	maerwald	[20:09:54] lol
2021-07-18 16:36:24	Franciman	[20:09:57] LOL
2021-07-18 16:36:24	Franciman	[20:10:07] but it does not integrate well with ghc etc
2021-07-18 16:36:24	dsal	[20:16:13] Franciman: the last time I wrote literate Haskell, it was in markdown.  It's not bad.
2021-07-18 16:36:24	Franciman	[20:18:01] it is cool yeah
2021-07-18 16:36:24	Franciman	[20:18:25] only thing is, as it seems, it does not mix well with haddock
2021-07-18 16:36:24	Franciman	[20:18:32] you still have to add haddock special comments
2021-07-18 16:36:24	dsal	[20:21:13] Yeah, haddock is lacking in a few ways. I also want TH to work with it.
2021-07-18 16:36:24	dmj`	[20:22:54] an alternative haddock could be nice, could call it koi pond
2021-07-18 16:36:24	geekosaur	[20:24:15] there was at some point a discussion on cafe about incompatibilities between haddock markup and markdown that would make supporting both difficult
2021-07-18 16:36:24	monochrom	[20:35:56] It is sad that we now have to add "bi-directional" to refer to actual literate programming.
2021-07-18 16:36:24	monochrom	[20:36:33] Candidly, lhs is merely a nicer syntax for vanilla comments.
2021-07-18 16:36:24	monochrom	[20:38:15] Literate programming needed to be invented as a thing distinct from mere comments because the biggest part is to present your code in an order the computer doesn't expect. If a system can't do this, it is not literate programming.
2021-07-18 16:36:24	dmj`	[20:52:14] It would be really nice if Haskell abided by industry standards instead of custom stuff, like use toml, markdown, LLVM instead of cabal files, haddock syntax, Cmm 
2021-07-18 16:36:24	geekosaur	[20:55:29] llvm's not gonna happen unless you want to try to upstream a bunch of stuff so ghc can inform llvm of cps-ed stuff
2021-07-18 16:36:24	geekosaur	[20:56:01] and then arrange for ghc to be able to do so, but nobody's going to do that until there's somewhere for it to go
2021-07-18 16:36:24	Rembane	[20:57:04] Sounds like a moment 22
2021-07-18 16:36:24	geekosaur	[20:57:45] no, they know what needs to change and how, but it would require a bunch of llvm changes that are more or less ghc-specific
2021-07-18 16:36:24	geekosaur	[20:57:54] so they're unlikely to ever happen
2021-07-18 16:36:24	Rembane	[20:58:33] Got it! Then I misread, thank you for the clarification.
2021-07-18 16:36:24	noctux	[20:58:48] dmj`: industry standards? do you mean XML, more XML and visual-C? :P
2021-07-18 16:36:24	dmj`	[20:59:16] noctux: yes, XML over SOAP.
2021-07-18 16:36:24	maerwald	[20:59:30] dmj`: afair someone was actually working on providing a toml interface to cabal?
2021-07-18 16:36:24	maerwald	[20:59:41] or maybe I just imagined that
2021-07-18 16:36:24	dmj`	[21:00:33] geekosaur: what are your thoughts on GRIN as a backend for GHC
2021-07-18 16:36:24	geekosaur	[21:05:18] looks to me like it really wants to be a whole-program compiler? which ghc kinda doesn't
2021-07-18 16:36:24	geekosaur	[21:05:42] (and yet kinda does since it "fakes it" via exporting cidode in .hi files)
2021-07-18 16:36:24	geekosaur	[21:05:55] *code
2021-07-18 16:36:24	geekosaur	[21:07:27] still, makes me wonder how well grin would work if used thye way ghc would use it instead of whole-program
2021-07-18 16:36:24	geekosaur	[21:09:43] would really need to write out IR files instead of object files and let the backend take it from there, but I'm not sure how well ghc would work with that setup given it doesn't e.g. do that with llvm IR
2021-07-18 16:36:24	geekosaur	[21:11:06] and you couldn't mix grin backend objects with non-grin backend, like you currently can with llvm vs. asm
2021-07-18 16:36:24	geekosaur	[21:13:22] I think ghc would have to treat grin not as a backend but as a "way" (e.g. static vs. dynamic, or profiled vs. non-profiled)
2021-07-18 16:36:24	monochrom	[21:13:37] cabal was invented long before "industry standard" existed.
2021-07-18 16:36:24	monochrom	[21:14:02] Apart from XML.
2021-07-18 16:36:24	Rembane	[21:14:22] I wonder why industry didn't go with cabal's format. 
2021-07-18 16:36:24	monochrom	[21:15:23] And JVM bytecode.
2021-07-18 16:36:24	geekosaur	[21:15:50] because it's only friendly to haskell, since haskell is friendly to parsers?
2021-07-18 16:36:24	dmj`	[21:16:18] ghc-grin forks ghc it seems, exports *all* of the STG somewhere, does the analysis, brings it back and continues on in the pipeline, to great effect. Suppose we went the nuclear option and replaced STG with GRIN. GRIN would inline the eval function (which is currently hardcoded in the RTS), then perform the WPO, then emit LLVM. 
2021-07-18 16:36:24	geekosaur	[21:16:19] and the syntax is at least reminiscent of haskell
2021-07-18 16:36:24	dmj`	[21:16:34] We could even compile the RTS to GRIN and include it in the optimization phases, which would have the effect of dead code eliminating parts of the RTS that were unused, like GC for example. 
2021-07-18 16:36:24	geekosaur	[21:16:52] interesting
2021-07-18 16:36:24	dmj`	[21:20:33] benefits from WPO are so large even naive pointer analysis (steensgaard) is an enormous win, would still need a fast interpreter though
2021-07-18 16:36:24	dmj`	[21:21:12] thomas johnson created STG, then his final work was GRIN, but it never saw prominence in GHC, I wonder why that is
2021-07-18 16:36:24	geekosaur	[21:23:53] probably because ghc's architecture makes intervening at the stg layer more difficult than it should be
2021-07-18 16:36:24	dmj`	[21:30:54] exactly, too much code at that point
2021-07-18 16:36:24	dmj`	[21:35:03] realizing that GRIN's eval inlining is the first step in undoing the overhead of lazy evaluation (while preserving semantics) was pretty mind-blowing
2021-07-18 16:36:24	danso	[23:02:36] is there a typeclass that generalizes fromMaybe and fromRight? 
2021-07-18 16:36:24	danso	[23:02:53] it seems closely related to Alternative, like <|> 
2021-07-18 16:36:24	danso	[23:03:29] but (<|>) :: f a -> f a -> f a
2021-07-18 16:36:24	hpc	[23:03:31] :t traverse
2021-07-18 16:36:24	lambdabot	[23:03:32] (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
2021-07-18 16:36:24	danso	[23:03:41] i'm looking for f a -> f a -> a 
2021-07-18 16:36:24	geekosaur	[23:04:44] danso, what should such a typeclass do if it would fail?
2021-07-18 16:36:24	hpc	[23:04:55] maybe you want Foldable? https://hackage.haskell.org/package/base-4.15.0.0/docs/Prelude.html#t:Foldable
2021-07-18 16:36:24	danso	[23:05:10] oh you're right geekosaur 
2021-07-18 16:36:24	danso	[23:05:18] i made a mistake; i want f a -> a -> a 
2021-07-18 16:36:24	hpc	[23:05:36] % sum (Just 5)
2021-07-18 16:36:24	yahb	[23:05:36] hpc: 5
2021-07-18 16:36:24	hpc	[23:05:40] % sum Nothing
2021-07-18 16:36:24	yahb	[23:05:41] hpc: 0
2021-07-18 16:36:24	hpc	[23:05:52] % :t sum
2021-07-18 16:36:24	yahb	[23:05:53] hpc: (Foldable t, Num a) => t a -> a
2021-07-18 16:36:24	danso	[23:06:26] something like foldr (const id) is close maybe
2021-07-18 16:36:24	hpc	[23:07:03] :t foldMap
2021-07-18 16:36:24	lambdabot	[23:07:04] (Foldable t, Monoid m) => (a -> m) -> t a -> m
2021-07-18 16:36:24	danso	[23:07:54] wow, TIL Maybe is Foldable 
2021-07-18 16:36:24	hpc	[23:09:37] speaking of, TIL Complex is Foldable
2021-07-18 16:36:24	hpc	[23:09:59] % sum (5 :+ 10)
2021-07-18 16:36:24	yahb	[23:09:59] hpc: 15
2021-07-18 16:36:24	hpc	[23:10:15] and it... just combines the numbers
2021-07-18 16:36:24	hpc	[23:10:19] i don't know what i was expecting
2021-07-18 16:36:24	geekosaur	[23:14:30] o.O
2021-07-18 16:36:24	xsperry	[23:21:57] that's.. interesting
2021-07-18 16:36:24	monochrom	[23:35:07] That's the natural answer to someone who expects length (x,y) = 2.  Use length (x :+ y) instead.  >:)
2021-07-18 16:36:24	geekosaur	[23:36:48] > length (1,2) -- "natural"
2021-07-18 16:36:24	lambdabot	[23:36:49]  1
2021-07-18 16:36:24	 *	geekosaur [23:37:13] originally typoed "notural"
2021-07-18 16:36:24	monochrom	[23:39:17] And haha someone was ahead of me, Complex is a Monad too.
2021-07-18 16:36:24	boxscape	[23:56:13] % :i Complex
2021-07-18 16:36:24	yahb	[23:56:13] boxscape: type Complex :: * -> *; data Complex a = !a :+ !a; -- Defined in `Data.Complex'; instance Applicative Complex -- Defined in `Data.Complex'; instance Eq a => Eq (Complex a) -- Defined in `Data.Complex'; instance Functor Complex -- Defined in `Data.Complex'; instance Monad Complex -- Defined in `Data.Complex'; instance RealFloat a => Floating (Complex a) -- Defined in `Data.Complex'; instance RealFloat a
2021-07-18 16:36:24	boxscape	[23:56:51] so Complex is really just `Pair`, with all the behavior you would expect (and then some, for the number stuff)
2021-07-18 16:36:24	geekosaur	[23:57:31] so if you ever need that value with a type that's both Num and Monad…
2021-07-18 16:36:24	boxscape	[23:58:19] % (1 :+ 2) >>= (\x -> x :+ x)
2021-07-18 16:36:24	yahb	[23:58:20] boxscape: 1 :+ 2
2021-07-18 16:36:24	monochrom	[23:59:22] :)
2021-07-18 16:36:24	davean	[01:48:09] I find most mathematical objects I deal with in practice to be "some set construction, with laws"
2021-07-18 16:36:24	guest61	[03:42:50] about IO socket, if peer closed the connection, will get -1, what about they just went off the network without sent disconnect signal, how to handle that?
2021-07-18 16:36:24	geekosaur	[03:44:04] you get an exception which you must catch
2021-07-18 16:36:24	geekosaur	[03:44:33] see the Control.Exception module
2021-07-18 16:36:24	guest61	[03:44:37] how we handle that without exception?
2021-07-18 16:36:24	guest61	[03:45:04] what about C langauage, it doesnt have exception, how it handle that?
2021-07-18 16:36:24	guest61	[03:45:24] Either cant handle this IO exception?
2021-07-18 16:36:24	geekosaur	[03:45:39] C returns -1 with an error code, vs. 0; it doesn;t have exceptions
2021-07-18 16:36:24	c_wraith	[03:45:41] in C, you look at return values and check ERRNO and hope nothing concurrent changed it
2021-07-18 16:36:24	geekosaur	[03:45:49] Either can;t handle this kind of exception
2021-07-18 16:36:24	lars8	[03:48:27] guest61, article makes a good argument why exceptions are prefered in IO over Either.  https://www.fpcomplete.com/blog/2016/11/exceptions-best-practices-haskell/
2021-07-18 16:36:24	guest61	[03:48:29] if there're multiple IO at the same time, one of them just did this, check ERRNO will work?
2021-07-18 16:36:24	lars8	[03:48:32] +this
2021-07-18 16:36:24	nitrix	[03:48:45] c_wraith, errno is thread-local for POSIX systems.
2021-07-18 16:36:24	guest61	[03:49:28] I thought that try-catch is typical OOP stuff
2021-07-18 16:36:24	geekosaur	[03:49:46] try-catch is not particularly OOP
2021-07-18 16:36:24	guest61	[03:49:49] FP has try-catch is weird
2021-07-18 16:36:24	nitrix	[03:50:21] For Haskell, Either/Maybe is a good way to do error-handling, then you also have nicer monad (transformers) like EitherT to do your exceptions.
2021-07-18 16:36:24	lars8	[03:50:54] but then you force callers to handle errors in two ways, via either, and exceptions
2021-07-18 16:36:24	guest61	[03:50:57] yes, but there're exception and run-time exception
2021-07-18 16:36:24	guest61	[03:51:13] Either cant handle run-time exception
2021-07-18 16:36:24	guest61	[03:55:35] how other languages without try-catch to handle run-time exceptions?
2021-07-18 16:36:24	xsperry	[03:57:10] probably more of a #programming question
2021-07-18 16:36:24	lars8	[04:21:43] guest61, Either can handle runtime errors, just return Left instead of throwing an exception. but, any IO code can throw exceptions other than the one you considered throwing, but are not returning (async exceptions, out of memory exceptions, etc), and encoding every possible exception in the type would be pretty tedious. java tried something similar with checked exceptions, and they are nearly universally hated
2021-07-18 16:36:24	lars8	[04:21:54] s/not/now
2021-07-18 16:36:24	c_wraith	[04:28:14] in some sense, Either is the same as checked exceptions.  Except that the tools for working with them are a lot more pleasant
2021-07-18 16:36:24	monochrom	[04:50:17] try-catch traces all the way back to a David Parnas 1970s paper. Way before OO.
2021-07-18 16:36:24	monochrom	[04:50:41] OO only added "the Exception type can have user-defined subtypes"
2021-07-18 16:36:24	monochrom	[04:51:21] SML also has had exceptions for a long time.
2021-07-18 16:36:24	monochrom	[04:51:31] and SML's predecessors
2021-07-18 16:36:24	monochrom	[04:55:12] Theorem provers written in *ML used this heavily for backtracking proof search. So it was not just I/O even.
2021-07-18 16:36:24	monochrom	[04:56:53] To be sure, in that use case, we now know that it should be Either/Maybe and MonadPlus. But writing theorem provers in *ML was a long long time ago.
2021-07-18 16:36:24	c_wraith	[05:00:22] and if you worry about performance of constructing/matching all those data types,  you might CPS-transform the Either, at which point...  you're basically back at exceptions anyway.  Except without an extra language construct.
2021-07-18 16:36:24	guest61	[07:05:52] update message is Nothing
2021-07-18 16:36:24	guest61	[07:05:53] update message is Nothing
2021-07-18 16:36:24	smtnet3	[08:17:16] yoyo
2021-07-18 16:36:24	***	Playback Complete.
2021-07-18 16:36:31	--	Channel created on Sun, 25 Apr 2021 01:04:39
2021-07-18 16:37:44	-->	Pickchea (~private@user/pickchea) has joined #haskell
2021-07-18 16:38:00	<--	mikoto-chan (~mikoto-ch@ip-213-49-189-31.dsl.scarlet.be) has quit (Ping timeout: 268 seconds)
2021-07-18 16:39:08	-->	mikoto-chan (~mikoto-ch@ip-213-49-189-31.dsl.scarlet.be) has joined #haskell
2021-07-18 16:39:11	-->	ghais (uid508683@id-508683.tinside.irccloud.com) has joined #haskell
2021-07-18 16:39:53	-->	eggplantade (~Eggplanta@108-201-191-115.lightspeed.sntcca.sbcglobal.net) has joined #haskell
2021-07-18 16:44:12	-->	hseg (~gesh@185.120.126.10) has joined #haskell
2021-07-18 16:44:14	-->	jippiedoe (~david@2a02-a44c-e14e-1-8d88-9bbd-c50a-c552.fixed6.kpn.net) has joined #haskell
2021-07-18 16:44:47	<--	eggplantade (~Eggplanta@108-201-191-115.lightspeed.sntcca.sbcglobal.net) has quit (Ping timeout: 268 seconds)
2021-07-18 16:45:41	-->	smichel17 (~smichel17@c-73-68-217-18.hsd1.ma.comcast.net) has joined #haskell
2021-07-18 16:46:26	--	ghais is now known as Ghais
2021-07-18 16:49:58	hseg	has this idea been offered to solve the orphan instance problem: extend overlapping rules so that non-orphan instances are considered more specific than orphan instances
2021-07-18 16:50:41	hseg	at first blush, it would seem to provide a mechanism for adoptable orphans -- just mark your instance OVERLAPPABLE, and petition upstream to pull it in
2021-07-18 16:50:55	--	Ghais is now known as _0x47
2021-07-18 16:52:16	<--	Guest9 (~Guest9@103.250.137.212) has quit (Quit: Connection closed)
2021-07-18 16:52:44	hseg	you'd just want to extract the orphans from your package so you don't have multiple orphans first
2021-07-18 16:55:42	<--	albet70 (~xxx@2400:8902::f03c:92ff:fe60:98d8) has quit (Remote host closed the connection)
2021-07-18 16:56:48	-->	albet70 (~xxx@2400:8902::f03c:92ff:fe60:98d8) has joined #haskell
2021-07-18 16:57:48	<--	hseg (~gesh@185.120.126.10) has quit (Quit: WeeChat 3.2)
2021-07-18 16:59:30	-->	hseg (~gesh@185.120.126.10) has joined #haskell
2021-07-18 17:00:18	-->	merijn (~merijn@83-160-49-249.ip.xs4all.nl) has joined #haskell
2021-07-18 17:10:30	<--	Codaraxis (~Codaraxis@user/codaraxis) has quit (Remote host closed the connection)
2021-07-18 17:10:53	-->	Codaraxis (~Codaraxis@user/codaraxis) has joined #haskell
2021-07-18 17:10:55	<--	ph88 (~ph88@2a02:8109:9e00:7e5c:f938:d06a:9ad7:b39c) has quit (Ping timeout: 246 seconds)
2021-07-18 17:14:11	<--	burnsidesLlama (~burnsides@dhcp168-011.wadham.ox.ac.uk) has quit (Remote host closed the connection)
2021-07-18 17:15:45	<--	jippiedoe (~david@2a02-a44c-e14e-1-8d88-9bbd-c50a-c552.fixed6.kpn.net) has quit (Ping timeout: 255 seconds)
2021-07-18 17:26:25	-->	drd (~drd@93-39-151-19.ip76.fastwebnet.it) has joined #haskell
2021-07-18 17:29:19	<--	ishutin_ (~ishutin@85-238-93-30.pool.digikabel.hu) has quit (Remote host closed the connection)
2021-07-18 17:34:01	-->	pesada (~agua@2804:18:44:17a3:1:0:2cdf:1514) has joined #haskell
2021-07-18 17:34:43	<--	merijn (~merijn@83-160-49-249.ip.xs4all.nl) has quit (Ping timeout: 265 seconds)
2021-07-18 17:35:48	<--	hexfive (~eric@50.35.83.177) has quit (Quit: WeeChat 3.0)
2021-07-18 17:36:49	<--	agua (~agua@2804:14c:8793:8e2f:642c:be4c:c775:de87) has quit (Ping timeout: 246 seconds)
2021-07-18 17:38:15	<--	xff0x_ (~xff0x@2001:1a81:525b:ea00:61de:d55d:7965:91a3) has quit (Ping timeout: 255 seconds)
2021-07-18 17:38:33	-->	xff0x_ (~xff0x@185.65.135.235) has joined #haskell
2021-07-18 17:39:04	hseg	no takers? to recall my question was whether considering non-orphan instances more specific than orphans for overlap resolution was ever considered as a solution for the orphan instance problem
2021-07-18 17:44:53	-->	soft-warm (~soft-warm@2600:8801:db01:8f0:b50e:8cc8:c702:8b1f) has joined #haskell
2021-07-18 17:48:42	-->	fendor_ (~fendor@178.165.167.65.wireless.dyn.drei.com) has joined #haskell
2021-07-18 17:51:02	-->	fendor__ (~fendor@212095005147.public.telering.at) has joined #haskell
2021-07-18 17:51:07	-->	turlando_ (~turlando@93-42-250-112.ip89.fastwebnet.it) has joined #haskell
2021-07-18 17:51:24	<--	turlando (~turlando@user/turlando) has quit (Remote host closed the connection)
2021-07-18 17:51:24	<--	fendor (~fendor@178.165.167.65.wireless.dyn.drei.com) has quit (Read error: Connection reset by peer)
2021-07-18 17:52:58	-->	fendor (~fendor@178.165.167.65.wireless.dyn.drei.com) has joined #haskell
2021-07-18 17:53:16	<--	fendor_ (~fendor@178.165.167.65.wireless.dyn.drei.com) has quit (Ping timeout: 246 seconds)
2021-07-18 17:53:19	<--	fendor (~fendor@178.165.167.65.wireless.dyn.drei.com) has quit (Read error: Connection reset by peer)
2021-07-18 17:53:46	-->	fendor (~fendor@178.165.167.65.wireless.dyn.drei.com) has joined #haskell
2021-07-18 17:55:01	<--	soft-warm (~soft-warm@2600:8801:db01:8f0:b50e:8cc8:c702:8b1f) has quit (Ping timeout: 246 seconds)
2021-07-18 17:56:46	<--	xff0x_ (~xff0x@185.65.135.235) has quit (Ping timeout: 252 seconds)
2021-07-18 17:58:46	-->	xff0x_ (~xff0x@2001:1a81:525b:ea00:8ac3:8abd:f864:c680) has joined #haskell
2021-07-18 18:00:14	--	fendor__ is now known as fendor_
2021-07-18 18:02:06	<--	jmorris (uid433911@id-433911.stonehaven.irccloud.com) has quit (Quit: Connection closed for inactivity)
2021-07-18 18:03:41	-->	lavaman (~lavaman@98.38.249.169) has joined #haskell
2021-07-18 18:07:04	-->	awth13 (~user@user/awth13) has joined #haskell
2021-07-18 18:07:34	-->	ph88 (~ph88@2a02:8109:9e00:7e5c:f938:d06a:9ad7:b39c) has joined #haskell
2021-07-18 18:08:33	<--	lavaman (~lavaman@98.38.249.169) has quit (Ping timeout: 265 seconds)
2021-07-18 18:08:35	<--	adanwan (~adanwan@gateway/tor-sasl/adanwan) has quit (Remote host closed the connection)
2021-07-18 18:08:50	-->	adanwan (~adanwan@gateway/tor-sasl/adanwan) has joined #haskell
2021-07-18 18:11:06	<--	Pickchea (~private@user/pickchea) has quit (Ping timeout: 255 seconds)
2021-07-18 18:16:44	guest61	update message is Nothing
2021-07-18 18:18:23	[exa]	no update, good update
2021-07-18 18:18:31	<--	Feuermagier (~Feuermagi@user/feuermagier) has quit (Ping timeout: 268 seconds)
2021-07-18 18:20:07	-->	burnsidesLlama (~burnsides@dhcp168-011.wadham.ox.ac.uk) has joined #haskell
2021-07-18 18:22:27	tom__	Are stochastic processes better modelled as comonads or monads?
2021-07-18 18:23:07	-->	jao (~jao@cpc103048-sgyl39-2-0-cust502.18-2.cable.virginm.net) has joined #haskell
2021-07-18 18:23:42	<--	albet70 (~xxx@2400:8902::f03c:92ff:fe60:98d8) has quit (Remote host closed the connection)
2021-07-18 18:24:50	-->	albet70 (~xxx@2400:8902::f03c:92ff:fe60:98d8) has joined #haskell
2021-07-18 18:25:26	[exa]	tom__: depends
2021-07-18 18:25:27	<--	Vajb (~Vajb@hag-jnsbng11-58c3a1-224.dhcp.inet.fi) has quit (Read error: Connection reset by peer)
2021-07-18 18:25:30	<--	burnsidesLlama (~burnsides@dhcp168-011.wadham.ox.ac.uk) has quit (Ping timeout: 255 seconds)
2021-07-18 18:25:45	[exa]	tom__: comonads are great for representing a "cache" of stuff, may be interesting for e.g. precomputed distributions
2021-07-18 18:26:28	[exa]	tom__: monads are great for representing the "actual background context" that you only somehow manipulate using (say) an EDSL
2021-07-18 18:26:33	tom__	Its for brownian motion/wiener process
2021-07-18 18:26:39	-->	Vajb (~Vajb@hag-jnsbng11-58c3a1-224.dhcp.inet.fi) has joined #haskell
2021-07-18 18:27:01	<--	Raito_Bezarius (~Raito@wireguard/tunneler/raito-bezarius) has quit (Quit: free())
2021-07-18 18:27:02	-->	lbseale (~lbseale@user/ep1ctetus) has joined #haskell
2021-07-18 18:27:11	[exa]	so you have a state of X particles moving around and hitting each other?
2021-07-18 18:27:34	tom__	Well, modelling a stock price 
2021-07-18 18:27:49	-->	Raito_Bezarius (~Raito@wireguard/tunneler/raito-bezarius) has joined #haskell
2021-07-18 18:27:52	tom__	So just a time series
2021-07-18 18:28:13	-->	burnsidesLlama (~burnsides@dhcp168-011.wadham.ox.ac.uk) has joined #haskell
2021-07-18 18:28:35	[exa]	ok so there's some "actual state", and some "history" that you may as well forget, right?
2021-07-18 18:29:23	tom__	Yeah since its a martingale the process computes the next step from the last step only
2021-07-18 18:29:58	tom__	but the last step has some extra state which is the delta of the brownian motion itself which  obviously has a random component
2021-07-18 18:30:33	tom__	Forgetting history when computing the next step feels comonadic to me
2021-07-18 18:35:29	<--	mikoto-chan (~mikoto-ch@ip-213-49-189-31.dsl.scarlet.be) has quit (Quit: mikoto-chan)
2021-07-18 18:35:43	[exa]	yeah that would work
2021-07-18 18:35:44	-->	mikoto-chan (~mikoto-ch@ip-213-49-189-31.dsl.scarlet.be) has joined #haskell
2021-07-18 18:36:01	[exa]	otoh it might be much simpler because you really don't need to reach for the history there
2021-07-18 18:41:25	-->	burnside_ (~burnsides@dhcp168-011.wadham.ox.ac.uk) has joined #haskell
2021-07-18 18:41:25	<--	burnsidesLlama (~burnsides@dhcp168-011.wadham.ox.ac.uk) has quit (Read error: Connection reset by peer)
2021-07-18 18:43:52	-->	fendor__ (~fendor@178.165.167.65.wireless.dyn.drei.com) has joined #haskell
2021-07-18 18:45:57	-->	mthvedt (uid501949@id-501949.stonehaven.irccloud.com) has joined #haskell
2021-07-18 18:45:59	<--	burnside_ (~burnsides@dhcp168-011.wadham.ox.ac.uk) has quit (Read error: Connection reset by peer)
2021-07-18 18:46:05	tom__	awesome thanks!
2021-07-18 18:46:06	-->	burnsidesLlama (~burnsides@dhcp168-011.wadham.ox.ac.uk) has joined #haskell
2021-07-18 18:47:00	<--	fendor_ (~fendor@212095005147.public.telering.at) has quit (Ping timeout: 252 seconds)
2021-07-18 18:47:00	guest61	update message is Nothing
2021-07-18 18:50:52	-->	raehik (~raehik@cpc95906-rdng25-2-0-cust156.15-3.cable.virginm.net) has joined #haskell
2021-07-18 18:52:44	<--	chexum (~chexum@gateway/tor-sasl/chexum) has quit (Quit: -)
2021-07-18 18:53:38	-->	retroid_ (~retro@97e2ba5d.skybroadband.com) has joined #haskell
2021-07-18 18:56:41	-->	hseg_ (~gesh@185.120.126.10) has joined #haskell
2021-07-18 18:57:28	<--	burnsidesLlama (~burnsides@dhcp168-011.wadham.ox.ac.uk) has quit (Remote host closed the connection)
2021-07-18 18:59:48	<--	hseg (~gesh@185.120.126.10) has quit (Ping timeout: 258 seconds)
2021-07-18 19:00:42	-->	chomwitt (~Pitsikoko@athedsl-32487.home.otenet.gr) has joined #haskell
2021-07-18 19:03:43	<--	albet70 (~xxx@2400:8902::f03c:92ff:fe60:98d8) has quit (Remote host closed the connection)
2021-07-18 19:04:49	-->	albet70 (~xxx@2400:8902::f03c:92ff:fe60:98d8) has joined #haskell
2021-07-18 19:09:00	-->	chexum (~chexum@gateway/tor-sasl/chexum) has joined #haskell
2021-07-18 19:09:01	<--	chexum (~chexum@gateway/tor-sasl/chexum) has quit (Client Quit)
2021-07-18 19:15:30	-->	amahl (~amahl@dsl-jklbng12-54fbca-64.dhcp.inet.fi) has joined #haskell
2021-07-18 19:19:20	Boarders	Is there a convenient way to see every type defined in base?
2021-07-18 19:19:41	-->	haritz (~hrtz@2a02:8010:65b5:0:6009:6384:e3cb:2220) has joined #haskell
2021-07-18 19:19:42	<--	haritz (~hrtz@2a02:8010:65b5:0:6009:6384:e3cb:2220) has quit (Changing host)
2021-07-18 19:19:42	-->	haritz (~hrtz@user/haritz) has joined #haskell
2021-07-18 19:22:29	-->	merijn (~merijn@83-160-49-249.ip.xs4all.nl) has joined #haskell
2021-07-18 19:25:20	<--	anandprabhu (~anandprab@94.202.243.198) has quit (Quit: Leaving)
2021-07-18 19:28:41	--	irc: disconnected from server
2021-07-18 20:21:09	-->	amanr (~therojjha@20.204.87.0) has joined #haskell
2021-07-18 20:21:09	--	Topic for #haskell is "https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org | Paste code/errors: https://paste.tomsmeding.com | tunes.org-style logging should be coming soon | Logs: https://ircbrowse.tomsmeding.com/browse/lchaskell"
2021-07-18 20:21:09	--	Topic set by geekosaur (~geekosaur@xmonad/geekosaur) on Mon, 14 Jun 2021 05:16:14
2021-07-18 20:21:09	--	Channel #haskell: 696 nicks (1 op, 0 voices, 695 normals)
2021-07-18 20:21:09	***	Buffer Playback...
2021-07-18 20:21:09	arkanoid	[10:23:16] the Error monad link is broken https://wiki.haskell.org/Errormonad.html
2021-07-18 20:21:09	kuribas	[10:45:22] How does haskell compare to other functional languages?  Looking a bit at SML and OCaml, it seems that haskell has far more libraries, and is more practical for real world projects (other than compilers etc).
2021-07-18 20:21:09	kuribas	[10:46:31] Of course scala and clojure are also popular, but I don't consider clojure a real functional language, it's more a lisp derivative.  And Scala is mostly multiparadigm, and also complex and overengineerd.
2021-07-18 20:21:09	arahael	[10:47:48] kuribas: I use haskell for most of my private hobby/side projects.  It's awesule, but I've used F# and Swift, which are somewhat OCaml-inspired.
2021-07-18 20:21:09	arahael	[10:48:25] kuribas: The biggest most profound difference with Haskell is that it's *lazy*, and has a really really good type system, but in practice that it's lazy makes a big difference to how you use haskell.
2021-07-18 20:21:09	kuribas	[10:48:54] arahael: how much libraries are there for F#?  Or does it just use the C# ecosystem?
2021-07-18 20:21:09	arahael	[10:49:05] F# is just another .NET language, really, yeah.
2021-07-18 20:21:09	arahael	[10:49:17] As is C#. :)
2021-07-18 20:21:09	kuribas	[10:49:20] doesn't that mean that most libraries aren't really made for FP?
2021-07-18 20:21:09	arahael	[10:50:00] Kinda.  The way F# copes with nulls is interesting. (It assumes there aren't any).
2021-07-18 20:21:09	kuribas	[10:50:41] then how do you test if a function returns null?
2021-07-18 20:21:09	arahael	[10:51:33] kuribas: That's a trap, yeah.  In earlier versions, you'd check for it explicitly, and the compiler lets you. But then, the compiler *elides* that check because it thinks better.
2021-07-18 20:21:09	arahael	[10:51:44] Hopefully they've changed that now.
2021-07-18 20:21:09	arahael	[10:53:33] Looks like they've changed it - suggesting instead to use pattern matching.  Far better: https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/values/null-values
2021-07-18 20:21:09	arahael	[10:53:59] But anyway, one difference is that Haskell is lazy, so your functions must not have side effects.
2021-07-18 20:21:10	arahael	[10:54:30] And since that practice is so strictly encouraged (otherwise you risk loosing your sanity), that has a flow-on effect to all of haskell's libraries, too.
2021-07-18 20:21:10	DigitalKiwi	[10:55:34] haskell is non-strict
2021-07-18 20:21:10	DigitalKiwi	[10:55:52] https://wiki.haskell.org/Lazy_vs._non-strict
2021-07-18 20:21:10	arahael	[10:56:01] Yeah - more accurate - thanks for that.
2021-07-18 20:21:10	DigitalKiwi	[10:56:34] speaking only for myself haskell programmers are lazy ;)
2021-07-18 20:21:10	arahael	[10:58:05] Hmm. :)
2021-07-18 20:21:10	DigitalKiwi	[11:01:36] and obsesssed with bottoms
2021-07-18 20:21:10	 *	DigitalKiwi [11:02:01] drops mic
2021-07-18 20:21:10	Rembane	[11:03:21] I like lazy bottoms and I cannot lie.
2021-07-18 20:21:10	 *	arahael [11:05:07] suddenly realises why bottom is drawn like _|_
2021-07-18 20:21:10	DigitalKiwi	[11:06:04] dibblego twitter avatar lolol
2021-07-18 20:21:10	kuribas	[11:08:21] arahael: so haskell is the only language that doesn't let you get away coding imperative OO in it?
2021-07-18 20:21:10	kuribas	[11:09:07] Although imperative style is still quite possible in haskell.  OO on the other hand is pretty hard.
2021-07-18 20:21:10	dibblego	[11:09:35] DigitalKiwi: that's BUMFISH
2021-07-18 20:21:10	DigitalKiwi	[11:10:01] is that a new operator
2021-07-18 20:21:10	dibblego	[11:11:41] no, it's a pre-landing checklist
2021-07-18 20:21:10	arahael	[11:13:08] Heh.
2021-07-18 20:21:10	arahael	[11:13:36] kuribas: If it's subtyping you're referring to, no, I don't think haskell has that.
2021-07-18 20:21:10	arahael	[11:13:58] kuribas: It does have classes and instances, though, but they behave quite differently.
2021-07-18 20:21:10	kuribas	[11:14:06] And that's a good thing...
2021-07-18 20:21:10	 *	arahael [11:14:25] thinks so.
2021-07-18 20:21:10	DigitalKiwi	[11:14:37] https://www.parsonsmatt.org/2017/02/17/object_oriented_programming_in_haskell.html
2021-07-18 20:21:10	DigitalKiwi	[11:16:43] https://hackage.haskell.org/package/hoop
2021-07-18 20:21:10	DigitalKiwi	[11:16:56] cue bot "haskell can do that!"
2021-07-18 20:21:10	dibblego	[11:22:23] DigitalKiwi: https://flightscope.gitlab.io/aircraft/checklist/eurofox.pdf page 1, top-right
2021-07-18 20:21:10	kuribas	[11:58:55] I've been accused of being a haskell lanuage zealot.  But actually I am interested in other languages (logic, FP, dependently typed, etc...).  It just doesn't seem to be useful to push for other languages that I know less...
2021-07-18 20:21:10	kuribas	[11:59:21] I could recommend F# instead of haskell, but I don't know it that well, so there is less benefit IMO...
2021-07-18 20:21:10	kuribas	[12:04:48] Every time I come with rational arguments, I get a reply like "But I don't like types, they get in the way".  Or "programming languages don't matter, business logic does".  Or "I don't care it's more robust, we want to move fast and solve bugs as we go".
2021-07-18 20:21:10	dibblego	[12:18:06] get used to it
2021-07-18 20:21:10	tom__	[12:18:47] kuribas: I feel your pain
2021-07-18 20:21:10	tom__	[12:19:43] "Types get in the way" then spends three hours NULL chasing
2021-07-18 20:21:10	kuribas	[12:20:50] tom__: exactly!  I spend far more time thinking about types in clojure than in haskell.
2021-07-18 20:21:10	maerwald	[12:21:11] types can get in the way, especially since haskell lacks structural typing
2021-07-18 20:21:10	tom__	[12:21:34] haha sometimes you want types to get in the way
2021-07-18 20:21:10	maerwald	[12:21:51] I know of at least one Haskell dev who now works full-time with typescript and doesn't regret it
2021-07-18 20:21:10	maerwald	[12:22:09] I probably wouldn't, but it's a valid position
2021-07-18 20:21:10	tom__	[12:22:55] Clojure to me is just javascript with some immutability
2021-07-18 20:21:10	kuribas	[12:23:22] maerwald: I find that often, it just amounts to having a bit more boilerplate.  Or having duplicate type definitions.
2021-07-18 20:21:10	maerwald	[12:23:40] it can be a *lot* of boilerplate
2021-07-18 20:21:10	maerwald	[12:24:00] and prohibits you of expressing certain relationships between data
2021-07-18 20:21:10	tom__	[12:24:19] Haskell, Rust and Julia - desert island stack
2021-07-18 20:21:10	tom__	[12:24:37] Havent tried the latter two :D
2021-07-18 20:21:10	maerwald	[12:24:58] class based solutions don't work well when you need an *actual* data type for serialisation
2021-07-18 20:21:10	maerwald	[12:25:45] typescript is surprisingly simple and powerful on these matters... certainly less elegant and unsound in a few places, but that's the tradeoff the make
2021-07-18 20:21:10	kuribas	[12:26:10] tom__: rust is only my "to learn list" :)
2021-07-18 20:21:10	kuribas	[12:26:42] maerwald: you can be less elegant and unsound in haskell too...
2021-07-18 20:21:10	maerwald	[12:27:02] kuribas: yeah, but that usually involves MORE complexity, not less
2021-07-18 20:21:10	maerwald	[12:27:10] so the opposite of typescript
2021-07-18 20:21:10	tom__	[12:27:22] You can be and then people who don't understand what a theoretical model is say that it must mean Haskell is pointless
2021-07-18 20:21:10	kuribas	[12:28:12] maerwald: I don't agree
2021-07-18 20:21:10	maerwald	[12:28:47] well, you *can* do some forms of structural typing/subtyping, but it all ends in esoteric libraries
2021-07-18 20:21:10	kuribas	[12:29:00] maerwald: so don't do it.
2021-07-18 20:21:10	maerwald	[12:29:03] while you get all that in TS for free without complexity
2021-07-18 20:21:10	maerwald	[12:29:45] well, I'm not commenting on which language is better, I'm just commenting on "types can get in the way", because they can
2021-07-18 20:21:10	kuribas	[12:29:55] maerwald: plenty of ways to get around that: 1) partially applied functions (the Endo trick), create a new type with some of the fields.  3) just make the fields all Maybe.
2021-07-18 20:21:10	kuribas	[12:30:56] maerwald: there is a difference between "the types sometimes get in the way", and "the types always get in the way", the latter is what they seem to be implying.
2021-07-18 20:21:10	maerwald	[12:31:02] 1) difficult for serialisation, Show instances, debugging, ... 2) boilerplate, 3) unexpressive, because now you have two cases of `Maybe`
2021-07-18 20:21:10	kuribas	[12:32:02] You don't need two cases of Maybe
2021-07-18 20:21:10	kuribas	[12:32:44] and 4) just put default values.
2021-07-18 20:21:10	maerwald	[12:33:32] 1. there's no such value, because the computation doesn't return one for the given input, 2. there's no such value, because the computation can *never* return one
2021-07-18 20:21:10	maerwald	[12:33:45] now you also have to wonder: 3. there's a value, but there shouldn't be one
2021-07-18 20:21:10	maerwald	[12:33:47] oops
2021-07-18 20:21:10	kuribas	[12:33:47] IMO, the more you want correctness, the more you are restricted in what you write.  It has nothing to do with types (directly).
2021-07-18 20:21:10	kuribas	[12:34:28] maerwald: if you grab to clojure, you don't care anyway...
2021-07-18 20:21:10	maerwald	[12:34:48] default values.. what's my default account balance? :p
2021-07-18 20:21:10	dibblego	[12:34:54] like I said, get used to it
2021-07-18 20:21:10	tom__	[12:35:20] ^ yes and get used to makeNegative = (*) -1
2021-07-18 20:21:10	kuribas	[12:35:49] Which is my point, haskell can be a nice unsafe language to.  Just make a big sum type, and partial functions over it (don't forget to add error messages though...).
2021-07-18 20:21:10	maerwald	[12:36:21] well, with structural typing you don't need to be partial
2021-07-18 20:21:10	int-e	[12:36:25] Or unsafeCoerce everything and program untyped lambda calculus? :)
2021-07-18 20:21:10	arahael	[12:36:48] kuribas: Mind you, Clojure seems to offer alternative methods to allow you to type ocrrect code.  In particular, Clojure seems to have a fantastic runtime repl.
2021-07-18 20:21:10	arahael	[12:37:15] kuribas: Such that you're running the live program and debugging it and replacing functions on the fly.
2021-07-18 20:21:10	int-e	[12:37:26] I like types, they prevent some of the more embarrassing programming errors from being run as code.
2021-07-18 20:21:10	tom__	[12:37:44] Revenge is forcing them to write a web app in the Lean proof assistant fully verified.
2021-07-18 20:21:10	tom__	[12:37:49] It has IO.
2021-07-18 20:21:10	maerwald	[12:38:25] right... clojure: forget a closing  bracket, code still compiles, but doesn't compute prime numbers... instead it compiles to a chess engine
2021-07-18 20:21:10	tom__	[12:38:42] haha
2021-07-18 20:21:10	maerwald	[12:38:45] type safe? Yeah maybe. But.
2021-07-18 20:21:10	kuribas	[12:38:48] arahael: I think you never actually used clojure?
2021-07-18 20:21:10	int-e	[12:39:03] tom__: That's deep in "overdoing it" territory. At least if the specification is anything more elaborate than "something in, something out", and even that may be tricky if you interpret it as a promise to fulfil request in finite time.
2021-07-18 20:21:10	kuribas	[12:39:26] arahael: it's a very mediocre runtime IMO, compared to java.  Error messages are nearly incomprehensible.  Tracing is nice though...
2021-07-18 20:21:10	tom__	[12:39:39] int-e: Yeah pointless torture :)
2021-07-18 20:21:10	maerwald	[12:39:50] the only upside of clojure is interactive development
2021-07-18 20:21:10	tom__	[12:40:08] The haskell compiler feels pretty interactive
2021-07-18 20:21:10	maerwald	[12:40:29] if HLS works, maybe
2021-07-18 20:21:10	arahael	[12:40:37] kuribas: Seemed to be effective enough.
2021-07-18 20:21:10	arahael	[12:40:53] But no, I haven't personally used it.
2021-07-18 20:21:10	maerwald	[12:41:00] but on the other hand: usually not. Compile times are too slow
2021-07-18 20:21:10	kuribas	[12:41:12] arahael: clojurists just have a different idea of "correct code".
2021-07-18 20:21:10	arahael	[12:41:15] I personally quite like ghcid.
2021-07-18 20:21:10	arahael	[12:41:27] kuribas: Indeed, but I think it's the process of discovery that they like.
2021-07-18 20:21:10	arahael	[12:41:57] kuribas: In haskell, we seem to prefer to test functions in isolation. Clojure people seem to prefer to test functions in the live system.
2021-07-18 20:21:10	maerwald	[12:42:00] if you're working on 300+ modules and your Type module has a whitespace change, you're gonna need to restart cabal a few times, because your machine OOMed due to TH
2021-07-18 20:21:10	tom__	[12:42:18] Which library is recommended for sampling probability distributions?
2021-07-18 20:21:10	arahael	[12:42:42] maerwald: The amount of memory Haskell uses is crazy high.  Sadly, I find it way faster than Swift. :/
2021-07-18 20:21:10	kuribas	[12:45:45] arahael: lispers will boast about how easy it is to hot patch live systems.  They don't tell you that it becomes very hard to see who changed what and when.
2021-07-18 20:21:10	kuribas	[12:46:05] arahael: so you'll end up with CI/CD anyway.  
2021-07-18 20:21:10	kuribas	[12:46:34] However a theoretically, a "live" programming environment with integrated version control could be nice.
2021-07-18 20:21:10	kuribas	[12:46:44] I don't know if that ever has been done.
2021-07-18 20:21:10	maerwald	[12:47:32] https://hackage.haskell.org/package/optics-th-0.4/docs/Optics-TH.html#v:makeClassy
2021-07-18 20:21:10	maerwald	[12:47:34] https://hackage.haskell.org/package/optics-th-0.4/docs/Optics-TH.html#v:makeFieldsNoPrefix
2021-07-18 20:21:10	maerwald	[12:47:36] https://hackage.haskell.org/package/generic-optics-2.2.0.0/docs/Data-Generics-Product-Fields.html#t:HasField
2021-07-18 20:21:10	maerwald	[12:47:38] which one of those to pick?
2021-07-18 20:21:10	maerwald	[12:49:00] HasField is kinda cool with those neat type errors
2021-07-18 20:21:10	boxscape	[15:15:35] maerwald: the TH versions say "This method of optics generation should only be used when migrating an existing codebase from the lens library to optics"
2021-07-18 20:21:10	boxscape	[15:15:51] maerwald: this, my final answer is C
2021-07-18 20:21:10	boxscape	[15:15:56] s/this/thus
2021-07-18 20:21:10	maerwald	[15:16:07] HasField?
2021-07-18 20:21:10	boxscape	[15:16:46] yeah.. though I thought there was a version of that which uses OverloadedLabels
2021-07-18 20:21:10	maerwald	[15:17:20] HasField though doesn't allow arbitrary subtyping... it's a simple getter
2021-07-18 20:21:10	maerwald	[15:17:54] with makeClassy style classes you could descend deeper into the structure with the same getter
2021-07-18 20:21:10	boxscape	[15:18:30] maerwald: oh actually the TH version links to https://hackage.haskell.org/package/optics-core-0.4/docs/Optics-Label.html as preferred solution
2021-07-18 20:21:10	boxscape	[15:19:03] that's the OverloadedLabels version I was remembering
2021-07-18 20:21:10	maerwald	[15:22:44] so there you could also define custom LabelOptic instances that descend into a structure?
2021-07-18 20:21:10	boxscape	[15:23:27] that seems plausible but I haven't tried doing it
2021-07-18 20:21:10	maerwald	[15:23:47] I'm leaning towards makeClassy, but I'm not sure
2021-07-18 20:21:10	boxscape	[15:24:25] I like makeClassy, the main reason I would avoid it personally is that the documentation advises against it
2021-07-18 20:21:10	maerwald	[15:25:40] so what does LabelOptic give over HasField?
2021-07-18 20:21:10	texasmynsted	[15:26:17] What is the modern answer to haskell records? Lens?
2021-07-18 20:21:10	maerwald	[15:26:49] only difference I see is labelOptic is `Optic` and HasField is a `Lens`
2021-07-18 20:21:10	boxscape	[15:28:24] hm I'm not sure what the concrete differences are
2021-07-18 20:21:10	boxscape	[15:30:52] texasmynsted: there are a few answers to this: In the next version, OverloadedRecordDot is being introduces, which allows one to write something like `personA.company.name`. (Updates are a bit iffy but will improve over time.) In the meantime, lens is definitely still widely used, though optics is a replacement which aims to have better error messages. There is also some research going into row types, but that's further out.
2021-07-18 20:21:10	boxscape	[15:30:55] s/next version/next version of GHC
2021-07-18 20:21:10	boxscape	[15:32:08] (though regarding row types, the vinyl records package allows something similar today)
2021-07-18 20:21:10	Guest14	[16:03:05] Hello :)
2021-07-18 20:21:10	Guest14	[16:03:40] I am new to Haskell and am working through the Real World Haskell Book
2021-07-18 20:21:10	Guest14	[16:04:27] I have a basic question if anyone would care to listen
2021-07-18 20:21:10	allbery_b	[16:06:02] best to just ask it rather than asking to ask
2021-07-18 20:21:10	davean	[16:06:23] asking to ask is why I wasn't helping
2021-07-18 20:21:10	Guest14	[16:07:44] splitWith _ [] = []
2021-07-18 20:21:10	Guest14	[16:07:45] splitWith a xs = [pre ++ [x]] ++ next
2021-07-18 20:21:10	Guest14	[16:07:45]     where 
2021-07-18 20:21:10	Guest14	[16:07:46]         (pre, x:suf) = span a xs
2021-07-18 20:21:10	Guest14	[16:07:46]         next = splitWith a suf
2021-07-18 20:21:10	Guest14	[16:08:10] I have this program and I run into a problem with x:suf when span a xs is [] becuase there is no head
2021-07-18 20:21:10	int-e	[16:09:34] > let f = splitAt 1 in (f "abc", f "")
2021-07-18 20:21:10	lambdabot	[16:09:36]  (("a","bc"),("",""))
2021-07-18 20:21:10	int-e	[16:11:31] (So maybe use splitAt instead of the x:suf pattern.)
2021-07-18 20:21:10	maerwald	[16:11:39] was there a question yet?
2021-07-18 20:21:10	davean	[16:11:45] No
2021-07-18 20:21:10	Guest14	[16:12:09] Ok I will give that a try thanks
2021-07-18 20:21:10	int-e	[16:12:10] They described a problem, close enough.
2021-07-18 20:21:10	maerwald	[16:12:35] They also described the answer
2021-07-18 20:21:10	maerwald	[16:12:38] "there is no head"
2021-07-18 20:21:10	int-e	[16:12:47] @where paste
2021-07-18 20:21:10	lambdabot	[16:12:47] Help us help you: please paste full code, input and/or output at e.g. https://paste.tomsmeding.com
2021-07-18 20:21:10	int-e	[16:13:04] maerwald: That's the reason, but not a solution for the problem?
2021-07-18 20:21:10	 *	int-e [16:13:06] shrugs
2021-07-18 20:21:10	maerwald	[16:13:10] So my answer is: yes
2021-07-18 20:21:10	int-e	[16:13:28] Well, so sorry for trying to be helpful.
2021-07-18 20:21:10	davean	[16:14:09] int-e: oh do be helpful
2021-07-18 20:21:10	Guest14	[16:15:14] int-e that worked thank you
2021-07-18 20:21:10	texasmynsted	[16:20:42] thank you boxscape 
2021-07-18 20:21:10	texasmynsted	[16:21:29] Sounds like optics or vinyl for now
2021-07-18 20:21:10	sm	[16:31:11] g'day all. Speaking of optics.. you experienced [lens] coders, do you find it good or bad for (a) fields and (b) lenses to be visually disctinct from other kinds of bindings (functions, "variables") ? As in eg _field/lens_, field_/lens__, _field/lensL, .... ?
2021-07-18 20:21:10	sm	[16:32:24] I feel it would be good overall, for avoiding collisions and for human comprehension . But I don't have a lot of lens experience
2021-07-18 20:21:10	maerwald	[16:40:10] can you derive LabelOptic with deriving via for an inner type? 
2021-07-18 20:21:10	oso	[16:42:50] xpost from #haskell-beginners:
2021-07-18 20:21:10	oso	[16:42:52] I'm passing around a type synonym for Int, but in reality the only constraint it needs to  follow is that it's hashable. what constructor do i use for this? my brain says go from `type UID = Int` to `data UID a = Hashable a` but that's very not correct, and google isn't helping much
2021-07-18 20:21:10	oso	[16:43:21] nvm sorry got an answer there
2021-07-18 20:21:10	glguy	[16:54:37] oso, if you just need to know that something is hashable you'd use it like: stuff :: Hashable a => a -> b -> c
2021-07-18 20:21:10	glguy	[16:55:19] If a parameter is the uid parameter you can document that like:  stuff :: Hashable uid => uid {- ^ the UID -} -> etc
2021-07-18 20:21:10	oso	[16:55:35] I was trying to do that while also using types to keep my signatures from becoming unwieldy, but first i'll just worry about getting the code working
2021-07-18 20:21:10	glguy	[16:56:22] the documentation for parameters goes in the haddock comments rather than type synonyms
2021-07-18 20:21:10	oso	[16:56:43] mmk
2021-07-18 20:21:10	dsal	[17:05:40] oso: It's tempting to put constraints in the type definitions, but if you take a look at, for example, `Data.Map.Strict` you'll see the type definition is just `data Map k a`.  You'd think k would always have to be ordered, but that's not the case.  You can create and work on maps that have unorderable keys when you don't do things that require ordering.  e.g.:
2021-07-18 20:21:10	dsal	[17:05:42] > M.elems $ (* 2) <$> M.singleton id 3
2021-07-18 20:21:10	lambdabot	[17:05:43]  [6]
2021-07-18 20:21:10	dsal	[17:07:10] The idea is that you only have to constrain things where they actually need to be constrained.  The Functor instance, e.g., doesn't care about the keys at all, so why should it require they're ordered?
2021-07-18 20:21:10	oso	[17:13:45] got it working \o/
2021-07-18 20:21:10	oso	[17:13:47] thank you
2021-07-18 20:21:10	hololeap	[17:46:09] so, I figured out a way to make a function with an arbitrary number of arguments using type families and type-level lists. but, I have to wonder ... has someone already made this and put it on hackage?
2021-07-18 20:21:10	texasmynsted	[17:47:46] wait, why do you want a function with an arbitrary number of arguments?
2021-07-18 20:21:10	c_wraith	[17:49:03] usually to cover for a lack of other expressiveness
2021-07-18 20:21:10	c_wraith	[17:49:09] printf is a common example
2021-07-18 20:21:10	texasmynsted	[17:49:12] Seems to me ideally a function should have exactly one argument
2021-07-18 20:21:10	c_wraith	[17:49:19] We can't write the type it actually has in Haskell
2021-07-18 20:21:10	c_wraith	[17:49:25] Because it's a dependent type
2021-07-18 20:21:10	c_wraith	[17:49:51] So varargs lets us do it anyway and fail at runtime if the programmer got it wrong
2021-07-18 20:21:10	texasmynsted	[17:50:07] printf solves a problem in a particular way that I think could be solved better, differently 
2021-07-18 20:21:10	c_wraith	[17:50:18] differently?  sure.  Better?  Not really.
2021-07-18 20:21:10	hololeap	[17:50:21] the motivation was because I had a typeclass with a function, and I encountered some outliers that needed extra arguments passed to that function
2021-07-18 20:21:10	texasmynsted	[17:50:47] c_wraith: I am not convinced 
2021-07-18 20:21:10	hololeap	[17:50:48] I'd have to write up a blog post or something to get into all the details
2021-07-18 20:21:10	Rembane	[17:50:57] hololeap: Do it! :D
2021-07-18 20:21:10	texasmynsted	[17:51:08] yes, that would be a good read
2021-07-18 20:21:10	c_wraith	[17:51:15] printf is *really* good at doing exactly what it's intended for.  Compactly specifying output formatted for monospace devices.
2021-07-18 20:21:10	texasmynsted	[17:51:32] like regular expressions?
2021-07-18 20:21:10	c_wraith	[17:51:42] honestly, it's more useful
2021-07-18 20:21:10	c_wraith	[17:52:01] regular expressions have to involve things like capturing group to really be useful, and those complicate APIs tremendously
2021-07-18 20:21:10	c_wraith	[17:52:05] printf has no such problems
2021-07-18 20:21:10	texasmynsted	[17:52:20] Right. I think regular expressions work great but are terrible and the problem is better solved differently 
2021-07-18 20:21:10	EvanR	[17:52:46] compare and contrast serious uses of printf with the expanded version, replicate that across a code base like 50 times and compare xD
2021-07-18 20:21:10	EvanR	[17:53:12] also, printf for debugging
2021-07-18 20:21:10	EvanR	[17:53:25] debugging would be harsher without it
2021-07-18 20:21:10	EvanR	[17:54:27] I'm more interested with this case of some function sometimes needing more arguments
2021-07-18 20:21:10	texasmynsted	[17:56:04] I am still going with functions should have exactly one argument 
2021-07-18 20:21:10	hololeap	[17:56:30] I mean... they do, technically.
2021-07-18 20:21:10	texasmynsted	[17:57:38] yes
2021-07-18 20:21:10	EvanR	[17:58:02] if the difference is between argument type (A,B) and (A,B,C) it's about argument type and not number
2021-07-18 20:21:10	texasmynsted	[17:58:23] Okay now we are getting somewhere
2021-07-18 20:21:10	texasmynsted	[19:06:50] sigh.
2021-07-18 20:21:10	oso	[19:07:39] seconded
2021-07-18 20:21:10	texasmynsted	[19:08:52] +1 oso
2021-07-18 20:21:10	monochrom	[19:32:57] Why so grim?
2021-07-18 20:21:10	boxscape	[19:33:18] hololeap: one of rae's latest videos is also about varargs https://youtu.be/iGSKqcebhfs
2021-07-18 20:21:10	monochrom	[19:33:22] You know "grim" and "grin" are just one curvy stroke apart. :)
2021-07-18 20:21:10	boxscape	[19:33:55] you can't spell slaughter without laughter, you can't spell grim without grin
2021-07-18 20:21:10	monochrom	[19:34:33] hee hee
2021-07-18 20:21:10	oso	[19:35:57] idk why texas is feeling grim but i'm extremely anxious about a work trip and trying to stuff the feelings down by adding documentation to my heretofore undocumented code
2021-07-18 20:21:10	monochrom	[19:36:32] My gripe about printf is I will be writing "%d %d %d %d %d %d %d" and then it's the same issue with (Int,Int,Int,Int,Int,Int). And I'm deliberately demonstrating an miscounting error for starters. But this issue is not about vararg, it's about losing structure.
2021-07-18 20:21:10	maerwald	[19:51:08] can you implement varargs in haskell without ambiguitiy due to partial application?
2021-07-18 20:21:10	maerwald	[19:51:18] (and I'm not talking about the typeclass trick)
2021-07-18 20:21:10	geekosaur	[19:52:19] I think there's a typesafe varargs via TH somewhere on hackage
2021-07-18 20:21:10	geekosaur	[19:52:48] probably relies on the format string being literal, but you have other problems if it's not anyway
2021-07-18 20:21:10	c_wraith	[19:53:46] In the general case, there's true ambiguity.  There's no general way to distinguish between providing all the arguments that will be provided and partially applying the function.
2021-07-18 20:21:10	geekosaur	[19:54:25] ^
2021-07-18 20:21:10	c_wraith	[19:55:20] this is why I described varargs as a workaround, not something worth having for itself :)
2021-07-18 20:21:10	Franciman	[19:56:21] Hi, does cabal support literate haskell?
2021-07-18 20:21:10	c_wraith	[19:56:38] if you put an .lhs extension on the files, it should find and compile them
2021-07-18 20:21:10	Franciman	[19:56:56] I have a project using .lhs files, but I get errors 
2021-07-18 20:21:10	Franciman	[19:56:58] wait 
2021-07-18 20:21:10	Franciman	[19:57:19]     `unlit' failed in phase `Literate pre-processor'. (Exit code: 1)
2021-07-18 20:21:10	c_wraith	[19:57:31] so it's trying!
2021-07-18 20:21:10	Franciman	[19:57:36] it is a module I specified in the other-modules
2021-07-18 20:21:10	Franciman	[19:57:45] so I wrote ListCursor
2021-07-18 20:21:10	Franciman	[19:57:49] instead of ListCursor.lhs
2021-07-18 20:21:10	Franciman	[19:58:08] I am really temped to ignore cabal and automatically go with ghc
2021-07-18 20:21:10	Franciman	[19:58:11] let me see what I can do
2021-07-18 20:21:10	geekosaur	[19:58:35] so it ran unlit, so it correctly found it was literate haskell. yoou could try running unlit manually and see what it choked on
2021-07-18 20:21:10	c_wraith	[19:58:40] that error doesn't look like you left out an extension
2021-07-18 20:21:10	c_wraith	[19:58:50] that error looks like it was incorrect literate haskell
2021-07-18 20:21:10	Franciman	[19:59:28] uhm
2021-07-18 20:21:10	Franciman	[20:00:10] geekosaur: how do I call unlit?
2021-07-18 20:21:10	Franciman	[20:00:16] I don't have an unlit program
2021-07-18 20:21:10	geekosaur	[20:00:32] it's in the library directory
2021-07-18 20:21:10	Franciman	[20:01:09] c_wraith: here is my code: https://bpa.st/A7JA
2021-07-18 20:21:10	geekosaur	[20:01:11] ghc --print-libdir
2021-07-18 20:21:10	geekosaur	[20:01:29] then unlit < yoursourcefile
2021-07-18 20:21:10	geekosaur	[20:01:48] with the fukll path to the unlit binary in the libdir
2021-07-18 20:21:10	Franciman	[20:02:36] geekosaur: sorry to bother again
2021-07-18 20:21:10	Franciman	[20:02:38] but I get
2021-07-18 20:21:10	Franciman	[20:02:43] usage: unlit [-q] [-n] [-c] [-#] [-P] [-h label] file1 file2
2021-07-18 20:21:10	Franciman	[20:02:47] and there is no help :D
2021-07-18 20:21:10	Franciman	[20:02:59] oh I am stupid
2021-07-18 20:21:10	Franciman	[20:03:01] sorry
2021-07-18 20:21:10	c_wraith	[20:03:03] I don't know if you can mix bird tracks and tex-style literate haskell in one file
2021-07-18 20:21:10	Franciman	[20:03:10] no ok, same problem
2021-07-18 20:21:10	Franciman	[20:03:31] c_wraith: uhm let me see
2021-07-18 20:21:10	geekosaur	[20:04:24] I don't think you can
2021-07-18 20:21:10	Franciman	[20:04:31] and in fact!
2021-07-18 20:21:10	Franciman	[20:04:35] thank you all
2021-07-18 20:21:10	Franciman	[20:05:10] only sad thing is that I can't use the # for markdown titles
2021-07-18 20:21:10	geekosaur	[20:05:26] unlit could use more documentation but I think it's largely fallen out of use
2021-07-18 20:21:10	Franciman	[20:05:38] nobody likes literate haskell?
2021-07-18 20:21:10	oso	[20:05:53] you could use the === underline in place of the # for header
2021-07-18 20:21:10	Franciman	[20:05:56] I mean, I understand, it does not even sync with haddock
2021-07-18 20:21:10	c_wraith	[20:06:01] in very broad terms, nobody likes literate programming
2021-07-18 20:21:10	Franciman	[20:06:08] yup, thanks oso 
2021-07-18 20:21:10	maerwald	[20:08:19] Franciman: no, it's not even bidirectional
2021-07-18 20:21:10	maerwald	[20:08:37] there's a project that fixes that
2021-07-18 20:21:10	maerwald	[20:08:43] but even then, not sure
2021-07-18 20:21:10	maerwald	[20:09:09] https://blog.esciencecenter.nl/entangled-1744448f4b9f
2021-07-18 20:21:10	maerwald	[20:09:25] https://github.com/entangled/entangled
2021-07-18 20:21:10	Franciman	[20:09:30] entangled is cool, I use it at my job
2021-07-18 20:21:10	Franciman	[20:09:36] it has some sore points
2021-07-18 20:21:10	Franciman	[20:09:39] and a lit of bugs
2021-07-18 20:21:10	Franciman	[20:09:50] lot* lol
2021-07-18 20:21:10	maerwald	[20:09:52] that's why it's LITerate
2021-07-18 20:21:10	maerwald	[20:09:54] lol
2021-07-18 20:21:10	Franciman	[20:09:57] LOL
2021-07-18 20:21:10	Franciman	[20:10:07] but it does not integrate well with ghc etc
2021-07-18 20:21:10	dsal	[20:16:13] Franciman: the last time I wrote literate Haskell, it was in markdown.  It's not bad.
2021-07-18 20:21:10	Franciman	[20:18:01] it is cool yeah
2021-07-18 20:21:10	Franciman	[20:18:25] only thing is, as it seems, it does not mix well with haddock
2021-07-18 20:21:10	Franciman	[20:18:32] you still have to add haddock special comments
2021-07-18 20:21:10	dsal	[20:21:13] Yeah, haddock is lacking in a few ways. I also want TH to work with it.
2021-07-18 20:21:10	dmj`	[20:22:54] an alternative haddock could be nice, could call it koi pond
2021-07-18 20:21:10	geekosaur	[20:24:15] there was at some point a discussion on cafe about incompatibilities between haddock markup and markdown that would make supporting both difficult
2021-07-18 20:21:10	monochrom	[20:35:56] It is sad that we now have to add "bi-directional" to refer to actual literate programming.
2021-07-18 20:21:10	monochrom	[20:36:33] Candidly, lhs is merely a nicer syntax for vanilla comments.
2021-07-18 20:21:10	monochrom	[20:38:15] Literate programming needed to be invented as a thing distinct from mere comments because the biggest part is to present your code in an order the computer doesn't expect. If a system can't do this, it is not literate programming.
2021-07-18 20:21:10	dmj`	[20:52:14] It would be really nice if Haskell abided by industry standards instead of custom stuff, like use toml, markdown, LLVM instead of cabal files, haddock syntax, Cmm 
2021-07-18 20:21:10	geekosaur	[20:55:29] llvm's not gonna happen unless you want to try to upstream a bunch of stuff so ghc can inform llvm of cps-ed stuff
2021-07-18 20:21:10	geekosaur	[20:56:01] and then arrange for ghc to be able to do so, but nobody's going to do that until there's somewhere for it to go
2021-07-18 20:21:10	Rembane	[20:57:04] Sounds like a moment 22
2021-07-18 20:21:10	geekosaur	[20:57:45] no, they know what needs to change and how, but it would require a bunch of llvm changes that are more or less ghc-specific
2021-07-18 20:21:10	geekosaur	[20:57:54] so they're unlikely to ever happen
2021-07-18 20:21:10	Rembane	[20:58:33] Got it! Then I misread, thank you for the clarification.
2021-07-18 20:21:10	noctux	[20:58:48] dmj`: industry standards? do you mean XML, more XML and visual-C? :P
2021-07-18 20:21:10	dmj`	[20:59:16] noctux: yes, XML over SOAP.
2021-07-18 20:21:10	maerwald	[20:59:30] dmj`: afair someone was actually working on providing a toml interface to cabal?
2021-07-18 20:21:10	maerwald	[20:59:41] or maybe I just imagined that
2021-07-18 20:21:10	dmj`	[21:00:33] geekosaur: what are your thoughts on GRIN as a backend for GHC
2021-07-18 20:21:10	geekosaur	[21:05:18] looks to me like it really wants to be a whole-program compiler? which ghc kinda doesn't
2021-07-18 20:21:10	geekosaur	[21:05:42] (and yet kinda does since it "fakes it" via exporting cidode in .hi files)
2021-07-18 20:21:10	geekosaur	[21:05:55] *code
2021-07-18 20:21:10	geekosaur	[21:07:27] still, makes me wonder how well grin would work if used thye way ghc would use it instead of whole-program
2021-07-18 20:21:10	geekosaur	[21:09:43] would really need to write out IR files instead of object files and let the backend take it from there, but I'm not sure how well ghc would work with that setup given it doesn't e.g. do that with llvm IR
2021-07-18 20:21:10	geekosaur	[21:11:06] and you couldn't mix grin backend objects with non-grin backend, like you currently can with llvm vs. asm
2021-07-18 20:21:10	geekosaur	[21:13:22] I think ghc would have to treat grin not as a backend but as a "way" (e.g. static vs. dynamic, or profiled vs. non-profiled)
2021-07-18 20:21:10	monochrom	[21:13:37] cabal was invented long before "industry standard" existed.
2021-07-18 20:21:10	monochrom	[21:14:02] Apart from XML.
2021-07-18 20:21:10	Rembane	[21:14:22] I wonder why industry didn't go with cabal's format. 
2021-07-18 20:21:10	monochrom	[21:15:23] And JVM bytecode.
2021-07-18 20:21:10	geekosaur	[21:15:50] because it's only friendly to haskell, since haskell is friendly to parsers?
2021-07-18 20:21:10	dmj`	[21:16:18] ghc-grin forks ghc it seems, exports *all* of the STG somewhere, does the analysis, brings it back and continues on in the pipeline, to great effect. Suppose we went the nuclear option and replaced STG with GRIN. GRIN would inline the eval function (which is currently hardcoded in the RTS), then perform the WPO, then emit LLVM. 
2021-07-18 20:21:10	geekosaur	[21:16:19] and the syntax is at least reminiscent of haskell
2021-07-18 20:21:10	dmj`	[21:16:34] We could even compile the RTS to GRIN and include it in the optimization phases, which would have the effect of dead code eliminating parts of the RTS that were unused, like GC for example. 
2021-07-18 20:21:10	geekosaur	[21:16:52] interesting
2021-07-18 20:21:10	dmj`	[21:20:33] benefits from WPO are so large even naive pointer analysis (steensgaard) is an enormous win, would still need a fast interpreter though
2021-07-18 20:21:10	dmj`	[21:21:12] thomas johnson created STG, then his final work was GRIN, but it never saw prominence in GHC, I wonder why that is
2021-07-18 20:21:10	geekosaur	[21:23:53] probably because ghc's architecture makes intervening at the stg layer more difficult than it should be
2021-07-18 20:21:10	dmj`	[21:30:54] exactly, too much code at that point
2021-07-18 20:21:10	dmj`	[21:35:03] realizing that GRIN's eval inlining is the first step in undoing the overhead of lazy evaluation (while preserving semantics) was pretty mind-blowing
2021-07-18 20:21:10	danso	[23:02:36] is there a typeclass that generalizes fromMaybe and fromRight? 
2021-07-18 20:21:10	danso	[23:02:53] it seems closely related to Alternative, like <|> 
2021-07-18 20:21:10	danso	[23:03:29] but (<|>) :: f a -> f a -> f a
2021-07-18 20:21:10	hpc	[23:03:31] :t traverse
2021-07-18 20:21:10	lambdabot	[23:03:32] (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
2021-07-18 20:21:10	danso	[23:03:41] i'm looking for f a -> f a -> a 
2021-07-18 20:21:10	geekosaur	[23:04:44] danso, what should such a typeclass do if it would fail?
2021-07-18 20:21:10	hpc	[23:04:55] maybe you want Foldable? https://hackage.haskell.org/package/base-4.15.0.0/docs/Prelude.html#t:Foldable
2021-07-18 20:21:10	danso	[23:05:10] oh you're right geekosaur 
2021-07-18 20:21:10	danso	[23:05:18] i made a mistake; i want f a -> a -> a 
2021-07-18 20:21:10	hpc	[23:05:36] % sum (Just 5)
2021-07-18 20:21:10	yahb	[23:05:36] hpc: 5
2021-07-18 20:21:10	hpc	[23:05:40] % sum Nothing
2021-07-18 20:21:10	yahb	[23:05:41] hpc: 0
2021-07-18 20:21:10	hpc	[23:05:52] % :t sum
2021-07-18 20:21:10	yahb	[23:05:53] hpc: (Foldable t, Num a) => t a -> a
2021-07-18 20:21:10	danso	[23:06:26] something like foldr (const id) is close maybe
2021-07-18 20:21:10	hpc	[23:07:03] :t foldMap
2021-07-18 20:21:10	lambdabot	[23:07:04] (Foldable t, Monoid m) => (a -> m) -> t a -> m
2021-07-18 20:21:10	danso	[23:07:54] wow, TIL Maybe is Foldable 
2021-07-18 20:21:10	hpc	[23:09:37] speaking of, TIL Complex is Foldable
2021-07-18 20:21:10	hpc	[23:09:59] % sum (5 :+ 10)
2021-07-18 20:21:10	yahb	[23:09:59] hpc: 15
2021-07-18 20:21:10	hpc	[23:10:15] and it... just combines the numbers
2021-07-18 20:21:10	hpc	[23:10:19] i don't know what i was expecting
2021-07-18 20:21:10	geekosaur	[23:14:30] o.O
2021-07-18 20:21:10	xsperry	[23:21:57] that's.. interesting
2021-07-18 20:21:10	monochrom	[23:35:07] That's the natural answer to someone who expects length (x,y) = 2.  Use length (x :+ y) instead.  >:)
2021-07-18 20:21:10	geekosaur	[23:36:48] > length (1,2) -- "natural"
2021-07-18 20:21:10	lambdabot	[23:36:49]  1
2021-07-18 20:21:10	 *	geekosaur [23:37:13] originally typoed "notural"
2021-07-18 20:21:10	monochrom	[23:39:17] And haha someone was ahead of me, Complex is a Monad too.
2021-07-18 20:21:10	boxscape	[23:56:13] % :i Complex
2021-07-18 20:21:10	yahb	[23:56:13] boxscape: type Complex :: * -> *; data Complex a = !a :+ !a; -- Defined in `Data.Complex'; instance Applicative Complex -- Defined in `Data.Complex'; instance Eq a => Eq (Complex a) -- Defined in `Data.Complex'; instance Functor Complex -- Defined in `Data.Complex'; instance Monad Complex -- Defined in `Data.Complex'; instance RealFloat a => Floating (Complex a) -- Defined in `Data.Complex'; instance RealFloat a
2021-07-18 20:21:10	boxscape	[23:56:51] so Complex is really just `Pair`, with all the behavior you would expect (and then some, for the number stuff)
2021-07-18 20:21:10	geekosaur	[23:57:31] so if you ever need that value with a type that's both Num and Monad…
2021-07-18 20:21:10	boxscape	[23:58:19] % (1 :+ 2) >>= (\x -> x :+ x)
2021-07-18 20:21:10	yahb	[23:58:20] boxscape: 1 :+ 2
2021-07-18 20:21:10	monochrom	[23:59:22] :)
2021-07-18 20:21:10	davean	[01:48:09] I find most mathematical objects I deal with in practice to be "some set construction, with laws"
2021-07-18 20:21:10	guest61	[03:42:50] about IO socket, if peer closed the connection, will get -1, what about they just went off the network without sent disconnect signal, how to handle that?
2021-07-18 20:21:10	geekosaur	[03:44:04] you get an exception which you must catch
2021-07-18 20:21:10	geekosaur	[03:44:33] see the Control.Exception module
2021-07-18 20:21:10	guest61	[03:44:37] how we handle that without exception?
2021-07-18 20:21:10	guest61	[03:45:04] what about C langauage, it doesnt have exception, how it handle that?
2021-07-18 20:21:10	guest61	[03:45:24] Either cant handle this IO exception?
2021-07-18 20:21:10	geekosaur	[03:45:39] C returns -1 with an error code, vs. 0; it doesn;t have exceptions
2021-07-18 20:21:10	c_wraith	[03:45:41] in C, you look at return values and check ERRNO and hope nothing concurrent changed it
2021-07-18 20:21:10	geekosaur	[03:45:49] Either can;t handle this kind of exception
2021-07-18 20:21:10	lars8	[03:48:27] guest61, article makes a good argument why exceptions are prefered in IO over Either.  https://www.fpcomplete.com/blog/2016/11/exceptions-best-practices-haskell/
2021-07-18 20:21:10	guest61	[03:48:29] if there're multiple IO at the same time, one of them just did this, check ERRNO will work?
2021-07-18 20:21:10	lars8	[03:48:32] +this
2021-07-18 20:21:10	nitrix	[03:48:45] c_wraith, errno is thread-local for POSIX systems.
2021-07-18 20:21:10	guest61	[03:49:28] I thought that try-catch is typical OOP stuff
2021-07-18 20:21:10	geekosaur	[03:49:46] try-catch is not particularly OOP
2021-07-18 20:21:10	guest61	[03:49:49] FP has try-catch is weird
2021-07-18 20:21:10	nitrix	[03:50:21] For Haskell, Either/Maybe is a good way to do error-handling, then you also have nicer monad (transformers) like EitherT to do your exceptions.
2021-07-18 20:21:10	lars8	[03:50:54] but then you force callers to handle errors in two ways, via either, and exceptions
2021-07-18 20:21:10	guest61	[03:50:57] yes, but there're exception and run-time exception
2021-07-18 20:21:10	guest61	[03:51:13] Either cant handle run-time exception
2021-07-18 20:21:10	guest61	[03:55:35] how other languages without try-catch to handle run-time exceptions?
2021-07-18 20:21:10	xsperry	[03:57:10] probably more of a #programming question
2021-07-18 20:21:10	lars8	[04:21:43] guest61, Either can handle runtime errors, just return Left instead of throwing an exception. but, any IO code can throw exceptions other than the one you considered throwing, but are not returning (async exceptions, out of memory exceptions, etc), and encoding every possible exception in the type would be pretty tedious. java tried something similar with checked exceptions, and they are nearly universally hated
2021-07-18 20:21:10	lars8	[04:21:54] s/not/now
2021-07-18 20:21:10	c_wraith	[04:28:14] in some sense, Either is the same as checked exceptions.  Except that the tools for working with them are a lot more pleasant
2021-07-18 20:21:10	monochrom	[04:50:17] try-catch traces all the way back to a David Parnas 1970s paper. Way before OO.
2021-07-18 20:21:10	monochrom	[04:50:41] OO only added "the Exception type can have user-defined subtypes"
2021-07-18 20:21:10	monochrom	[04:51:21] SML also has had exceptions for a long time.
2021-07-18 20:21:10	monochrom	[04:51:31] and SML's predecessors
2021-07-18 20:21:10	monochrom	[04:55:12] Theorem provers written in *ML used this heavily for backtracking proof search. So it was not just I/O even.
2021-07-18 20:21:10	monochrom	[04:56:53] To be sure, in that use case, we now know that it should be Either/Maybe and MonadPlus. But writing theorem provers in *ML was a long long time ago.
2021-07-18 20:21:10	c_wraith	[05:00:22] and if you worry about performance of constructing/matching all those data types,  you might CPS-transform the Either, at which point...  you're basically back at exceptions anyway.  Except without an extra language construct.
2021-07-18 20:21:10	guest61	[07:05:52] update message is Nothing
2021-07-18 20:21:10	guest61	[07:05:53] update message is Nothing
2021-07-18 20:21:10	smtnet3	[08:17:16] yoyo
2021-07-18 20:21:10	hseg	[11:19:58] has this idea been offered to solve the orphan instance problem: extend overlapping rules so that non-orphan instances are considered more specific than orphan instances
2021-07-18 20:21:10	hseg	[11:20:41] at first blush, it would seem to provide a mechanism for adoptable orphans -- just mark your instance OVERLAPPABLE, and petition upstream to pull it in
2021-07-18 20:21:10	hseg	[11:22:44] you'd just want to extract the orphans from your package so you don't have multiple orphans first
2021-07-18 20:21:10	hseg	[12:09:04] no takers? to recall my question was whether considering non-orphan instances more specific than orphans for overlap resolution was ever considered as a solution for the orphan instance problem
2021-07-18 20:21:10	guest61	[12:46:44] update message is Nothing
2021-07-18 20:21:10	[exa]	[12:48:23] no update, good update
2021-07-18 20:21:10	tom__	[12:52:27] Are stochastic processes better modelled as comonads or monads?
2021-07-18 20:21:10	[exa]	[12:55:26] tom__: depends
2021-07-18 20:21:10	[exa]	[12:55:45] tom__: comonads are great for representing a "cache" of stuff, may be interesting for e.g. precomputed distributions
2021-07-18 20:21:10	[exa]	[12:56:28] tom__: monads are great for representing the "actual background context" that you only somehow manipulate using (say) an EDSL
2021-07-18 20:21:10	tom__	[12:56:33] Its for brownian motion/wiener process
2021-07-18 20:21:10	[exa]	[12:57:11] so you have a state of X particles moving around and hitting each other?
2021-07-18 20:21:10	tom__	[12:57:34] Well, modelling a stock price 
2021-07-18 20:21:10	tom__	[12:57:52] So just a time series
2021-07-18 20:21:10	[exa]	[12:58:35] ok so there's some "actual state", and some "history" that you may as well forget, right?
2021-07-18 20:21:10	tom__	[12:59:23] Yeah since its a martingale the process computes the next step from the last step only
2021-07-18 20:21:10	tom__	[12:59:58] but the last step has some extra state which is the delta of the brownian motion itself which  obviously has a random component
2021-07-18 20:21:10	tom__	[13:00:33] Forgetting history when computing the next step feels comonadic to me
2021-07-18 20:21:10	[exa]	[13:05:43] yeah that would work
2021-07-18 20:21:10	[exa]	[13:06:01] otoh it might be much simpler because you really don't need to reach for the history there
2021-07-18 20:21:10	tom__	[13:16:05] awesome thanks!
2021-07-18 20:21:10	guest61	[13:17:00] update message is Nothing
2021-07-18 20:21:10	Boarders	[13:49:20] Is there a convenient way to see every type defined in base?
2021-07-18 20:21:10	[exa]	[14:00:33] Boarders: in ghci, you can do something like Prelude.[2x tab]
2021-07-18 20:21:10	[exa]	[14:01:05] types will be nicely together starting with capitals
2021-07-18 20:21:10	[exa]	[14:01:20] but that ain't too systematic, right
2021-07-18 20:21:10	Boarders	[14:01:37] Still useful to know :)
2021-07-18 20:21:10	***	Playback Complete.
2021-07-18 20:21:17	--	Channel created on Sun, 25 Apr 2021 01:04:39
2021-07-18 20:22:43	<--	azeem (~azeem@dynamic-adsl-84-220-239-18.clienti.tiscali.it) has quit (Ping timeout: 246 seconds)
2021-07-18 20:28:17	-->	afotgkmnzj7asv3r (~afotgkmnz@2001:470:69fc:105::c24b) has joined #haskell
2021-07-18 20:28:30	-->	Atum_ (~IRC@user/atum/x-2392232) has joined #haskell
2021-07-18 20:31:01	-->	Gurkenglas (~Gurkengla@dslb-002-203-144-156.002.203.pools.vodafone-ip.de) has joined #haskell
2021-07-18 20:32:48	<--	zebrag (~chris@user/zebrag) has quit (Quit: Konversation terminated!)
2021-07-18 20:38:21	-->	burnsidesLlama (~burnsides@dhcp168-011.wadham.ox.ac.uk) has joined #haskell
2021-07-18 20:38:28	-->	yauhsien (~yauhsien@61-231-25-245.dynamic-ip.hinet.net) has joined #haskell
2021-07-18 20:38:50	<--	oso (~oso@2601:58c:c080:a950:e67d:b4e2:c5be:433f) has quit (Quit: Client closed)
2021-07-18 20:39:39	-->	Null_A (~null_a@2601:645:8700:2290:a961:38e5:e25d:7cd0) has joined #haskell
2021-07-18 20:41:02	-->	myShoggoth (~myShoggot@97-120-70-214.ptld.qwest.net) has joined #haskell
2021-07-18 20:48:30	davean	hseg_: I feel you've missed what we value about instances
2021-07-18 20:49:05	hseg_	oh?
2021-07-18 20:49:10	--	hseg_ is now known as hseg
2021-07-18 20:49:30	<--	drd (~drd@93-39-151-19.ip76.fastwebnet.it) has quit (Ping timeout: 255 seconds)
2021-07-18 20:50:42	davean	hseg: your approach makes it vary by what you import.
2021-07-18 20:50:45	<--	albet70 (~xxx@2400:8902::f03c:92ff:fe60:98d8) has quit (Remote host closed the connection)
2021-07-18 20:51:21	<--	MQ-17J (~MQ-17J@d14-69-206-129.try.wideopenwest.com) has quit (Ping timeout: 258 seconds)
2021-07-18 20:51:47	hseg	except it already does -- if you ever have overlapping instances, whether the more specific instance is imported will affect which instance gets chosen
2021-07-18 20:51:55	-->	albet70 (~xxx@2400:8902::f03c:92ff:fe60:98d8) has joined #haskell
2021-07-18 20:51:59	davean	yes, thats the problem
2021-07-18 20:51:59	hseg	true, that isn't common practice
2021-07-18 20:52:45	<--	albet70 (~xxx@2400:8902::f03c:92ff:fe60:98d8) has quit (Read error: Connection reset by peer)
2021-07-18 20:53:01	hseg	the idea would be that this would be used to provide instances until upstream does, not to try and override upstream's instances
2021-07-18 20:53:50	-->	Pickchea (~private@user/pickchea) has joined #haskell
2021-07-18 20:53:52	-->	albet70 (~xxx@2400:8902::f03c:92ff:fe60:98d8) has joined #haskell
2021-07-18 20:55:34	-->	isekaijin (~pyon@user/pyon) has joined #haskell
2021-07-18 20:57:07	-->	MQ-17J (~MQ-17J@d14-69-206-129.try.wideopenwest.com) has joined #haskell
2021-07-18 20:58:46	<--	albet70 (~xxx@2400:8902::f03c:92ff:fe60:98d8) has quit (Remote host closed the connection)
2021-07-18 20:59:52	-->	albet70 (~xxx@2400:8902::f03c:92ff:fe60:98d8) has joined #haskell
2021-07-18 20:59:54	-->	azeem (~azeem@dynamic-adsl-94-34-39-251.clienti.tiscali.it) has joined #haskell
2021-07-18 21:00:04	-->	nate1 (~nate@108-233-125-227.lightspeed.sntcca.sbcglobal.net) has joined #haskell
2021-07-18 21:00:54	-->	gehmehgeh (~user@user/gehmehgeh) has joined #haskell
2021-07-18 21:01:56	<--	MQ-17J (~MQ-17J@d14-69-206-129.try.wideopenwest.com) has quit (Ping timeout: 268 seconds)
2021-07-18 21:02:58	-->	peterhil (~peterhil@dsl-hkibng32-54f849-252.dhcp.inet.fi) has joined #haskell
2021-07-18 21:03:47	<--	myShoggoth (~myShoggot@97-120-70-214.ptld.qwest.net) has quit (Ping timeout: 268 seconds)
2021-07-18 21:04:31	-->	machinedgod (~machinedg@24.105.81.50) has joined #haskell
2021-07-18 21:04:55	-->	wroathe (~wroathe@c-68-54-25-135.hsd1.mn.comcast.net) has joined #haskell
2021-07-18 21:04:58	<--	nate1 (~nate@108-233-125-227.lightspeed.sntcca.sbcglobal.net) has quit (Ping timeout: 265 seconds)
2021-07-18 21:05:11	-->	MQ-17J (~MQ-17J@d14-69-206-129.try.wideopenwest.com) has joined #haskell
2021-07-18 21:05:52	-->	Deide (~Deide@217.155.19.23) has joined #haskell
2021-07-18 21:05:53	<--	Deide (~Deide@217.155.19.23) has quit (Changing host)
2021-07-18 21:05:53	-->	Deide (~Deide@user/deide) has joined #haskell
2021-07-18 21:06:19	-->	Guest9 (~Guest9@103.240.169.111) has joined #haskell
2021-07-18 21:06:52	--	RemiYuko is now known as AkechiShiro
2021-07-18 21:07:17	-->	ph88 (~ph88@2a02:8109:9e00:7e5c:f938:d06a:9ad7:b39c) has joined #haskell
2021-07-18 21:07:37	<--	wei2912 (~wei2912@112.199.250.21) has quit (Quit: Lost terminal)
2021-07-18 21:11:31	-->	keutoi (~keutoi@223.237.21.130) has joined #haskell
2021-07-18 21:12:05	-->	zmt00 (~zmt00@user/zmt00) has joined #haskell
2021-07-18 21:13:39	<--	cheater (~Username@user/cheater) has quit (Ping timeout: 268 seconds)
2021-07-18 21:13:50	-->	cheater (~Username@user/cheater) has joined #haskell
2021-07-18 21:18:46	<--	albet70 (~xxx@2400:8902::f03c:92ff:fe60:98d8) has quit (Remote host closed the connection)
2021-07-18 21:18:56	<--	xff0x_ (~xff0x@2001:1a81:525b:ea00:8ac3:8abd:f864:c680) has quit (Ping timeout: 255 seconds)
2021-07-18 21:19:23	-->	zcombinator (~zcombinat@host-79-33-75-218.retail.telecomitalia.it) has joined #haskell
2021-07-18 21:19:53	-->	albet70 (~xxx@2400:8902::f03c:92ff:fe60:98d8) has joined #haskell
2021-07-18 21:19:58	-->	xff0x_ (~xff0x@2001:1a81:525b:ea00:e4bc:612d:f531:cac7) has joined #haskell
2021-07-18 21:20:17	--	irc: disconnected from server
2021-07-19 11:15:18	-->	amanr (~therojjha@20.204.87.0) has joined #haskell
2021-07-19 11:15:18	--	Topic for #haskell is "https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org | Paste code/errors: https://paste.tomsmeding.com | tunes.org-style logging should be coming soon | Logs: https://ircbrowse.tomsmeding.com/browse/lchaskell"
2021-07-19 11:15:18	--	Topic set by geekosaur (~geekosaur@xmonad/geekosaur) on Mon, 14 Jun 2021 05:16:14
2021-07-19 11:15:18	--	Channel #haskell: 695 nicks (1 op, 0 voices, 694 normals)
2021-07-19 11:15:18	***	Buffer Playback...
2021-07-19 11:15:18	dsal	[17:12:57] If you're not the first member on an established team, they might be upset with you if you decided to ignore all their ways.
2021-07-19 11:15:18	davean	[17:13:34] I'd be upset to end up with the mess that is oumolu how ever it happened :-p
2021-07-19 11:15:18	dsal	[17:13:58] :(  Yeah.  That's the biggest downside I'm facing.
2021-07-19 11:15:18	davean	[17:14:22] oumolu has no concept of the code its formating
2021-07-19 11:15:18	davean	[17:14:29] it can only consider syntax, not content
2021-07-19 11:15:18	davean	[17:14:42] so every human element is thrown out the window
2021-07-19 11:15:18	dsal	[17:14:43] They took a lot from elm which prioritized reading diffs over reading code.
2021-07-19 11:15:18	dsal	[17:15:35] IMO, fixing the stuff that renders diffs would be a saner approach than making all the code harder to read.
2021-07-19 11:15:18	geekosaur	[17:18:23] --make hasn't been needed for a while now (since ghc 6.12 iirc)
2021-07-19 11:15:18	dsal	[17:19:03] I lose most of my excitement about elm, dhall, etc... when I have to do things their One True Way™.  I passed a thing I wrote in elm through their standard formatter and got this: https://www.irccloud.com/pastebin/lIpmTDCu/format.elm
2021-07-19 11:15:18	geekosaur	[17:19:15] I'm a little surprised it hasn't been deprecated
2021-07-19 11:15:18	dsal	[17:19:32] I've not used ormolu much myself, but I expect I'll be seeing more such doublings where I can't read a function on my screen anymore.
2021-07-19 11:15:18	monochrom	[17:22:06] In comp.lang.functional there was once a detractor who praised imperative programming for "one thing at a time, one concept per line" and attacked functional programming for the opposite.
2021-07-19 11:15:18	monochrom	[17:22:29] You have just shown an answer similar to mine :)
2021-07-19 11:15:18	davean	[17:22:55] lol. I've seen a lot of mixed concerns in imperative programming
2021-07-19 11:15:18	maerwald	[17:23:30] if you do imperative programming with shared mutability tamed, then that is workable
2021-07-19 11:15:18	monochrom	[17:25:03] My reverse thinking is that whoever imposed that oversplitting style must have been an imperative bonehead who couldn't even understand in C "x = cos(t); y = sin(t);" if I wrote that as one line.
2021-07-19 11:15:18	geekosaur	[17:25:24] or a Python programmer
2021-07-19 11:15:18	dsal	[17:25:54] monochrom: please state your variable names in the form of complete sentences.
2021-07-19 11:15:18	monochrom	[17:26:12] haha yikes
2021-07-19 11:15:18	davean	[17:26:27] the_variable_x
2021-07-19 11:15:18	geekosaur	[17:26:29] I haven't programmed cobol in decades
2021-07-19 11:15:18	dsal	[17:26:29] I got in an argument with someone who said he had some kind of neurodivergence and couldn't possible comprehend code that used such short variable names.
2021-07-19 11:15:18	davean	[17:26:30] Done?
2021-07-19 11:15:18	monochrom	[17:26:45]       COMPUTE COSINE OF T INTO X
2021-07-19 11:15:18	monochrom	[17:26:55] (let's go COBOL for complete sentences)
2021-07-19 11:15:18	monochrom	[17:28:23]       COMPUTE COSINE OF T INTO THE_VAR_THAT_WOULD_BE_COSINE_OF_T
2021-07-19 11:15:18	monochrom	[17:28:37] (inspired by the movie name "the kid that would be king" :) )
2021-07-19 11:15:18	monochrom	[17:29:05] "lady of the trig functions, please return the cosine of t"
2021-07-19 11:15:18	monochrom	[17:29:11] OK I'll stop.
2021-07-19 11:15:18	oso	[17:29:11] needs more "Please"
2021-07-19 11:15:18	davean	[17:29:25] no, should be worded must
2021-07-19 11:15:18	davean	[17:29:29] we want to have confidence in it
2021-07-19 11:15:18	oso	[17:30:03] i was referencing INTERCAL, which wouldn't compile if you didn't say "please" enough but also wouldn't compile if you said it too much because you were being a suckup
2021-07-19 11:15:18	davean	[17:30:51] Yes but a function like "please_compute_the_cosine_of_t" might not
2021-07-19 11:15:18	davean	[17:30:56] you can't rely on your code being agreeable!
2021-07-19 11:15:18	oso	[17:31:26] true; on the contrary, i find my code to be most disagreeable
2021-07-19 11:15:18	dsal	[17:40:04] In go, we use Must as a prefix for things that will panic if they don't work.
2021-07-19 11:15:18	davean	[17:40:34] Ugh, like usuall go gets it wrong
2021-07-19 11:15:18	davean	[17:40:45] "must" should make it a total function that matches the specification
2021-07-19 11:15:18	davean	[17:41:05] What part of "must" did they understand?
2021-07-19 11:15:18	monochrom	[17:41:18] mustHead (x:xs) = x  \∩/
2021-07-19 11:15:18	davean	[17:42:00] monochrom: thats exactly the sort of thing "must" must fix!
2021-07-19 11:15:18	monochrom	[17:42:20] mustFix f = let x = f x in x
2021-07-19 11:15:18	monochrom	[17:44:14] OTOH perhaps "if they don't work" means "you can assume it works, only a system bug would be a reason why it doesn't, which is not your responsibility"
2021-07-19 11:15:18	davean	[17:45:42] lets just always assume it works.
2021-07-19 11:15:18	monochrom	[17:45:43] OTOOH under multiple-world non-determinism and the convention "ignore those worlds that don't survive", the function works in all surviving worlds, so the modal quantifier "must" is right.
2021-07-19 11:15:18	davean	[17:45:57] Yah, now you're getting it
2021-07-19 11:15:18	monochrom	[17:46:03] :)
2021-07-19 11:15:18	davean	[17:47:11] mustSort = randomizeOrder
2021-07-19 11:15:18	dsal	[17:47:47] must sort eventually
2021-07-19 11:15:18	davean	[17:48:06] dsal: No, quantum bogosort sorts in O(n)
2021-07-19 11:15:18	dsal	[17:48:39] I've been meaning to get a new computer for a while.  Might as well be a quantum one.
2021-07-19 11:15:18	davean	[17:49:13] So, launch missiles is in IO, whats the monad of universes?
2021-07-19 11:15:18	monochrom	[17:49:43] []
2021-07-19 11:15:18	monochrom	[17:50:22] Dr. Strange and the LogicT monad transformer of madness
2021-07-19 11:15:18	h98	[17:51:08] dumb question, is there a way to avoid the inner parentheses in the type application "@(f (g a b))"? something like @(f $ g a b) on the type-level?
2021-07-19 11:15:18	monochrom	[17:51:44] No.
2021-07-19 11:15:18	dmj`	[17:52:33] type Foo f g a b = f (g a b) -- @(Foo f g a b) ... maybe?
2021-07-19 11:15:18	h98	[17:54:21] oooh
2021-07-19 11:15:18	davean	[17:54:39] I guess the Haskellish form would be "sort = must (\xs -> all id . map (\(x,y) -> x <= y) . zip xs $ tail xs) randomizeOrder 
2021-07-19 11:15:18	h98	[17:54:40] yes duh, that works...thanks
2021-07-19 11:15:18	guest61	[18:03:38] update message is Nothing
2021-07-19 11:15:18	h98	[18:05:23] I can't get over that trick by the way davean, no more nested parentheses in any of my type expressions!
2021-07-19 11:15:18	guest61	[18:05:35] update message is Nothing
2021-07-19 11:15:18	davean	[18:05:36] Yu mean dmj`?
2021-07-19 11:15:18	h98	[18:05:55] sorry yes, dmj` hah
2021-07-19 11:15:18	davean	[18:06:06] *I'd* nest the parens because its less indirection :-p
2021-07-19 11:15:18	dmj`	[18:06:35] "One weird trick to remove your parentheses... lisp programmers *hate* him"
2021-07-19 11:15:18	davean	[18:06:36] (Not if the alias had semantics weight of its own though)
2021-07-19 11:15:18	guest61	[18:58:52] update message is Nothing
2021-07-19 11:15:18	monochrom	[19:03:47] guest61: What is all that about?
2021-07-19 11:15:18	guest61	[19:04:12] update message is Nothing
2021-07-19 11:15:18	tom__	[19:12:25] So if you are modelling a stochastic process as a comonad how do you get the randomness for each step if IO is a monad
2021-07-19 11:15:18	dsal	[19:13:09] Guest9: update message is (Just Quit)
2021-07-19 11:15:18	 *	dsal [19:13:32] is too late and missed
2021-07-19 11:15:18	davean	[19:18:07] tom__: or randomness is a source for the cell
2021-07-19 11:15:18	tom__	[19:19:17] davean: Right but you can't product a cell without being in IO then?
2021-07-19 11:15:18	tom__	[19:19:20] produce
2021-07-19 11:15:18	davean	[19:20:11] tom__: I mean, you don't need to be in IO to step a pseudo random function
2021-07-19 11:15:18	davean	[19:20:30] You can do all sorts of things
2021-07-19 11:15:18	davean	[19:20:48] the particular one I'd start with is taking one seed value, and splitting a prf to all the "cells"
2021-07-19 11:15:18	dsal	[19:22:59] > randomRs (1, 11)  $ mkStdGen 42
2021-07-19 11:15:18	lambdabot	[19:23:00]  [1,8,1,3,2,8,5,3,6,10,9,3,10,11,9,2,1,11,3,3,9,3,3,9,1,7,9,8,6,7,4,2,7,1,3,2...
2021-07-19 11:15:18	tom__	[19:28:18] Does the Random package allow sampling from a normal distribution?
2021-07-19 11:15:18	geekosaur	[19:28:53] yes, as of 1.2
2021-07-19 11:15:18	tom__	[19:29:02] thanks
2021-07-19 11:15:18	davean	[19:29:19] tom__: I mean it provides random numbers, sampling from is a way to *use* randomness
2021-07-19 11:15:18	tom__	[19:29:19] Does "Constructs a StdGen deterministically." mean - not randomly?
2021-07-19 11:15:18	davean	[19:29:58] Uh, the construction is never random persay
2021-07-19 11:15:18	geekosaur	[19:29:59] if the input you give it is deterministic then yes
2021-07-19 11:15:18	dsal	[19:30:00] > randomRs (1, 11)  $ mkStdGen 42 -- tom__ yes, it means it'll reproduce the same sequence
2021-07-19 11:15:18	lambdabot	[19:30:01]  [1,8,1,3,2,8,5,3,6,10,9,3,10,11,9,2,1,11,3,3,9,3,3,9,1,7,9,8,6,7,4,2,7,1,3,2...
2021-07-19 11:15:18	tom__	[19:31:21] Ah ok so mkStdGen enables "decoupling" between IO and your computation
2021-07-19 11:15:18	dsal	[19:31:47] Yes.  There are MonadIO variants in there as well.
2021-07-19 11:15:18	geekosaur	[19:31:58] you can also get a randomly generated seed from IO and do the rest purely
2021-07-19 11:15:18	tom__	[19:32:11] aha thanks
2021-07-19 11:15:18	tom__	[19:32:47] by purely do you mean -  not with IO?
2021-07-19 11:15:18	davean	[19:32:48] Note there are plenty of monadic forms that aren't IO also, for prfs
2021-07-19 11:15:18	geekosaur	[19:33:22] yes
2021-07-19 11:15:18	davean	[19:33:52] I'm not really a fan of the 1.2 changes :/
2021-07-19 11:15:18	davean	[19:34:21] tom__: if you want good sampling, see random-fu and such BTW
2021-07-19 11:15:18	davean	[19:34:31] distributions is seperate from random numbers
2021-07-19 11:15:18	geekosaur	[19:34:57] on the one hand it cleaned up my use of the mersenne twister a bit; on the other I found 1.1 much easier
2021-07-19 11:15:18	geekosaur	[19:35:17] gripping hand I didn't have to fake normal distributions any more
2021-07-19 11:15:18	davean	[19:35:31] geekosaur: I don't think the 1.2 design is valid :/ I think theres some actual contradictions in its design, but thats far too long a discussion for here and now
2021-07-19 11:15:18	davean	[19:36:13] I'm actually rather upset about 1.2
2021-07-19 11:15:18	davean	[19:36:27] Not that 1.1 was great
2021-07-19 11:15:18	tom__	[19:38:50] I'm using MWC-probability 
2021-07-19 11:15:18	mdunnio	[19:39:53] hello! is anyone aware of any up-to-date guides on how to use LLVM backend with GHC? I'm looking to utilize GHC 8.10.5's first class support for M1, but I'm not exactly sure where to get started.
2021-07-19 11:15:18	geekosaur	[19:41:18] using it is just doing "ghc-options: -fllvm" in the cabal file. but I think 8.10.5 is known buggy
2021-07-19 11:15:18	mdunnio	[19:41:44] oh interesting. ok
2021-07-19 11:15:18	mdunnio	[19:42:12] I'll try that out
2021-07-19 11:15:18	geekosaur	[19:42:26] and true first class (-fasm) support is supposed to come in 9.2.1
2021-07-19 11:15:18	geekosaur	[19:42:55] there's a prerelease available in ghcup but it has some known bugs
2021-07-19 11:15:18	davean	[19:43:22] Yah, on one hand llvm is kinda first class, on the other, LLVM isn't a general system and we don't fit its preconception of being C
2021-07-19 11:15:18	davean	[19:43:30] So it'll never be quite right to use LLVM
2021-07-19 11:15:18	davean	[19:43:48] You'll always eat a penalty of LLVM not being a general system
2021-07-19 11:15:18	mdunnio	[19:44:42] penalty as in performance, or just support generally?
2021-07-19 11:15:18	geekosaur	[19:44:56] both
2021-07-19 11:15:18	davean	[19:44:57] More the former, but there CAN be a few issues with the later
2021-07-19 11:15:18	davean	[19:45:07] LLVM is very much a C IR
2021-07-19 11:15:18	davean	[19:45:20] It claims to be general, but frankly, thats wishful thinking
2021-07-19 11:15:18	geekosaur	[19:45:22] llvm doesn't understand the cps-encoded code ghc emits and pessimizes it
2021-07-19 11:15:18	davean	[19:45:26] it has a ton of assumptions baked in at hte bottom
2021-07-19 11:15:18	Rembane	[19:45:43] So every language that looks like C if you squint works for LLVM?
2021-07-19 11:15:18	davean	[19:45:57] Rembane: Close, and LLVM works more generally than that, just not well
2021-07-19 11:15:18	davean	[19:46:10] LLVM can't think some normal thoughts, and never will be able to
2021-07-19 11:15:18	mdunnio	[19:46:13] I see
2021-07-19 11:15:18	Rembane	[19:46:25] davean: Got it. Doesn't sound too bad if your needs are C et al
2021-07-19 11:15:18	davean	[19:46:26] Theres ways to make them "work" because the turing tarpit, but that doesn't mean they work well
2021-07-19 11:15:18	davean	[19:46:37] Rembane: Yah, its actually great for that
2021-07-19 11:15:18	davean	[19:46:48] Rembane: I mean you make sometihng better for one thing, usually you make it worse for another
2021-07-19 11:15:18	davean	[19:46:58] the only issue I see here is the claim that its general, which it just clearly isn't
2021-07-19 11:15:18	davean	[19:47:16] but! It works pretty well for GHC for most thing
2021-07-19 11:15:18	davean	[19:47:22] so, go use it
2021-07-19 11:15:18	davean	[19:47:31] Its actually the best option for a few specific cases
2021-07-19 11:15:18	davean	[19:47:38] and you can do funky stuff to use it only where it is the best ...
2021-07-19 11:15:18	davean	[19:48:05] So like, its good to have, I'm not trying to bash it, just explain what one might feel about "first class ness"
2021-07-19 11:15:18	mdunnio	[19:48:36] yeah, to be fair, I have a pretty broad interpretation of what "first class support" even means
2021-07-19 11:15:18	Rembane	[19:48:58] davean: Totally, it's trade offs all the way down. 
2021-07-19 11:15:18	mdunnio	[19:49:07] at this point, I'm willing to take "does it work at all?"
2021-07-19 11:15:18	davean	[19:49:14] mdunnio: ok!
2021-07-19 11:15:18	davean	[19:49:16] so, it does work!
2021-07-19 11:15:18	davean	[19:50:14] mdunnio: So my understanding is that the nix stuff is still the best option
2021-07-19 11:15:18	davean	[19:51:02] (I uh, keep an arms length from Apple, I just uh, make sure we have CI for it)
2021-07-19 11:15:18	davean	[19:51:56] Talking of which, yah rossetta, uh, don't run a ton of x86 binaries.
2021-07-19 11:15:18	mdunnio	[19:53:05] fair
2021-07-19 11:15:18	mdunnio	[19:53:10] yeah, that's the plan
2021-07-19 11:15:18	davean	[19:53:38] yah, its a problem (I don't know if you know, but it doesn't clear the cache, so you'll run out of disk space and be stuck unless you disable SIP)
2021-07-19 11:15:18	mdunnio	[19:53:46] I haven't actually worked much with nix yet, might be time to experiment
2021-07-19 11:15:18	davean	[19:54:19] mdunnio: So, I'm not sure they want me to refer you, but the bigest expert I know in this area is moritz angermann
2021-07-19 11:15:18	davean	[19:54:31] I think we're due for a writeup on the state of M1 stuff
2021-07-19 11:15:18	davean	[19:54:41] It would be a public service
2021-07-19 11:15:18	mdunnio	[19:55:26] I recall moritz wrote up a bunch about cross-compiling for ARM. I did some rpi work back a year or so ago
2021-07-19 11:15:18	davean	[19:56:01] I'll admit I was taking care of a lot of the mac stuff and then moritz stepped in and not being a mac user I disowned it as fast as possible
2021-07-19 11:15:18	mdunnio	[19:56:23] seems like the appropriate time to pass the torch
2021-07-19 11:15:18	mdunnio	[19:56:51] ok, I'm going to experiment a little bit and see if I can get somewhere. I appreciate the help
2021-07-19 11:15:18	davean	[19:57:02] Someone needed to do it, but better it be someone who loves it and has base skills for it
2021-07-19 11:15:18	davean	[19:59:01] Hum, I failed to full say what I should have above - which is that the CI config is where that knowlege should be accessible
2021-07-19 11:15:18	davean	[19:59:04] well I'm a bad helper
2021-07-19 11:15:18	 *	sm [20:29:07] wonders why the above thread jumped tracks from LLVM to apple .. do these go together ?
2021-07-19 11:15:18	sm	[20:29:43] and , #ghc is also a good source of info
2021-07-19 11:15:18	davean	[20:31:47] sm: it was about Apple
2021-07-19 11:15:18	geekosaur	[20:31:49] sm: M1 == Apple Silicon
2021-07-19 11:15:18	davean	[20:31:55] the point of LLVM there was to get M1 support
2021-07-19 11:15:18	davean	[20:32:08] which we get via LLVM or the native code gen, the native code gen isn't until 9.2 tohugh
2021-07-19 11:15:18	zangi	[20:32:35] does laziness consume more memory than strict evaluation?
2021-07-19 11:15:18	davean	[20:32:45] zangi: no, sometimes far less
2021-07-19 11:15:18	dminuoso	[20:32:46] Yes. No.
2021-07-19 11:15:18	zangi	[20:33:40] what about the thunks?
2021-07-19 11:15:18	dminuoso	[20:33:42] zangi: In order to provide lazyness, the lazy expression has to have some kind of memory representation. That costs allocation and indirection. 
2021-07-19 11:15:18	davean	[20:33:44] zangi: Theres a few cases where it uses more, the main one is special cased in the GC
2021-07-19 11:15:18	davean	[20:34:07] zangi: whats smaller, the infinite list, or the thunk [1..]?
2021-07-19 11:15:18	dminuoso	[20:34:11] zangi: But this is usually offset having low residency when working on large data.
2021-07-19 11:15:18	dminuoso	[20:34:45] I think the fundamental problem is that "memory consumption" is not something you can put as a single number metric.
2021-07-19 11:15:18	dminuoso	[20:37:44] For instance: Your program might process a 20TiB data set but have only 50MiB of memory residency at any given time.
2021-07-19 11:15:18	dminuoso	[20:38:39] But this could still have a lot of allocations internally
2021-07-19 11:15:18	dminuoso	[20:39:22] Lazyness also produces a level of indirection, which might hurt locality 
2021-07-19 11:15:18	davean	[20:40:10] or it can create locality
2021-07-19 11:15:18	lechner	[20:40:46] Hi, why are the dolla signs needed in these two lines, please?    https://dpaste.org/41S0#L94,95
2021-07-19 11:15:18	dminuoso	[20:41:03] lechner: They are not needed.
2021-07-19 11:15:18	dminuoso	[20:41:17] lechner: You can also use parens to associate the right hand side of it.
2021-07-19 11:15:18	dminuoso	[20:41:31] host $ scheduler config is equivalent to: host (schedular config)
2021-07-19 11:15:18	lechner	[20:41:42] can i use map, too?
2021-07-19 11:15:18	lechner	[20:43:47] dminuoso: I get the following errors when I take out the dollar signs    https://dpaste.org/mM0q
2021-07-19 11:15:18	dminuoso	[20:44:10] lechner: Like I said.
2021-07-19 11:15:18	dsal	[20:44:16] Does anyone know how to do something interesting with Control.Monad.Trans.Select ?    There doesn't seem to be much written about it.
2021-07-19 11:15:18	dminuoso	[20:44:21] `host $ scheduler config` is equivalent to `host (scheduler config)
2021-07-19 11:15:18	lechner	[20:44:50] okay, why are the parentheses needed, please?
2021-07-19 11:15:18	davean	[20:44:56] lechner: to parse it
2021-07-19 11:15:18	geekosaur	[20:45:09] $ is "backwards parentheses
2021-07-19 11:15:18	lechner	[20:45:15] that i know
2021-07-19 11:15:18	lechner	[20:45:35] i think it's a (slightly) higher level question
2021-07-19 11:15:18	davean	[20:45:40] lechner: so things (sorta) group to the left by default
2021-07-19 11:15:18	geekosaur	[20:45:42] so if you remove a $ you usually have to insert the parenheses it was replacing. here, for (scheduler config)
2021-07-19 11:15:18	davean	[20:45:52] lechner: you need to put it into the grammer as a group, not seperate things
2021-07-19 11:15:18	lechner	[20:46:03] my JSON declarations are not strict
2021-07-19 11:15:18	davean	[20:46:22] WHo said anything about strictness?
2021-07-19 11:15:18	davean	[20:46:53] This is about grammar
2021-07-19 11:15:18	monochrom	[20:47:04] The computer is not telepathic. You can't just write "f g h" and "t x y" and have the computer guess "oh you mean (f g) h and t (x y)".
2021-07-19 11:15:18	lechner	[20:47:37] not even when asking for a final result (printf) ?
2021-07-19 11:15:18	monochrom	[20:47:55] But there is a little bit of left associativity so "f g h" means "(f g) h".
2021-07-19 11:15:18	lechner	[20:48:24] why is that evaluated in my case, though?
2021-07-19 11:15:18	nf	[20:52:20] you usually have to evaluate things in order to print them
2021-07-19 11:15:18	davean	[20:53:32] lechner: it doesn't know printf is your final result even
2021-07-19 11:15:18	lechner	[20:53:36] but is that done inside the parentheses around the argument to printf?
2021-07-19 11:15:18	davean	[20:53:44] Its not "done inside"
2021-07-19 11:15:18	davean	[20:53:51] you're saying what is applied to what
2021-07-19 11:15:18	lechner	[20:54:38] i think i misunderstood partial application
2021-07-19 11:15:18	davean	[21:02:30] Definition is not execution
2021-07-19 11:15:18	davean	[21:02:52] lechner: consider the option of doign that like with (.)
2021-07-19 11:15:18	davean	[21:02:58] *line
2021-07-19 11:15:18	maerwald	[21:04:47] monochrom: wingman can guess what you mean, haha
2021-07-19 11:15:18	maerwald	[21:05:02] if your types are correct, that is
2021-07-19 11:15:18	maerwald	[21:06:36] now you just need something to guess the types for you
2021-07-19 11:15:18	maerwald	[21:07:16] and then something that guesses what the program should do
2021-07-19 11:15:18	maerwald	[21:07:26] we'll have no engineering problems to solve anymore
2021-07-19 11:15:18	 *	maerwald [21:07:43] goes packing
2021-07-19 11:15:18	dexterfoo	[21:08:24] can I convert a 'Text' value directly into an Int?
2021-07-19 11:15:18	Hecate	[21:11:07] % import Data.Text.Read
2021-07-19 11:15:18	yahb	[21:11:08] Hecate: 
2021-07-19 11:15:18	Hecate	[21:11:12] % decimal "3"
2021-07-19 11:15:18	yahb	[21:11:13] Hecate: ; <interactive>:223:1: error:; Ambiguous occurrence `decimal'; It could refer to; either `Data.Text.Read.decimal', imported from `Data.Text.Read'; or `Numeric.Lens.decimal', imported from `Numeric.Lens'
2021-07-19 11:15:18	Hecate	[21:11:19] fair enough
2021-07-19 11:15:18	Hecate	[21:11:20] so
2021-07-19 11:15:18	monochrom	[21:11:30] fib :: Int -> Int -> Int -> Int -> Int  let wingman guess what I want!
2021-07-19 11:15:18	Hecate	[21:11:32] Data.Text.Read.decimal "3"
2021-07-19 11:15:18	Hecate	[21:11:35] % Data.Text.Read.decimal "3"
2021-07-19 11:15:18	yahb	[21:11:35] Hecate: ; <interactive>:224:24: error:; * Couldn't match type `[Char]' with `Data.Text.Internal.Text'; Expected: Data.Text.Internal.Text; Actual: GHC.Base.String; * In the first argument of `Data.Text.Read.decimal', namely `"3"'; In the expression: Data.Text.Read.decimal "3"; In an equation for `it': it = Data.Text.Read.decimal "3"
2021-07-19 11:15:18	Hecate	[21:11:39] curse
2021-07-19 11:15:18	Hecate	[21:11:46] % import qualified Data.Text as T
2021-07-19 11:15:18	yahb	[21:11:46] Hecate: 
2021-07-19 11:15:18	Hecate	[21:11:52] % Data.Text.Read.decimal (T.pack "3")
2021-07-19 11:15:19	yahb	[21:11:53] Hecate: Right (3,"")
2021-07-19 11:15:19	Hecate	[21:11:57] % Data.Text.Read.decimal (T.pack "3x")
2021-07-19 11:15:19	yahb	[21:11:57] Hecate: Right (3,"x")
2021-07-19 11:15:19	Hecate	[21:12:08] dexterfoo: check this ^
2021-07-19 11:15:19	lechner	[21:13:53] davean: how do i use . in that line, please?
2021-07-19 11:15:19	maerwald	[21:15:08] sometimes I wonder why I even write documentation... all it does is confuse me 2 weeks later
2021-07-19 11:15:19	maerwald	[21:15:39] "I tried to figure out what this does, but didn't manage. But I wrote down my crippled thought regardless"
2021-07-19 11:15:19	dexterfoo	[21:15:45] Hecate: thanks!
2021-07-19 11:15:19	Hecate	[21:16:28] maerwald: because you don't know how to talk to yourself yet :P
2021-07-19 11:15:19	Hecate	[21:16:34] dexterfoo: you're welcome :)
2021-07-19 11:15:19	maerwald	[21:16:44] Hecate: preciousssss
2021-07-19 11:15:19	lechner	[21:20:32] Hi, in     printf "%s:%d" $ map ($ struct) [stringAccessor intAccessor]     does map work only when the return types are the same?
2021-07-19 11:15:19	lechner	[21:20:55] actually, there is a comma in there
2021-07-19 11:15:19	geekosaur	[21:21:05] all elements of a list must have the same type, yes
2021-07-19 11:15:19	lechner	[21:22:27] thanks. i could prosumably use 'show'
2021-07-19 11:15:19	geekosaur	[21:23:05] that's the usual way to do it, yes
2021-07-19 11:15:19	geekosaur	[21:23:14] don't forget to change the %d to %s
2021-07-19 11:15:19	lechner	[21:24:18] at some point, that tips the scale toward  putStrLn
2021-07-19 11:15:19	geekosaur	[21:24:30] yes
2021-07-19 11:15:19	dsal	[21:27:27] lechner: You could make a function that does the "%s:%d" part pretty easily and NamedFieldPuns or RecordWildCards would make it fairly short.
2021-07-19 11:15:19	lechner	[21:29:28] dsal: that sounds like a great idea! let's do that in one minute please.
2021-07-19 11:15:19	lechner	[21:30:04] meanwhile i am learning. why doesn't that work:   printf "Expecting scheduler on %s:%s.\n" $ map ($ scheduler config) [Connection.host, show . Connection.listen_port]
2021-07-19 11:15:19	lechner	[21:31:55] the point here is the partial application of 'show'
2021-07-19 11:15:19	[exa]	[21:32:01] lechner: what's the error?
2021-07-19 11:15:19	lechner	[21:32:32] https://paste.debian.net/1204829/
2021-07-19 11:15:19	geekosaur	[21:32:45] I think you have multiple problems there
2021-07-19 11:15:19	geekosaur	[21:33:12] for one, a list is not a collection of applications
2021-07-19 11:15:19	dsal	[21:33:16] lechner: A list isn't two arguments.
2021-07-19 11:15:19	dsal	[21:33:26] Or phrased how geekosaur said it.
2021-07-19 11:15:19	[exa]	[21:33:55] lechner: why still keep printf? (just curious)
2021-07-19 11:15:19	lechner	[21:34:19] just chewing on other things :)
2021-07-19 11:15:19	lechner	[21:34:54] [exa]: i am not so fond of ++ "[" ++ exa ++ "]" ++ ....
2021-07-19 11:15:19	geekosaur	[21:35:14] there is concat
2021-07-19 11:15:19	oso	[21:35:15] `concat`?
2021-07-19 11:15:19	dsal	[21:35:43] I don't use ++ in general, but I do use fold for logging.
2021-07-19 11:15:19	monochrom	[21:36:04] $ kills printf type inference. Seriously. Just don't use $.
2021-07-19 11:15:19	[exa]	[21:36:42] lechner: `concat [all, this, stuff]` is a widely used pattern. Esp good when combined with `intercalate`
2021-07-19 11:15:19	lechner	[21:37:01] monochrom: for some reason it seemed i needed $
2021-07-19 11:15:19	dsal	[21:37:40] lechner: does it work with $ ?
2021-07-19 11:15:19	monochrom	[21:37:43] Sure, "map ($ x) [f, g, h]" has just cause.  I am referring to "printf fmt $ ..."
2021-07-19 11:15:19	lechner	[21:37:56] okay, i'll change that but why is my partial application wrong. could someone please restate?
2021-07-19 11:15:19	dsal	[21:37:57] :t ($)
2021-07-19 11:15:19	lambdabot	[21:37:58] (a -> b) -> a -> b
2021-07-19 11:15:19	geekosaur	[21:38:17] lechner, you are attempting to use a list as two applications
2021-07-19 11:15:19	lechner	[21:38:17] monochrom: i meant that one
2021-07-19 11:15:19	[exa]	[21:38:25] lechner: the partial application is right (at least so it seems to me), the problem is that you're giving printf 1 argument and specify 2 in format
2021-07-19 11:15:19	dsal	[21:38:37] lechner: If it doesn't work, then it's not fair to say that you needed it.
2021-07-19 11:15:19	geekosaur	[21:38:43] one list is one application, not two
2021-07-19 11:15:19	dsal	[21:39:17] > (+) $ 1 $ 2
2021-07-19 11:15:19	lambdabot	[21:39:18]  error:
2021-07-19 11:15:19	lambdabot	[21:39:18]      • Could not deduce (Num t0)
2021-07-19 11:15:19	lambdabot	[21:39:18]        from the context: (Num a, Num t, Num (t -> a))
2021-07-19 11:15:19	dsal	[21:39:55] $ isn't a syntactic feature.  It's just a function.  And it will break your applications if effective arity is > 1
2021-07-19 11:15:19	lechner	[21:40:01] [exa]: https://paste.debian.net/1204830/
2021-07-19 11:15:19	[exa]	[21:40:44] dsal: you'd need -XChurchNumerals
2021-07-19 11:15:19	dsal	[21:40:48] You might try breaking that into different statements to understand it better.
2021-07-19 11:15:19	geekosaur	[21:41:16] lechner, contemplate this:
2021-07-19 11:15:19	geekosaur	[21:41:25] > (+) [1,2]
2021-07-19 11:15:19	lambdabot	[21:41:27]  error:
2021-07-19 11:15:19	lambdabot	[21:41:27]      • No instance for (Num [Integer]) arising from a use of ‘e_112’
2021-07-19 11:15:19	lambdabot	[21:41:27]      • In the expression: e_112
2021-07-19 11:15:19	geekosaur	[21:41:43] hm, (+) is not the best example there
2021-07-19 11:15:19	monochrom	[21:41:54] (&&) [False, False]
2021-07-19 11:15:19	[exa]	[21:41:57] lechner: yeah there printf uses `map` as the first argument, likely not very printable
2021-07-19 11:15:19	geekosaur	[21:41:58] > (++) ["a","b"]
2021-07-19 11:15:19	lambdabot	[21:42:00]  <[[Char]] -> [[Char]]>
2021-07-19 11:15:19	lechner	[21:42:03] geekosaur: isn't that here four applications?   https://salsa.debian.org/lintian/kickoff/-/blob/master/Collect.hs#L68
2021-07-19 11:15:19	lechner	[21:42:40] [exa]: yeah, that part i get now
2021-07-19 11:15:19	monochrom	[21:42:40] one single list.
2021-07-19 11:15:19	geekosaur	[21:42:46] lechner, no, it is a 4-element list
2021-07-19 11:15:19	dsal	[21:42:56] :t map
2021-07-19 11:15:19	lambdabot	[21:42:57] (a -> b) -> [a] -> [b]
2021-07-19 11:15:19	geekosaur	[21:43:06] thisis not lisp, a list is not a group of applications
2021-07-19 11:15:19	dsal	[21:43:23] map takes a function and applies it to each element inside a list.  One list in, one list out.
2021-07-19 11:15:19	lechner	[21:44:39] that's what i am looking for, except one member (of all partially or unapplied functions) is specified as    a . b 
2021-07-19 11:15:19	dsal	[21:45:19] You're doing several things at once.  You will likely have more success if you break them down a bit.
2021-07-19 11:15:19	lechner	[21:45:53] dsal: let's go with your approach. i am reading up on puns
2021-07-19 11:15:19	dsal	[21:45:54] A list is one thing, but it's not what your printf wants.  So to work backwards, you'll have to figure out how to make what your printf wants.
2021-07-19 11:15:19	lechner	[21:46:03] yes
2021-07-19 11:15:19	lechner	[21:46:14] let's chuck printf
2021-07-19 11:15:19	dsal	[21:46:17] My approach is to make a function that formats  your connection string.
2021-07-19 11:15:19	dsal	[21:47:12] In MonadLogger, you can call that ToLogStr, but that's the opposite direction from "do less stuff"  :)
2021-07-19 11:15:19	lechner	[21:54:50] can i define an instance of 'show' to return the string     host ++ ":" ++ listen_port     for a type that has both?
2021-07-19 11:15:19	geekosaur	[21:55:05] you can but you shouldn't
2021-07-19 11:15:19	lechner	[21:55:20] why not, please?
2021-07-19 11:15:19	geekosaur	[21:55:47] an instance of Show should match an instance of Read and ideally be a fragment of Haskell source that will reproduce a value of the type within ghc /  ghci
2021-07-19 11:15:19	geekosaur	[21:56:37] otherwise you run into issues Show-ing or Read-ing structures that contain values of that type
2021-07-19 11:15:19	lechner	[21:56:39] could i add both?
2021-07-19 11:15:19	geekosaur	[21:57:38] what do you mean?
2021-07-19 11:15:19	lechner	[21:58:00] Show and Read
2021-07-19 11:15:19	dsal	[21:58:40] lechner: That's not what show is for.  This is why MonadLogger defines ToLogStr.  You can make your own.
2021-07-19 11:15:19	dminuoso	[21:59:47] geekosaur: Strictly speaking, that is only requires for deriving generated instances. This notion that they "should" seems to be based in rumour or just an observation of established practice.
2021-07-19 11:15:19	dsal	[21:59:47] You *can* define your own Show and Read if you're pretty sure you can encapsulate all of the structure you want.  It's not definitely the wrong idea all the time, but it's not easier than making something specific for logging and having your logger log with it.
2021-07-19 11:15:19	dsal	[22:00:39] I think it's the date/time stuff that has fancy Show instances that just make life miserable when you have them in data structures.
2021-07-19 11:15:19	lechner	[22:01:08] i should not use UTCTime in JSON decls?
2021-07-19 11:15:19	pavonia	[22:01:13] Custom Show instances are a PITA if you have to debug things. Just don't do it
2021-07-19 11:15:19	lechner	[22:01:22] okay
2021-07-19 11:15:19	monochrom	[22:01:42] Established practice is still something to respect.  Of course, "respect" allows exceptions.  OK I'm on a fence, I'll stop now.
2021-07-19 11:15:19	lechner	[22:02:04] i'm just learning
2021-07-19 11:15:19	sm	[22:04:01] for learning, do whatever you like :)
2021-07-19 11:15:19	exarkun	[22:04:58] Where's the Haskell implementation of https://en.wikipedia.org/wiki/Turtle_graphics ?
2021-07-19 11:15:19	lechner	[22:05:52] what's the precedence between $ and ++ please?
2021-07-19 11:15:19	dminuoso	[22:06:55] %i ($)
2021-07-19 11:15:19	dminuoso	[22:07:05] % :i ($)
2021-07-19 11:15:19	yahb	[22:07:05] dminuoso: ($) :: (a -> b) -> a -> b -- Defined in `GHC.Base'; infixr 0 $
2021-07-19 11:15:19	dminuoso	[22:07:07] % :i (++)
2021-07-19 11:15:19	yahb	[22:07:08] dminuoso: (++) :: [a] -> [a] -> [a] -- Defined in `GHC.Base'; infixr 5 ++
2021-07-19 11:15:19	dminuoso	[22:07:18] lechner: ^- See the fixity declarations?
2021-07-19 11:15:19	dminuoso	[22:08:05] The number is the precedence level
2021-07-19 11:15:19	dsal	[22:08:09] % :i (<>)
2021-07-19 11:15:19	yahb	[22:08:09] dsal: type GHC.Base.Semigroup :: * -> Constraint; class GHC.Base.Semigroup a where; (<>) :: a -> a -> a; ...; -- Defined in `GHC.Base'; infixr 6 <>
2021-07-19 11:15:19	dsal	[22:08:17] That's interesting.
2021-07-19 11:15:19	dminuoso	[22:08:20] And the `r` in infixr means its right-associative. We also have infixl for left associative
2021-07-19 11:15:19	dminuoso	[22:09:23] If no fixity is declared, an operator defaults to infixl 9.
2021-07-19 11:15:19	lechner	[22:09:33] dsal: ++ binds more tightly than $ right?
2021-07-19 11:15:19	dminuoso	[22:09:41] Yes.
2021-07-19 11:15:19	monochrom	[22:10:01] What do "0" and "5" tell you?
2021-07-19 11:15:19	lechner	[22:10:32] a relative ordering
2021-07-19 11:15:19	dsal	[22:10:35] I don't ever use ++.  I just never considered ++ was lower than <>
2021-07-19 11:15:19	lechner	[22:11:05] what is <> please? i have only seen that in purescript
2021-07-19 11:15:19	dsal	[22:11:14] :t (<>)
2021-07-19 11:15:19	lambdabot	[22:11:16] Semigroup a => a -> a -> a
2021-07-19 11:15:19	dsal	[22:11:17] :t (++)
2021-07-19 11:15:19	lambdabot	[22:11:19] [a] -> [a] -> [a]
2021-07-19 11:15:19	dsal	[22:11:35] ++ only works for lists.  <> is like ++ but works for many other types.
2021-07-19 11:15:19	xsperry	[22:11:40] lechner, you can think of it as a more general ++. it works with more than just lists
2021-07-19 11:15:19	lechner	[22:12:02] dsal: should is stick to concat instead of ++?
2021-07-19 11:15:19	dsal	[22:12:29] :t concat
2021-07-19 11:15:19	lambdabot	[22:12:30] Foldable t => t [a] -> [a]
2021-07-19 11:15:19	dsal	[22:12:37] :t fold
2021-07-19 11:15:19	lambdabot	[22:12:39] (Foldable t, Monoid m) => t m -> m
2021-07-19 11:15:19	dsal	[22:12:51] That doesn't do the same thing, but depending on what you're doing, it might be better.
2021-07-19 11:15:19	dsal	[22:13:18] I use <> often, I just don't use ++.  You can use ++ if you like.  I was just commenting on the precedence.
2021-07-19 11:15:19	dsal	[22:14:41] I've got logging functions like `logErrorL, logInfoL, logDbgL :: (Foldable f, MonadLogger m) => f T.Text-> m ()` which are helpful when I want to log a list of Texts.  e.g., `logInfoL = logInfoN . fold`
2021-07-19 11:15:19	lechner	[22:27:12] are those two lines acceptable for a newbie?  https://dpaste.org/sqiW#L96,97
2021-07-19 11:15:19	dminuoso	[22:28:48] Looks fine.
2021-07-19 11:15:19	lechner	[22:29:12] thanks to everyone for your help!
2021-07-19 11:15:19	dminuoso	[22:29:22] The `nice 19` looks dubious though.
2021-07-19 11:15:19	lechner	[22:29:48] what should it look like?
2021-07-19 11:15:19	lechner	[22:31:08] I'm trying to do this:   https://salsa.debian.org/lintian/kickoff/-/blob/master/runner#L57
2021-07-19 11:15:19	lechner	[23:05:32] why do ++ and concat not do the same thing, please?
2021-07-19 11:15:19	int-e	[23:05:51] they have different types?
2021-07-19 11:15:19	geekosaur	[23:06:39] what do you mean by "not do the same thing"?
2021-07-19 11:15:19	geekosaur	[23:06:45] :t (++)
2021-07-19 11:15:19	lambdabot	[23:06:46] [a] -> [a] -> [a]
2021-07-19 11:15:19	int-e	[23:06:46] concat takes a list of lists (well, a traversable of lists, but let's simplify) and appends those; ++ takes two lists and appends them
2021-07-19 11:15:19	geekosaur	[23:06:58] :t concat
2021-07-19 11:15:19	lambdabot	[23:06:59] Foldable t => t [a] -> [a]
2021-07-19 11:15:19	int-e	[23:07:05] foldable, my bad
2021-07-19 11:15:19	int-e	[23:07:14] Why do we use "t" for a Foldable.
2021-07-19 11:15:19	lechner	[23:07:47] are they different when used with String?
2021-07-19 11:15:19	int-e	[23:07:55] (That's what misled me, though it shouldn't have.)
2021-07-19 11:15:19	geekosaur	[23:07:58] I think this may be ghc inferring a type and calling it "t" because that's the default
2021-07-19 11:15:19	int-e	[23:08:07] > concat ["a","b","c"]
2021-07-19 11:15:19	lambdabot	[23:08:09]  "abc"
2021-07-19 11:15:19	geekosaur	[23:08:09] lechner, a String is just a list of Char
2021-07-19 11:15:19	int-e	[23:08:11] > "a" ++ "b"
2021-07-19 11:15:19	lambdabot	[23:08:12]  "ab"
2021-07-19 11:15:19	int-e	[23:08:19] it's still a completely different type
2021-07-19 11:15:19	dsal	[23:08:37] Two things and a list of two things are not the same type.
2021-07-19 11:15:19	int-e	[23:08:58] You can rewrite  xs ++ ys  as  concat [xs,ys]  if you like.
2021-07-19 11:15:19	lechner	[23:09:22] that's what i meant. thanks!
2021-07-19 11:15:19	int-e	[23:09:27] (it may come at a small performance penalty)
2021-07-19 11:15:19	int-e	[23:09:34] (I haven't checked)
2021-07-19 11:15:19	lechner	[23:10:22] performance is a binary event here atm
2021-07-19 11:15:19	int-e	[23:11:55] Checked, evidently  concat [xs, ys]  gets rewritten to  xs ++ ys, so there's no difference.
2021-07-19 11:15:19	int-e	[23:12:10] (when compiling with ghc with optimizations enabled)
2021-07-19 11:15:19	int-e	[23:13:41] I don't know what "binary event" means.
2021-07-19 11:15:19	arahael	[23:13:44] The joy of a bit of early-morning haskell before work. :D
2021-07-19 11:15:19	beaky	[23:14:08] hello does ghc do whole program optimization like mlton 
2021-07-19 11:15:19	arahael	[23:14:24] It's _remarkable_ how one can get by with sloppy code in haskell: You can trivially and painlessly refactor it.  So nice.
2021-07-19 11:15:19	int-e	[23:15:18] beaky: no, it compiles modules separately, though there's inlining across modules for small functions.
2021-07-19 11:15:19	arahael	[23:17:27] int-e: There was this last year, though: https://www.patreon.com/posts/introducing-ghc-38173710  Has anything happened in that space since then or has it fizzled out?
2021-07-19 11:15:19	int-e	[23:18:45] I don't really know. I saw that there was some discussion on GRIN on here 2 hours ago...
2021-07-19 11:15:19	geekosaur	[23:19:43] there is apparently still some ongoing work but it hasn't been upstreamed and isn't yet usable in production
2021-07-19 11:15:19	int-e	[23:21:49] Or is that 26 hours ago, my client has no dates in the timestamp, and my feeling for time is all messed up
2021-07-19 11:15:19	arahael	[23:22:39] I'm personally a bit torn between thinking that that research is awesome - and or wishing that compilation took way less memory, even though memory doesn't seem to affect me because I never have less than 16 GB of RAM these days.
2021-07-19 11:15:19	geekosaur	[23:23:25] 26 hours ago more likely
2021-07-19 11:15:19	geekosaur	[23:23:37] was when I was in the discussion at least
2021-07-19 11:15:19	int-e	[23:24:18] cf. https://paste.debian.net/hidden/d3d82af6/
2021-07-19 11:15:19	int-e	[23:25:17] Yes, it was 26 hours ago. I still don't know whether it's related to that patreon thing. The topic clearly overlaps heavily.
2021-07-19 11:15:19	int-e	[23:26:10] (don't bookmark that paste, I set it to expire in 24h)
2021-07-19 11:15:19	geekosaur	[23:27:15] people can get it from ircbrowse if they want it :)
2021-07-19 11:15:19	geekosaur	[23:27:40] admittedly it'd help if it were searchable, but can't have everything
2021-07-19 11:15:19	geekosaur	[23:29:29] that was the one I was talking about, at least. don't know with 100% certainty it was the one dmj` intended, but it seemed to match up
2021-07-19 11:15:19	dminuoso	[00:18:21] Mmm. Im doing an URL style percent encoding/decoding of bytestring. I have two Word8 and want to prepend them to a ByteString, what's the efficient way to do this here?
2021-07-19 11:15:19	Axman6	[00:19:32] I would have a look at the bytestring-base16 code to find efficient ways to do things. otherwise I'd probably just say use a builder if it's likely you'll be doing more appends/prepends
2021-07-19 11:15:19	dminuoso	[00:21:33] I was thinking along the lines of: let dualton c1 c2 = unsafeCreate 2 $ \p -> poke p c1 >> poke (p `plusPtr` 1) c2 in dualton x1 x2 <> rest
2021-07-19 11:15:19	dminuoso	[00:21:45] Axman6: Mmm.
2021-07-19 11:15:19	dminuoso	[00:22:10] Ah, yes. Perhaps that is the better way indeed
2021-07-19 11:15:19	Axman6	[00:22:57] if you know exactly how large the result will be there's definitely tricks to make it fast, but usually if the question is ')how do I construct a bytestring from parts" the answer is Builder
2021-07-19 11:15:19	dminuoso	[00:26:36] Mmm, so on the outside Im inside conduit. Maybe there's a way to stream a bytestring builder into a conduit
2021-07-19 11:15:19	dminuoso	[00:27:21] Apparently not, but that's fine
2021-07-19 11:15:19	dminuoso	[00:29:46] @tell burnsidesLlama It just occured to me, that the generalization you are looking for is `scanl` or `scanr`.
2021-07-19 11:15:19	lambdabot	[00:29:46] Consider it noted.
2021-07-19 11:15:19	Axman6	[00:36:38] dminuoso: using https://hackage.haskell.org/package/bytestring-0.11.1.0/docs/Data-ByteString-Builder-Internal.html#t:ChunkIOStream you can efficiently stream a bytestring
2021-07-19 11:15:19	Axman6	[00:41:38] ... maybe, actually struggling to see how to take in Builders and then use that
2021-07-19 11:15:19	dmj`	[02:40:46] int-e: there is a patreon for GRIN work yes
2021-07-19 11:15:19	dmj`	[02:41:13] Some of what I said is related to that
2021-07-19 11:15:19	GeorgeArmani	[03:11:30] Can someone help me understand this error message ?
2021-07-19 11:15:19	GeorgeArmani	[03:11:32] any' :: (a -> Bool) -> a -> Bool
2021-07-19 11:15:19	GeorgeArmani	[03:11:32] any' f xs = foldl step False xs where
2021-07-19 11:15:19	GeorgeArmani	[03:11:33]     step acc (y:ys)
2021-07-19 11:15:19	GeorgeArmani	[03:11:33]         | f y = True
2021-07-19 11:15:19	GeorgeArmani	[03:11:34]         | otherwise = acc
2021-07-19 11:15:19	GeorgeArmani	[03:11:41] Fold.hs:52:30: error:
2021-07-19 11:15:19	GeorgeArmani	[03:11:42]     • Occurs check: cannot construct the infinite type: a ~ t0 [a]
2021-07-19 11:15:19	GeorgeArmani	[03:11:42]     • In the third argument of ‘foldl’, namely ‘xs’
2021-07-19 11:15:19	GeorgeArmani	[03:11:43]       In the expression: foldl step False xs
2021-07-19 11:15:19	GeorgeArmani	[03:11:43]       In an equation for ‘any'’:
2021-07-19 11:15:19	GeorgeArmani	[03:11:44]           any' f xs
2021-07-19 11:15:19	GeorgeArmani	[03:11:44]             = foldl step False xs
2021-07-19 11:15:19	GeorgeArmani	[03:11:45]             where
2021-07-19 11:15:19	GeorgeArmani	[03:11:45]                 step acc (y : ys)
2021-07-19 11:15:19	GeorgeArmani	[03:11:46]                   | f y = True
2021-07-19 11:15:19	GeorgeArmani	[03:11:46]                   | otherwise = acc
2021-07-19 11:15:19	geekosaur	[03:13:31] please don't paste directly into the channel like that
2021-07-19 11:15:19	Axman6	[03:13:32] @where paste
2021-07-19 11:15:19	lambdabot	[03:13:32] Help us help you: please paste full code, input and/or output at e.g. https://paste.tomsmeding.com
2021-07-19 11:15:19	geekosaur	[03:14:59] but it's telling you that 'a' cannot at the same time be a Foldable over a list and an element of that list
2021-07-19 11:15:19	GeorgeArmani	[03:15:15] https://paste.tomsmeding.com/qsfDJyUC#file-1
2021-07-19 11:15:19	Axman6	[03:15:16] yeah take a close look at the type you've given any'
2021-07-19 11:15:19	geekosaur	[03:15:18] think about your type signature
2021-07-19 11:15:19	geekosaur	[03:18:15] it may also be helpful to give step the type signature you think it should have
2021-07-19 11:15:19	GeorgeArmani	[03:39:44] I'm really having a tough time sorting that out
2021-07-19 11:15:19	geekosaur	[03:41:22] what does the type "a" in your type signature represent?
2021-07-19 11:15:19	geekosaur	[03:41:49] remember that it's going to be the same type everywhere in that signature
2021-07-19 11:15:19	GeorgeArmani	[03:43:29] I think it should be a list every time its used?
2021-07-19 11:15:19	geekosaur	[03:43:48] is it in (a -> Bool)?
2021-07-19 11:15:19	GeorgeArmani	[03:47:05] ahhhh so should it be ------- any' :: (a -> Bool) -> [a] -> Bool
2021-07-19 11:15:19	geekosaur	[03:47:15] yes
2021-07-19 11:15:19	geekosaur	[03:49:09] I suspect from your original error that this will only fix one problem, though
2021-07-19 11:15:19	GeorgeArmani	[03:49:25] correct
2021-07-19 11:15:19	GeorgeArmani	[03:50:45] In fact, I had that type signature originally but changed it to deal with this error https://paste.tomsmeding.com/ntGaaQnX
2021-07-19 11:15:19	GeorgeArmani	[03:51:42] Wait just putting [xs] like that worked 
2021-07-19 11:15:19	GeorgeArmani	[03:52:05] https://paste.tomsmeding.com/qirkhcRw
2021-07-19 11:15:19	GeorgeArmani	[03:52:10] Im not sure why though
2021-07-19 11:15:19	GeorgeArmani	[03:55:08] I get it now. Thanks Geekosaur. 
2021-07-19 11:15:19	geekosaur	[03:55:53] yeh, you are splitting the list in step as well when you don't need to because fold already is
2021-07-19 11:15:19	geekosaur	[03:56:25] so it thinks you need a list of lists. that's why I suggested putting a type signature on step
2021-07-19 11:15:19	GeorgeArmani	[03:56:37] exactly, I deleted calling head in step and removed the [] around xs
2021-07-19 11:15:19	GeorgeArmani	[04:04:03] Sorry for asking so many questions. I am confused about the type signature for step.
2021-07-19 11:15:19	GeorgeArmani	[04:04:41] I thought it would be Bool -> a -> Bool , but it is throwing an error at compile
2021-07-19 11:15:19	h98	[04:07:51] what's your code right now? that type signature sounds right to me
2021-07-19 11:15:19	GeorgeArmani	[04:09:13] https://paste.tomsmeding.com/kU1zB95f
2021-07-19 11:15:19	geekosaur	[04:09:30] oh, right, this requires ScopedTypeVariables to specify a signature
2021-07-19 11:15:19	geekosaur	[04:10:30] otherwise the a you specify in the type signature for step is unrelated to the one specified for any', but that breaks f
2021-07-19 11:15:19	GeorgeArmani	[04:10:31] Ok ill look into that
2021-07-19 11:15:19	geekosaur	[04:11:11] sometimes ghc is annoying that way
2021-07-19 11:15:19	h98	[04:11:22] should compile as-is if you delete the type signature now
2021-07-19 11:15:19	GeorgeArmani	[04:11:42] ahhhh ok. That is a little frustrating. 
2021-07-19 11:15:19	GeorgeArmani	[04:12:04] yeah h98 thank you. I just wanted to make sure that I understood what was going on fully.
2021-07-19 11:15:19	geekosaur	[04:12:04] yes, but I suggested adding the type signature, having forgotten it wouldn';t work :(
2021-07-19 11:15:19	GeorgeArmani	[04:12:42] All good :) . Appreciate the help, Geekosaur.
2021-07-19 11:15:19	lechner	[04:52:56] Hi, is it possible to catch decompression errors from LZMA here?   https://salsa.debian.org/lintian/kickoff/-/blob/master/Collect.hs#L82
2021-07-19 11:15:19	dsal	[05:10:48] lechner: It uses MonadFail.  You could use exceptions
2021-07-19 11:15:19	dsal	[05:10:52] @package exceptions
2021-07-19 11:15:19	lambdabot	[05:10:53] https://hackage.haskell.org/package/exceptions
2021-07-19 11:15:19	Hecate	[05:24:13] o/
2021-07-19 11:15:19	Hecate	[05:24:26] I'm trying to better understand how I can use Comonad in my programs
2021-07-19 11:15:19	Hecate	[05:25:04] I've seen *one* usage of Comonad in a codebase, in which it acted as a priviledged accessor, like https://twitter.com/TechnoEmpress/status/1416992128643776513
2021-07-19 11:15:19	Hecate	[05:26:04] but I think the usecase really stops at running "whatever <- asks extract"
2021-07-19 11:15:19	Hecate	[05:27:01] But then it feels more like I've created one more indirection
2021-07-19 11:15:19	Hecate	[05:27:54] that being said if I need more polymorphism on the 'Comonad r' this could be good
2021-07-19 11:15:19	lechner	[05:32:05] dsal: thanks!
2021-07-19 11:15:19	Guest95	[05:43:02] Hello! I currently use Spacemacs as my Haskell code editor. What code editor would you recommend? Is Yi worth looking in to?
2021-07-19 11:15:19	***	Playback Complete.
2021-07-19 11:15:26	--	Channel created on Sun, 25 Apr 2021 01:04:39
2021-07-19 11:16:16	Hecate	Guest95: Yi was an interesting project but I fear it may be dead these days
2021-07-19 11:16:31	-->	paolino (~paolo@84.33.141.5) has joined #haskell
2021-07-19 11:16:32	Hecate	Guest95: I use neovim + lua plugins and config (if you're allergic to too much VimL)
2021-07-19 11:16:33	-->	Maxdamantus (~Maxdamant@user/maxdamantus) has joined #haskell
2021-07-19 11:20:40	<--	cjb (~cjb@user/cjb) has quit (Quit: rcirc on GNU Emacs 28.0.50)
2021-07-19 11:23:14	-->	raehik (~raehik@cpc95906-rdng25-2-0-cust156.15-3.cable.virginm.net) has joined #haskell
2021-07-19 11:24:11	<--	Null_A (~null_a@2601:645:8700:2290:5577:9a94:3b66:c39d) has quit (Read error: Connection reset by peer)
2021-07-19 11:25:07	<--	dre (~dre@2001:8003:c932:c301:e078:5df6:bd54:b22a) has quit (Quit: Leaving)
2021-07-19 11:26:48	<--	Guest95 (~Guest95@50.47.115.102) has quit (Quit: Client closed)
2021-07-19 11:26:50	lechner	Thanks for the pointer to yi. I may have found a minimal replacement for things like commit messages for mg, which is even less maintained and can't do Unicode
2021-07-19 11:30:59	-->	Erutuon (~Erutuon@user/erutuon) has joined #haskell
2021-07-19 11:33:17	<--	MQ-17J (~MQ-17J@8.21.10.15) has quit (Ping timeout: 268 seconds)
2021-07-19 11:35:23	<--	eggplantade (~Eggplanta@108-201-191-115.lightspeed.sntcca.sbcglobal.net) has quit (Remote host closed the connection)
2021-07-19 11:35:47	-->	eggplantade (~Eggplanta@108-201-191-115.lightspeed.sntcca.sbcglobal.net) has joined #haskell
2021-07-19 11:45:19	--	irc: disconnected from server
2021-07-19 11:45:31	-->	amanr (~therojjha@20.204.87.0) has joined #haskell
2021-07-19 11:45:31	--	Topic for #haskell is "https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org | Paste code/errors: https://paste.tomsmeding.com | tunes.org-style logging should be coming soon | Logs: https://ircbrowse.tomsmeding.com/browse/lchaskell"
2021-07-19 11:45:31	--	Topic set by geekosaur (~geekosaur@xmonad/geekosaur) on Mon, 14 Jun 2021 05:16:14
2021-07-19 11:45:31	--	Channel #haskell: 696 nicks (1 op, 0 voices, 695 normals)
2021-07-19 11:45:31	***	Buffer Playback...
2021-07-19 11:45:31	davean	[17:14:22] oumolu has no concept of the code its formating
2021-07-19 11:45:31	davean	[17:14:29] it can only consider syntax, not content
2021-07-19 11:45:31	davean	[17:14:42] so every human element is thrown out the window
2021-07-19 11:45:31	dsal	[17:14:43] They took a lot from elm which prioritized reading diffs over reading code.
2021-07-19 11:45:31	dsal	[17:15:35] IMO, fixing the stuff that renders diffs would be a saner approach than making all the code harder to read.
2021-07-19 11:45:31	geekosaur	[17:18:23] --make hasn't been needed for a while now (since ghc 6.12 iirc)
2021-07-19 11:45:31	dsal	[17:19:03] I lose most of my excitement about elm, dhall, etc... when I have to do things their One True Way™.  I passed a thing I wrote in elm through their standard formatter and got this: https://www.irccloud.com/pastebin/lIpmTDCu/format.elm
2021-07-19 11:45:31	geekosaur	[17:19:15] I'm a little surprised it hasn't been deprecated
2021-07-19 11:45:31	dsal	[17:19:32] I've not used ormolu much myself, but I expect I'll be seeing more such doublings where I can't read a function on my screen anymore.
2021-07-19 11:45:31	monochrom	[17:22:06] In comp.lang.functional there was once a detractor who praised imperative programming for "one thing at a time, one concept per line" and attacked functional programming for the opposite.
2021-07-19 11:45:31	monochrom	[17:22:29] You have just shown an answer similar to mine :)
2021-07-19 11:45:31	davean	[17:22:55] lol. I've seen a lot of mixed concerns in imperative programming
2021-07-19 11:45:31	maerwald	[17:23:30] if you do imperative programming with shared mutability tamed, then that is workable
2021-07-19 11:45:31	monochrom	[17:25:03] My reverse thinking is that whoever imposed that oversplitting style must have been an imperative bonehead who couldn't even understand in C "x = cos(t); y = sin(t);" if I wrote that as one line.
2021-07-19 11:45:31	geekosaur	[17:25:24] or a Python programmer
2021-07-19 11:45:31	dsal	[17:25:54] monochrom: please state your variable names in the form of complete sentences.
2021-07-19 11:45:31	monochrom	[17:26:12] haha yikes
2021-07-19 11:45:31	davean	[17:26:27] the_variable_x
2021-07-19 11:45:31	geekosaur	[17:26:29] I haven't programmed cobol in decades
2021-07-19 11:45:31	dsal	[17:26:29] I got in an argument with someone who said he had some kind of neurodivergence and couldn't possible comprehend code that used such short variable names.
2021-07-19 11:45:31	davean	[17:26:30] Done?
2021-07-19 11:45:31	monochrom	[17:26:45]       COMPUTE COSINE OF T INTO X
2021-07-19 11:45:31	monochrom	[17:26:55] (let's go COBOL for complete sentences)
2021-07-19 11:45:31	monochrom	[17:28:23]       COMPUTE COSINE OF T INTO THE_VAR_THAT_WOULD_BE_COSINE_OF_T
2021-07-19 11:45:31	monochrom	[17:28:37] (inspired by the movie name "the kid that would be king" :) )
2021-07-19 11:45:31	monochrom	[17:29:05] "lady of the trig functions, please return the cosine of t"
2021-07-19 11:45:31	monochrom	[17:29:11] OK I'll stop.
2021-07-19 11:45:31	oso	[17:29:11] needs more "Please"
2021-07-19 11:45:31	davean	[17:29:25] no, should be worded must
2021-07-19 11:45:31	davean	[17:29:29] we want to have confidence in it
2021-07-19 11:45:31	oso	[17:30:03] i was referencing INTERCAL, which wouldn't compile if you didn't say "please" enough but also wouldn't compile if you said it too much because you were being a suckup
2021-07-19 11:45:31	davean	[17:30:51] Yes but a function like "please_compute_the_cosine_of_t" might not
2021-07-19 11:45:31	davean	[17:30:56] you can't rely on your code being agreeable!
2021-07-19 11:45:31	oso	[17:31:26] true; on the contrary, i find my code to be most disagreeable
2021-07-19 11:45:31	dsal	[17:40:04] In go, we use Must as a prefix for things that will panic if they don't work.
2021-07-19 11:45:31	davean	[17:40:34] Ugh, like usuall go gets it wrong
2021-07-19 11:45:31	davean	[17:40:45] "must" should make it a total function that matches the specification
2021-07-19 11:45:31	davean	[17:41:05] What part of "must" did they understand?
2021-07-19 11:45:31	monochrom	[17:41:18] mustHead (x:xs) = x  \∩/
2021-07-19 11:45:31	davean	[17:42:00] monochrom: thats exactly the sort of thing "must" must fix!
2021-07-19 11:45:31	monochrom	[17:42:20] mustFix f = let x = f x in x
2021-07-19 11:45:31	monochrom	[17:44:14] OTOH perhaps "if they don't work" means "you can assume it works, only a system bug would be a reason why it doesn't, which is not your responsibility"
2021-07-19 11:45:31	davean	[17:45:42] lets just always assume it works.
2021-07-19 11:45:31	monochrom	[17:45:43] OTOOH under multiple-world non-determinism and the convention "ignore those worlds that don't survive", the function works in all surviving worlds, so the modal quantifier "must" is right.
2021-07-19 11:45:31	davean	[17:45:57] Yah, now you're getting it
2021-07-19 11:45:31	monochrom	[17:46:03] :)
2021-07-19 11:45:31	davean	[17:47:11] mustSort = randomizeOrder
2021-07-19 11:45:31	dsal	[17:47:47] must sort eventually
2021-07-19 11:45:31	davean	[17:48:06] dsal: No, quantum bogosort sorts in O(n)
2021-07-19 11:45:31	dsal	[17:48:39] I've been meaning to get a new computer for a while.  Might as well be a quantum one.
2021-07-19 11:45:31	davean	[17:49:13] So, launch missiles is in IO, whats the monad of universes?
2021-07-19 11:45:31	monochrom	[17:49:43] []
2021-07-19 11:45:31	monochrom	[17:50:22] Dr. Strange and the LogicT monad transformer of madness
2021-07-19 11:45:31	h98	[17:51:08] dumb question, is there a way to avoid the inner parentheses in the type application "@(f (g a b))"? something like @(f $ g a b) on the type-level?
2021-07-19 11:45:31	monochrom	[17:51:44] No.
2021-07-19 11:45:31	dmj`	[17:52:33] type Foo f g a b = f (g a b) -- @(Foo f g a b) ... maybe?
2021-07-19 11:45:31	h98	[17:54:21] oooh
2021-07-19 11:45:31	davean	[17:54:39] I guess the Haskellish form would be "sort = must (\xs -> all id . map (\(x,y) -> x <= y) . zip xs $ tail xs) randomizeOrder 
2021-07-19 11:45:31	h98	[17:54:40] yes duh, that works...thanks
2021-07-19 11:45:31	guest61	[18:03:38] update message is Nothing
2021-07-19 11:45:31	h98	[18:05:23] I can't get over that trick by the way davean, no more nested parentheses in any of my type expressions!
2021-07-19 11:45:31	guest61	[18:05:35] update message is Nothing
2021-07-19 11:45:31	davean	[18:05:36] Yu mean dmj`?
2021-07-19 11:45:31	h98	[18:05:55] sorry yes, dmj` hah
2021-07-19 11:45:31	davean	[18:06:06] *I'd* nest the parens because its less indirection :-p
2021-07-19 11:45:31	dmj`	[18:06:35] "One weird trick to remove your parentheses... lisp programmers *hate* him"
2021-07-19 11:45:31	davean	[18:06:36] (Not if the alias had semantics weight of its own though)
2021-07-19 11:45:31	guest61	[18:58:52] update message is Nothing
2021-07-19 11:45:31	monochrom	[19:03:47] guest61: What is all that about?
2021-07-19 11:45:31	guest61	[19:04:12] update message is Nothing
2021-07-19 11:45:31	tom__	[19:12:25] So if you are modelling a stochastic process as a comonad how do you get the randomness for each step if IO is a monad
2021-07-19 11:45:31	dsal	[19:13:09] Guest9: update message is (Just Quit)
2021-07-19 11:45:31	 *	dsal [19:13:32] is too late and missed
2021-07-19 11:45:31	davean	[19:18:07] tom__: or randomness is a source for the cell
2021-07-19 11:45:31	tom__	[19:19:17] davean: Right but you can't product a cell without being in IO then?
2021-07-19 11:45:31	tom__	[19:19:20] produce
2021-07-19 11:45:31	davean	[19:20:11] tom__: I mean, you don't need to be in IO to step a pseudo random function
2021-07-19 11:45:31	davean	[19:20:30] You can do all sorts of things
2021-07-19 11:45:31	davean	[19:20:48] the particular one I'd start with is taking one seed value, and splitting a prf to all the "cells"
2021-07-19 11:45:31	dsal	[19:22:59] > randomRs (1, 11)  $ mkStdGen 42
2021-07-19 11:45:31	lambdabot	[19:23:00]  [1,8,1,3,2,8,5,3,6,10,9,3,10,11,9,2,1,11,3,3,9,3,3,9,1,7,9,8,6,7,4,2,7,1,3,2...
2021-07-19 11:45:31	tom__	[19:28:18] Does the Random package allow sampling from a normal distribution?
2021-07-19 11:45:31	geekosaur	[19:28:53] yes, as of 1.2
2021-07-19 11:45:31	tom__	[19:29:02] thanks
2021-07-19 11:45:31	davean	[19:29:19] tom__: I mean it provides random numbers, sampling from is a way to *use* randomness
2021-07-19 11:45:31	tom__	[19:29:19] Does "Constructs a StdGen deterministically." mean - not randomly?
2021-07-19 11:45:31	davean	[19:29:58] Uh, the construction is never random persay
2021-07-19 11:45:31	geekosaur	[19:29:59] if the input you give it is deterministic then yes
2021-07-19 11:45:31	dsal	[19:30:00] > randomRs (1, 11)  $ mkStdGen 42 -- tom__ yes, it means it'll reproduce the same sequence
2021-07-19 11:45:31	lambdabot	[19:30:01]  [1,8,1,3,2,8,5,3,6,10,9,3,10,11,9,2,1,11,3,3,9,3,3,9,1,7,9,8,6,7,4,2,7,1,3,2...
2021-07-19 11:45:31	tom__	[19:31:21] Ah ok so mkStdGen enables "decoupling" between IO and your computation
2021-07-19 11:45:31	dsal	[19:31:47] Yes.  There are MonadIO variants in there as well.
2021-07-19 11:45:31	geekosaur	[19:31:58] you can also get a randomly generated seed from IO and do the rest purely
2021-07-19 11:45:31	tom__	[19:32:11] aha thanks
2021-07-19 11:45:31	tom__	[19:32:47] by purely do you mean -  not with IO?
2021-07-19 11:45:31	davean	[19:32:48] Note there are plenty of monadic forms that aren't IO also, for prfs
2021-07-19 11:45:31	geekosaur	[19:33:22] yes
2021-07-19 11:45:31	davean	[19:33:52] I'm not really a fan of the 1.2 changes :/
2021-07-19 11:45:31	davean	[19:34:21] tom__: if you want good sampling, see random-fu and such BTW
2021-07-19 11:45:31	davean	[19:34:31] distributions is seperate from random numbers
2021-07-19 11:45:31	geekosaur	[19:34:57] on the one hand it cleaned up my use of the mersenne twister a bit; on the other I found 1.1 much easier
2021-07-19 11:45:31	geekosaur	[19:35:17] gripping hand I didn't have to fake normal distributions any more
2021-07-19 11:45:31	davean	[19:35:31] geekosaur: I don't think the 1.2 design is valid :/ I think theres some actual contradictions in its design, but thats far too long a discussion for here and now
2021-07-19 11:45:31	davean	[19:36:13] I'm actually rather upset about 1.2
2021-07-19 11:45:31	davean	[19:36:27] Not that 1.1 was great
2021-07-19 11:45:31	tom__	[19:38:50] I'm using MWC-probability 
2021-07-19 11:45:31	mdunnio	[19:39:53] hello! is anyone aware of any up-to-date guides on how to use LLVM backend with GHC? I'm looking to utilize GHC 8.10.5's first class support for M1, but I'm not exactly sure where to get started.
2021-07-19 11:45:31	geekosaur	[19:41:18] using it is just doing "ghc-options: -fllvm" in the cabal file. but I think 8.10.5 is known buggy
2021-07-19 11:45:31	mdunnio	[19:41:44] oh interesting. ok
2021-07-19 11:45:31	mdunnio	[19:42:12] I'll try that out
2021-07-19 11:45:31	geekosaur	[19:42:26] and true first class (-fasm) support is supposed to come in 9.2.1
2021-07-19 11:45:31	geekosaur	[19:42:55] there's a prerelease available in ghcup but it has some known bugs
2021-07-19 11:45:31	davean	[19:43:22] Yah, on one hand llvm is kinda first class, on the other, LLVM isn't a general system and we don't fit its preconception of being C
2021-07-19 11:45:31	davean	[19:43:30] So it'll never be quite right to use LLVM
2021-07-19 11:45:31	davean	[19:43:48] You'll always eat a penalty of LLVM not being a general system
2021-07-19 11:45:31	mdunnio	[19:44:42] penalty as in performance, or just support generally?
2021-07-19 11:45:31	geekosaur	[19:44:56] both
2021-07-19 11:45:31	davean	[19:44:57] More the former, but there CAN be a few issues with the later
2021-07-19 11:45:31	davean	[19:45:07] LLVM is very much a C IR
2021-07-19 11:45:31	davean	[19:45:20] It claims to be general, but frankly, thats wishful thinking
2021-07-19 11:45:31	geekosaur	[19:45:22] llvm doesn't understand the cps-encoded code ghc emits and pessimizes it
2021-07-19 11:45:31	davean	[19:45:26] it has a ton of assumptions baked in at hte bottom
2021-07-19 11:45:31	Rembane	[19:45:43] So every language that looks like C if you squint works for LLVM?
2021-07-19 11:45:31	davean	[19:45:57] Rembane: Close, and LLVM works more generally than that, just not well
2021-07-19 11:45:31	davean	[19:46:10] LLVM can't think some normal thoughts, and never will be able to
2021-07-19 11:45:31	mdunnio	[19:46:13] I see
2021-07-19 11:45:31	Rembane	[19:46:25] davean: Got it. Doesn't sound too bad if your needs are C et al
2021-07-19 11:45:31	davean	[19:46:26] Theres ways to make them "work" because the turing tarpit, but that doesn't mean they work well
2021-07-19 11:45:31	davean	[19:46:37] Rembane: Yah, its actually great for that
2021-07-19 11:45:31	davean	[19:46:48] Rembane: I mean you make sometihng better for one thing, usually you make it worse for another
2021-07-19 11:45:31	davean	[19:46:58] the only issue I see here is the claim that its general, which it just clearly isn't
2021-07-19 11:45:31	davean	[19:47:16] but! It works pretty well for GHC for most thing
2021-07-19 11:45:31	davean	[19:47:22] so, go use it
2021-07-19 11:45:31	davean	[19:47:31] Its actually the best option for a few specific cases
2021-07-19 11:45:31	davean	[19:47:38] and you can do funky stuff to use it only where it is the best ...
2021-07-19 11:45:31	davean	[19:48:05] So like, its good to have, I'm not trying to bash it, just explain what one might feel about "first class ness"
2021-07-19 11:45:31	mdunnio	[19:48:36] yeah, to be fair, I have a pretty broad interpretation of what "first class support" even means
2021-07-19 11:45:31	Rembane	[19:48:58] davean: Totally, it's trade offs all the way down. 
2021-07-19 11:45:31	mdunnio	[19:49:07] at this point, I'm willing to take "does it work at all?"
2021-07-19 11:45:31	davean	[19:49:14] mdunnio: ok!
2021-07-19 11:45:31	davean	[19:49:16] so, it does work!
2021-07-19 11:45:31	davean	[19:50:14] mdunnio: So my understanding is that the nix stuff is still the best option
2021-07-19 11:45:31	davean	[19:51:02] (I uh, keep an arms length from Apple, I just uh, make sure we have CI for it)
2021-07-19 11:45:31	davean	[19:51:56] Talking of which, yah rossetta, uh, don't run a ton of x86 binaries.
2021-07-19 11:45:31	mdunnio	[19:53:05] fair
2021-07-19 11:45:31	mdunnio	[19:53:10] yeah, that's the plan
2021-07-19 11:45:31	davean	[19:53:38] yah, its a problem (I don't know if you know, but it doesn't clear the cache, so you'll run out of disk space and be stuck unless you disable SIP)
2021-07-19 11:45:31	mdunnio	[19:53:46] I haven't actually worked much with nix yet, might be time to experiment
2021-07-19 11:45:31	davean	[19:54:19] mdunnio: So, I'm not sure they want me to refer you, but the bigest expert I know in this area is moritz angermann
2021-07-19 11:45:31	davean	[19:54:31] I think we're due for a writeup on the state of M1 stuff
2021-07-19 11:45:31	davean	[19:54:41] It would be a public service
2021-07-19 11:45:31	mdunnio	[19:55:26] I recall moritz wrote up a bunch about cross-compiling for ARM. I did some rpi work back a year or so ago
2021-07-19 11:45:31	davean	[19:56:01] I'll admit I was taking care of a lot of the mac stuff and then moritz stepped in and not being a mac user I disowned it as fast as possible
2021-07-19 11:45:31	mdunnio	[19:56:23] seems like the appropriate time to pass the torch
2021-07-19 11:45:31	mdunnio	[19:56:51] ok, I'm going to experiment a little bit and see if I can get somewhere. I appreciate the help
2021-07-19 11:45:31	davean	[19:57:02] Someone needed to do it, but better it be someone who loves it and has base skills for it
2021-07-19 11:45:31	davean	[19:59:01] Hum, I failed to full say what I should have above - which is that the CI config is where that knowlege should be accessible
2021-07-19 11:45:31	davean	[19:59:04] well I'm a bad helper
2021-07-19 11:45:31	 *	sm [20:29:07] wonders why the above thread jumped tracks from LLVM to apple .. do these go together ?
2021-07-19 11:45:31	sm	[20:29:43] and , #ghc is also a good source of info
2021-07-19 11:45:31	davean	[20:31:47] sm: it was about Apple
2021-07-19 11:45:31	geekosaur	[20:31:49] sm: M1 == Apple Silicon
2021-07-19 11:45:31	davean	[20:31:55] the point of LLVM there was to get M1 support
2021-07-19 11:45:31	davean	[20:32:08] which we get via LLVM or the native code gen, the native code gen isn't until 9.2 tohugh
2021-07-19 11:45:31	zangi	[20:32:35] does laziness consume more memory than strict evaluation?
2021-07-19 11:45:31	davean	[20:32:45] zangi: no, sometimes far less
2021-07-19 11:45:31	dminuoso	[20:32:46] Yes. No.
2021-07-19 11:45:31	zangi	[20:33:40] what about the thunks?
2021-07-19 11:45:31	dminuoso	[20:33:42] zangi: In order to provide lazyness, the lazy expression has to have some kind of memory representation. That costs allocation and indirection. 
2021-07-19 11:45:31	davean	[20:33:44] zangi: Theres a few cases where it uses more, the main one is special cased in the GC
2021-07-19 11:45:31	davean	[20:34:07] zangi: whats smaller, the infinite list, or the thunk [1..]?
2021-07-19 11:45:31	dminuoso	[20:34:11] zangi: But this is usually offset having low residency when working on large data.
2021-07-19 11:45:31	dminuoso	[20:34:45] I think the fundamental problem is that "memory consumption" is not something you can put as a single number metric.
2021-07-19 11:45:31	dminuoso	[20:37:44] For instance: Your program might process a 20TiB data set but have only 50MiB of memory residency at any given time.
2021-07-19 11:45:31	dminuoso	[20:38:39] But this could still have a lot of allocations internally
2021-07-19 11:45:31	dminuoso	[20:39:22] Lazyness also produces a level of indirection, which might hurt locality 
2021-07-19 11:45:31	davean	[20:40:10] or it can create locality
2021-07-19 11:45:31	lechner	[20:40:46] Hi, why are the dolla signs needed in these two lines, please?    https://dpaste.org/41S0#L94,95
2021-07-19 11:45:31	dminuoso	[20:41:03] lechner: They are not needed.
2021-07-19 11:45:31	dminuoso	[20:41:17] lechner: You can also use parens to associate the right hand side of it.
2021-07-19 11:45:31	dminuoso	[20:41:31] host $ scheduler config is equivalent to: host (schedular config)
2021-07-19 11:45:31	lechner	[20:41:42] can i use map, too?
2021-07-19 11:45:31	lechner	[20:43:47] dminuoso: I get the following errors when I take out the dollar signs    https://dpaste.org/mM0q
2021-07-19 11:45:31	dminuoso	[20:44:10] lechner: Like I said.
2021-07-19 11:45:31	dsal	[20:44:16] Does anyone know how to do something interesting with Control.Monad.Trans.Select ?    There doesn't seem to be much written about it.
2021-07-19 11:45:31	dminuoso	[20:44:21] `host $ scheduler config` is equivalent to `host (scheduler config)
2021-07-19 11:45:31	lechner	[20:44:50] okay, why are the parentheses needed, please?
2021-07-19 11:45:31	davean	[20:44:56] lechner: to parse it
2021-07-19 11:45:31	geekosaur	[20:45:09] $ is "backwards parentheses
2021-07-19 11:45:31	lechner	[20:45:15] that i know
2021-07-19 11:45:31	lechner	[20:45:35] i think it's a (slightly) higher level question
2021-07-19 11:45:31	davean	[20:45:40] lechner: so things (sorta) group to the left by default
2021-07-19 11:45:31	geekosaur	[20:45:42] so if you remove a $ you usually have to insert the parenheses it was replacing. here, for (scheduler config)
2021-07-19 11:45:31	davean	[20:45:52] lechner: you need to put it into the grammer as a group, not seperate things
2021-07-19 11:45:31	lechner	[20:46:03] my JSON declarations are not strict
2021-07-19 11:45:31	davean	[20:46:22] WHo said anything about strictness?
2021-07-19 11:45:31	davean	[20:46:53] This is about grammar
2021-07-19 11:45:31	monochrom	[20:47:04] The computer is not telepathic. You can't just write "f g h" and "t x y" and have the computer guess "oh you mean (f g) h and t (x y)".
2021-07-19 11:45:31	lechner	[20:47:37] not even when asking for a final result (printf) ?
2021-07-19 11:45:31	monochrom	[20:47:55] But there is a little bit of left associativity so "f g h" means "(f g) h".
2021-07-19 11:45:31	lechner	[20:48:24] why is that evaluated in my case, though?
2021-07-19 11:45:31	nf	[20:52:20] you usually have to evaluate things in order to print them
2021-07-19 11:45:31	davean	[20:53:32] lechner: it doesn't know printf is your final result even
2021-07-19 11:45:31	lechner	[20:53:36] but is that done inside the parentheses around the argument to printf?
2021-07-19 11:45:31	davean	[20:53:44] Its not "done inside"
2021-07-19 11:45:31	davean	[20:53:51] you're saying what is applied to what
2021-07-19 11:45:31	lechner	[20:54:38] i think i misunderstood partial application
2021-07-19 11:45:31	davean	[21:02:30] Definition is not execution
2021-07-19 11:45:31	davean	[21:02:52] lechner: consider the option of doign that like with (.)
2021-07-19 11:45:31	davean	[21:02:58] *line
2021-07-19 11:45:31	maerwald	[21:04:47] monochrom: wingman can guess what you mean, haha
2021-07-19 11:45:31	maerwald	[21:05:02] if your types are correct, that is
2021-07-19 11:45:31	maerwald	[21:06:36] now you just need something to guess the types for you
2021-07-19 11:45:31	maerwald	[21:07:16] and then something that guesses what the program should do
2021-07-19 11:45:31	maerwald	[21:07:26] we'll have no engineering problems to solve anymore
2021-07-19 11:45:31	 *	maerwald [21:07:43] goes packing
2021-07-19 11:45:31	dexterfoo	[21:08:24] can I convert a 'Text' value directly into an Int?
2021-07-19 11:45:31	Hecate	[21:11:07] % import Data.Text.Read
2021-07-19 11:45:31	yahb	[21:11:08] Hecate: 
2021-07-19 11:45:31	Hecate	[21:11:12] % decimal "3"
2021-07-19 11:45:31	yahb	[21:11:13] Hecate: ; <interactive>:223:1: error:; Ambiguous occurrence `decimal'; It could refer to; either `Data.Text.Read.decimal', imported from `Data.Text.Read'; or `Numeric.Lens.decimal', imported from `Numeric.Lens'
2021-07-19 11:45:31	Hecate	[21:11:19] fair enough
2021-07-19 11:45:31	Hecate	[21:11:20] so
2021-07-19 11:45:31	monochrom	[21:11:30] fib :: Int -> Int -> Int -> Int -> Int  let wingman guess what I want!
2021-07-19 11:45:31	Hecate	[21:11:32] Data.Text.Read.decimal "3"
2021-07-19 11:45:31	Hecate	[21:11:35] % Data.Text.Read.decimal "3"
2021-07-19 11:45:31	yahb	[21:11:35] Hecate: ; <interactive>:224:24: error:; * Couldn't match type `[Char]' with `Data.Text.Internal.Text'; Expected: Data.Text.Internal.Text; Actual: GHC.Base.String; * In the first argument of `Data.Text.Read.decimal', namely `"3"'; In the expression: Data.Text.Read.decimal "3"; In an equation for `it': it = Data.Text.Read.decimal "3"
2021-07-19 11:45:31	Hecate	[21:11:39] curse
2021-07-19 11:45:31	Hecate	[21:11:46] % import qualified Data.Text as T
2021-07-19 11:45:31	yahb	[21:11:46] Hecate: 
2021-07-19 11:45:31	Hecate	[21:11:52] % Data.Text.Read.decimal (T.pack "3")
2021-07-19 11:45:31	yahb	[21:11:53] Hecate: Right (3,"")
2021-07-19 11:45:31	Hecate	[21:11:57] % Data.Text.Read.decimal (T.pack "3x")
2021-07-19 11:45:31	yahb	[21:11:57] Hecate: Right (3,"x")
2021-07-19 11:45:31	Hecate	[21:12:08] dexterfoo: check this ^
2021-07-19 11:45:31	lechner	[21:13:53] davean: how do i use . in that line, please?
2021-07-19 11:45:31	maerwald	[21:15:08] sometimes I wonder why I even write documentation... all it does is confuse me 2 weeks later
2021-07-19 11:45:31	maerwald	[21:15:39] "I tried to figure out what this does, but didn't manage. But I wrote down my crippled thought regardless"
2021-07-19 11:45:31	dexterfoo	[21:15:45] Hecate: thanks!
2021-07-19 11:45:31	Hecate	[21:16:28] maerwald: because you don't know how to talk to yourself yet :P
2021-07-19 11:45:31	Hecate	[21:16:34] dexterfoo: you're welcome :)
2021-07-19 11:45:31	maerwald	[21:16:44] Hecate: preciousssss
2021-07-19 11:45:31	lechner	[21:20:32] Hi, in     printf "%s:%d" $ map ($ struct) [stringAccessor intAccessor]     does map work only when the return types are the same?
2021-07-19 11:45:31	lechner	[21:20:55] actually, there is a comma in there
2021-07-19 11:45:31	geekosaur	[21:21:05] all elements of a list must have the same type, yes
2021-07-19 11:45:31	lechner	[21:22:27] thanks. i could prosumably use 'show'
2021-07-19 11:45:31	geekosaur	[21:23:05] that's the usual way to do it, yes
2021-07-19 11:45:31	geekosaur	[21:23:14] don't forget to change the %d to %s
2021-07-19 11:45:31	lechner	[21:24:18] at some point, that tips the scale toward  putStrLn
2021-07-19 11:45:31	geekosaur	[21:24:30] yes
2021-07-19 11:45:31	dsal	[21:27:27] lechner: You could make a function that does the "%s:%d" part pretty easily and NamedFieldPuns or RecordWildCards would make it fairly short.
2021-07-19 11:45:31	lechner	[21:29:28] dsal: that sounds like a great idea! let's do that in one minute please.
2021-07-19 11:45:31	lechner	[21:30:04] meanwhile i am learning. why doesn't that work:   printf "Expecting scheduler on %s:%s.\n" $ map ($ scheduler config) [Connection.host, show . Connection.listen_port]
2021-07-19 11:45:31	lechner	[21:31:55] the point here is the partial application of 'show'
2021-07-19 11:45:31	[exa]	[21:32:01] lechner: what's the error?
2021-07-19 11:45:31	lechner	[21:32:32] https://paste.debian.net/1204829/
2021-07-19 11:45:31	geekosaur	[21:32:45] I think you have multiple problems there
2021-07-19 11:45:31	geekosaur	[21:33:12] for one, a list is not a collection of applications
2021-07-19 11:45:31	dsal	[21:33:16] lechner: A list isn't two arguments.
2021-07-19 11:45:31	dsal	[21:33:26] Or phrased how geekosaur said it.
2021-07-19 11:45:31	[exa]	[21:33:55] lechner: why still keep printf? (just curious)
2021-07-19 11:45:31	lechner	[21:34:19] just chewing on other things :)
2021-07-19 11:45:31	lechner	[21:34:54] [exa]: i am not so fond of ++ "[" ++ exa ++ "]" ++ ....
2021-07-19 11:45:31	geekosaur	[21:35:14] there is concat
2021-07-19 11:45:31	oso	[21:35:15] `concat`?
2021-07-19 11:45:31	dsal	[21:35:43] I don't use ++ in general, but I do use fold for logging.
2021-07-19 11:45:31	monochrom	[21:36:04] $ kills printf type inference. Seriously. Just don't use $.
2021-07-19 11:45:31	[exa]	[21:36:42] lechner: `concat [all, this, stuff]` is a widely used pattern. Esp good when combined with `intercalate`
2021-07-19 11:45:31	lechner	[21:37:01] monochrom: for some reason it seemed i needed $
2021-07-19 11:45:31	dsal	[21:37:40] lechner: does it work with $ ?
2021-07-19 11:45:31	monochrom	[21:37:43] Sure, "map ($ x) [f, g, h]" has just cause.  I am referring to "printf fmt $ ..."
2021-07-19 11:45:31	lechner	[21:37:56] okay, i'll change that but why is my partial application wrong. could someone please restate?
2021-07-19 11:45:31	dsal	[21:37:57] :t ($)
2021-07-19 11:45:31	lambdabot	[21:37:58] (a -> b) -> a -> b
2021-07-19 11:45:31	geekosaur	[21:38:17] lechner, you are attempting to use a list as two applications
2021-07-19 11:45:31	lechner	[21:38:17] monochrom: i meant that one
2021-07-19 11:45:31	[exa]	[21:38:25] lechner: the partial application is right (at least so it seems to me), the problem is that you're giving printf 1 argument and specify 2 in format
2021-07-19 11:45:31	dsal	[21:38:37] lechner: If it doesn't work, then it's not fair to say that you needed it.
2021-07-19 11:45:31	geekosaur	[21:38:43] one list is one application, not two
2021-07-19 11:45:31	dsal	[21:39:17] > (+) $ 1 $ 2
2021-07-19 11:45:31	lambdabot	[21:39:18]  error:
2021-07-19 11:45:31	lambdabot	[21:39:18]      • Could not deduce (Num t0)
2021-07-19 11:45:31	lambdabot	[21:39:18]        from the context: (Num a, Num t, Num (t -> a))
2021-07-19 11:45:31	dsal	[21:39:55] $ isn't a syntactic feature.  It's just a function.  And it will break your applications if effective arity is > 1
2021-07-19 11:45:31	lechner	[21:40:01] [exa]: https://paste.debian.net/1204830/
2021-07-19 11:45:31	[exa]	[21:40:44] dsal: you'd need -XChurchNumerals
2021-07-19 11:45:31	dsal	[21:40:48] You might try breaking that into different statements to understand it better.
2021-07-19 11:45:31	geekosaur	[21:41:16] lechner, contemplate this:
2021-07-19 11:45:31	geekosaur	[21:41:25] > (+) [1,2]
2021-07-19 11:45:31	lambdabot	[21:41:27]  error:
2021-07-19 11:45:31	lambdabot	[21:41:27]      • No instance for (Num [Integer]) arising from a use of ‘e_112’
2021-07-19 11:45:31	lambdabot	[21:41:27]      • In the expression: e_112
2021-07-19 11:45:31	geekosaur	[21:41:43] hm, (+) is not the best example there
2021-07-19 11:45:31	monochrom	[21:41:54] (&&) [False, False]
2021-07-19 11:45:31	[exa]	[21:41:57] lechner: yeah there printf uses `map` as the first argument, likely not very printable
2021-07-19 11:45:31	geekosaur	[21:41:58] > (++) ["a","b"]
2021-07-19 11:45:31	lambdabot	[21:42:00]  <[[Char]] -> [[Char]]>
2021-07-19 11:45:31	lechner	[21:42:03] geekosaur: isn't that here four applications?   https://salsa.debian.org/lintian/kickoff/-/blob/master/Collect.hs#L68
2021-07-19 11:45:31	lechner	[21:42:40] [exa]: yeah, that part i get now
2021-07-19 11:45:31	monochrom	[21:42:40] one single list.
2021-07-19 11:45:31	geekosaur	[21:42:46] lechner, no, it is a 4-element list
2021-07-19 11:45:31	dsal	[21:42:56] :t map
2021-07-19 11:45:31	lambdabot	[21:42:57] (a -> b) -> [a] -> [b]
2021-07-19 11:45:31	geekosaur	[21:43:06] thisis not lisp, a list is not a group of applications
2021-07-19 11:45:31	dsal	[21:43:23] map takes a function and applies it to each element inside a list.  One list in, one list out.
2021-07-19 11:45:31	lechner	[21:44:39] that's what i am looking for, except one member (of all partially or unapplied functions) is specified as    a . b 
2021-07-19 11:45:31	dsal	[21:45:19] You're doing several things at once.  You will likely have more success if you break them down a bit.
2021-07-19 11:45:31	lechner	[21:45:53] dsal: let's go with your approach. i am reading up on puns
2021-07-19 11:45:31	dsal	[21:45:54] A list is one thing, but it's not what your printf wants.  So to work backwards, you'll have to figure out how to make what your printf wants.
2021-07-19 11:45:31	lechner	[21:46:03] yes
2021-07-19 11:45:31	lechner	[21:46:14] let's chuck printf
2021-07-19 11:45:31	dsal	[21:46:17] My approach is to make a function that formats  your connection string.
2021-07-19 11:45:31	dsal	[21:47:12] In MonadLogger, you can call that ToLogStr, but that's the opposite direction from "do less stuff"  :)
2021-07-19 11:45:31	lechner	[21:54:50] can i define an instance of 'show' to return the string     host ++ ":" ++ listen_port     for a type that has both?
2021-07-19 11:45:31	geekosaur	[21:55:05] you can but you shouldn't
2021-07-19 11:45:31	lechner	[21:55:20] why not, please?
2021-07-19 11:45:31	geekosaur	[21:55:47] an instance of Show should match an instance of Read and ideally be a fragment of Haskell source that will reproduce a value of the type within ghc /  ghci
2021-07-19 11:45:31	geekosaur	[21:56:37] otherwise you run into issues Show-ing or Read-ing structures that contain values of that type
2021-07-19 11:45:31	lechner	[21:56:39] could i add both?
2021-07-19 11:45:31	geekosaur	[21:57:38] what do you mean?
2021-07-19 11:45:31	lechner	[21:58:00] Show and Read
2021-07-19 11:45:31	dsal	[21:58:40] lechner: That's not what show is for.  This is why MonadLogger defines ToLogStr.  You can make your own.
2021-07-19 11:45:31	dminuoso	[21:59:47] geekosaur: Strictly speaking, that is only requires for deriving generated instances. This notion that they "should" seems to be based in rumour or just an observation of established practice.
2021-07-19 11:45:31	dsal	[21:59:47] You *can* define your own Show and Read if you're pretty sure you can encapsulate all of the structure you want.  It's not definitely the wrong idea all the time, but it's not easier than making something specific for logging and having your logger log with it.
2021-07-19 11:45:31	dsal	[22:00:39] I think it's the date/time stuff that has fancy Show instances that just make life miserable when you have them in data structures.
2021-07-19 11:45:31	lechner	[22:01:08] i should not use UTCTime in JSON decls?
2021-07-19 11:45:31	pavonia	[22:01:13] Custom Show instances are a PITA if you have to debug things. Just don't do it
2021-07-19 11:45:31	lechner	[22:01:22] okay
2021-07-19 11:45:31	monochrom	[22:01:42] Established practice is still something to respect.  Of course, "respect" allows exceptions.  OK I'm on a fence, I'll stop now.
2021-07-19 11:45:31	lechner	[22:02:04] i'm just learning
2021-07-19 11:45:31	sm	[22:04:01] for learning, do whatever you like :)
2021-07-19 11:45:31	exarkun	[22:04:58] Where's the Haskell implementation of https://en.wikipedia.org/wiki/Turtle_graphics ?
2021-07-19 11:45:31	lechner	[22:05:52] what's the precedence between $ and ++ please?
2021-07-19 11:45:31	dminuoso	[22:06:55] %i ($)
2021-07-19 11:45:31	dminuoso	[22:07:05] % :i ($)
2021-07-19 11:45:31	yahb	[22:07:05] dminuoso: ($) :: (a -> b) -> a -> b -- Defined in `GHC.Base'; infixr 0 $
2021-07-19 11:45:31	dminuoso	[22:07:07] % :i (++)
2021-07-19 11:45:31	yahb	[22:07:08] dminuoso: (++) :: [a] -> [a] -> [a] -- Defined in `GHC.Base'; infixr 5 ++
2021-07-19 11:45:31	dminuoso	[22:07:18] lechner: ^- See the fixity declarations?
2021-07-19 11:45:31	dminuoso	[22:08:05] The number is the precedence level
2021-07-19 11:45:31	dsal	[22:08:09] % :i (<>)
2021-07-19 11:45:31	yahb	[22:08:09] dsal: type GHC.Base.Semigroup :: * -> Constraint; class GHC.Base.Semigroup a where; (<>) :: a -> a -> a; ...; -- Defined in `GHC.Base'; infixr 6 <>
2021-07-19 11:45:31	dsal	[22:08:17] That's interesting.
2021-07-19 11:45:31	dminuoso	[22:08:20] And the `r` in infixr means its right-associative. We also have infixl for left associative
2021-07-19 11:45:31	dminuoso	[22:09:23] If no fixity is declared, an operator defaults to infixl 9.
2021-07-19 11:45:31	lechner	[22:09:33] dsal: ++ binds more tightly than $ right?
2021-07-19 11:45:31	dminuoso	[22:09:41] Yes.
2021-07-19 11:45:31	monochrom	[22:10:01] What do "0" and "5" tell you?
2021-07-19 11:45:31	lechner	[22:10:32] a relative ordering
2021-07-19 11:45:31	dsal	[22:10:35] I don't ever use ++.  I just never considered ++ was lower than <>
2021-07-19 11:45:31	lechner	[22:11:05] what is <> please? i have only seen that in purescript
2021-07-19 11:45:31	dsal	[22:11:14] :t (<>)
2021-07-19 11:45:31	lambdabot	[22:11:16] Semigroup a => a -> a -> a
2021-07-19 11:45:31	dsal	[22:11:17] :t (++)
2021-07-19 11:45:31	lambdabot	[22:11:19] [a] -> [a] -> [a]
2021-07-19 11:45:31	dsal	[22:11:35] ++ only works for lists.  <> is like ++ but works for many other types.
2021-07-19 11:45:31	xsperry	[22:11:40] lechner, you can think of it as a more general ++. it works with more than just lists
2021-07-19 11:45:31	lechner	[22:12:02] dsal: should is stick to concat instead of ++?
2021-07-19 11:45:31	dsal	[22:12:29] :t concat
2021-07-19 11:45:31	lambdabot	[22:12:30] Foldable t => t [a] -> [a]
2021-07-19 11:45:31	dsal	[22:12:37] :t fold
2021-07-19 11:45:31	lambdabot	[22:12:39] (Foldable t, Monoid m) => t m -> m
2021-07-19 11:45:31	dsal	[22:12:51] That doesn't do the same thing, but depending on what you're doing, it might be better.
2021-07-19 11:45:31	dsal	[22:13:18] I use <> often, I just don't use ++.  You can use ++ if you like.  I was just commenting on the precedence.
2021-07-19 11:45:31	dsal	[22:14:41] I've got logging functions like `logErrorL, logInfoL, logDbgL :: (Foldable f, MonadLogger m) => f T.Text-> m ()` which are helpful when I want to log a list of Texts.  e.g., `logInfoL = logInfoN . fold`
2021-07-19 11:45:31	lechner	[22:27:12] are those two lines acceptable for a newbie?  https://dpaste.org/sqiW#L96,97
2021-07-19 11:45:31	dminuoso	[22:28:48] Looks fine.
2021-07-19 11:45:31	lechner	[22:29:12] thanks to everyone for your help!
2021-07-19 11:45:31	dminuoso	[22:29:22] The `nice 19` looks dubious though.
2021-07-19 11:45:31	lechner	[22:29:48] what should it look like?
2021-07-19 11:45:31	lechner	[22:31:08] I'm trying to do this:   https://salsa.debian.org/lintian/kickoff/-/blob/master/runner#L57
2021-07-19 11:45:31	lechner	[23:05:32] why do ++ and concat not do the same thing, please?
2021-07-19 11:45:31	int-e	[23:05:51] they have different types?
2021-07-19 11:45:31	geekosaur	[23:06:39] what do you mean by "not do the same thing"?
2021-07-19 11:45:31	geekosaur	[23:06:45] :t (++)
2021-07-19 11:45:31	lambdabot	[23:06:46] [a] -> [a] -> [a]
2021-07-19 11:45:31	int-e	[23:06:46] concat takes a list of lists (well, a traversable of lists, but let's simplify) and appends those; ++ takes two lists and appends them
2021-07-19 11:45:31	geekosaur	[23:06:58] :t concat
2021-07-19 11:45:31	lambdabot	[23:06:59] Foldable t => t [a] -> [a]
2021-07-19 11:45:31	int-e	[23:07:05] foldable, my bad
2021-07-19 11:45:31	int-e	[23:07:14] Why do we use "t" for a Foldable.
2021-07-19 11:45:31	lechner	[23:07:47] are they different when used with String?
2021-07-19 11:45:31	int-e	[23:07:55] (That's what misled me, though it shouldn't have.)
2021-07-19 11:45:31	geekosaur	[23:07:58] I think this may be ghc inferring a type and calling it "t" because that's the default
2021-07-19 11:45:31	int-e	[23:08:07] > concat ["a","b","c"]
2021-07-19 11:45:31	lambdabot	[23:08:09]  "abc"
2021-07-19 11:45:31	geekosaur	[23:08:09] lechner, a String is just a list of Char
2021-07-19 11:45:31	int-e	[23:08:11] > "a" ++ "b"
2021-07-19 11:45:31	lambdabot	[23:08:12]  "ab"
2021-07-19 11:45:31	int-e	[23:08:19] it's still a completely different type
2021-07-19 11:45:31	dsal	[23:08:37] Two things and a list of two things are not the same type.
2021-07-19 11:45:31	int-e	[23:08:58] You can rewrite  xs ++ ys  as  concat [xs,ys]  if you like.
2021-07-19 11:45:31	lechner	[23:09:22] that's what i meant. thanks!
2021-07-19 11:45:31	int-e	[23:09:27] (it may come at a small performance penalty)
2021-07-19 11:45:31	int-e	[23:09:34] (I haven't checked)
2021-07-19 11:45:31	lechner	[23:10:22] performance is a binary event here atm
2021-07-19 11:45:31	int-e	[23:11:55] Checked, evidently  concat [xs, ys]  gets rewritten to  xs ++ ys, so there's no difference.
2021-07-19 11:45:31	int-e	[23:12:10] (when compiling with ghc with optimizations enabled)
2021-07-19 11:45:31	int-e	[23:13:41] I don't know what "binary event" means.
2021-07-19 11:45:31	arahael	[23:13:44] The joy of a bit of early-morning haskell before work. :D
2021-07-19 11:45:31	beaky	[23:14:08] hello does ghc do whole program optimization like mlton 
2021-07-19 11:45:31	arahael	[23:14:24] It's _remarkable_ how one can get by with sloppy code in haskell: You can trivially and painlessly refactor it.  So nice.
2021-07-19 11:45:31	int-e	[23:15:18] beaky: no, it compiles modules separately, though there's inlining across modules for small functions.
2021-07-19 11:45:31	arahael	[23:17:27] int-e: There was this last year, though: https://www.patreon.com/posts/introducing-ghc-38173710  Has anything happened in that space since then or has it fizzled out?
2021-07-19 11:45:31	int-e	[23:18:45] I don't really know. I saw that there was some discussion on GRIN on here 2 hours ago...
2021-07-19 11:45:31	geekosaur	[23:19:43] there is apparently still some ongoing work but it hasn't been upstreamed and isn't yet usable in production
2021-07-19 11:45:31	int-e	[23:21:49] Or is that 26 hours ago, my client has no dates in the timestamp, and my feeling for time is all messed up
2021-07-19 11:45:31	arahael	[23:22:39] I'm personally a bit torn between thinking that that research is awesome - and or wishing that compilation took way less memory, even though memory doesn't seem to affect me because I never have less than 16 GB of RAM these days.
2021-07-19 11:45:31	geekosaur	[23:23:25] 26 hours ago more likely
2021-07-19 11:45:31	geekosaur	[23:23:37] was when I was in the discussion at least
2021-07-19 11:45:31	int-e	[23:24:18] cf. https://paste.debian.net/hidden/d3d82af6/
2021-07-19 11:45:31	int-e	[23:25:17] Yes, it was 26 hours ago. I still don't know whether it's related to that patreon thing. The topic clearly overlaps heavily.
2021-07-19 11:45:31	int-e	[23:26:10] (don't bookmark that paste, I set it to expire in 24h)
2021-07-19 11:45:31	geekosaur	[23:27:15] people can get it from ircbrowse if they want it :)
2021-07-19 11:45:31	geekosaur	[23:27:40] admittedly it'd help if it were searchable, but can't have everything
2021-07-19 11:45:31	geekosaur	[23:29:29] that was the one I was talking about, at least. don't know with 100% certainty it was the one dmj` intended, but it seemed to match up
2021-07-19 11:45:31	dminuoso	[00:18:21] Mmm. Im doing an URL style percent encoding/decoding of bytestring. I have two Word8 and want to prepend them to a ByteString, what's the efficient way to do this here?
2021-07-19 11:45:31	Axman6	[00:19:32] I would have a look at the bytestring-base16 code to find efficient ways to do things. otherwise I'd probably just say use a builder if it's likely you'll be doing more appends/prepends
2021-07-19 11:45:31	dminuoso	[00:21:33] I was thinking along the lines of: let dualton c1 c2 = unsafeCreate 2 $ \p -> poke p c1 >> poke (p `plusPtr` 1) c2 in dualton x1 x2 <> rest
2021-07-19 11:45:31	dminuoso	[00:21:45] Axman6: Mmm.
2021-07-19 11:45:31	dminuoso	[00:22:10] Ah, yes. Perhaps that is the better way indeed
2021-07-19 11:45:31	Axman6	[00:22:57] if you know exactly how large the result will be there's definitely tricks to make it fast, but usually if the question is ')how do I construct a bytestring from parts" the answer is Builder
2021-07-19 11:45:31	dminuoso	[00:26:36] Mmm, so on the outside Im inside conduit. Maybe there's a way to stream a bytestring builder into a conduit
2021-07-19 11:45:31	dminuoso	[00:27:21] Apparently not, but that's fine
2021-07-19 11:45:31	dminuoso	[00:29:46] @tell burnsidesLlama It just occured to me, that the generalization you are looking for is `scanl` or `scanr`.
2021-07-19 11:45:31	lambdabot	[00:29:46] Consider it noted.
2021-07-19 11:45:31	Axman6	[00:36:38] dminuoso: using https://hackage.haskell.org/package/bytestring-0.11.1.0/docs/Data-ByteString-Builder-Internal.html#t:ChunkIOStream you can efficiently stream a bytestring
2021-07-19 11:45:31	Axman6	[00:41:38] ... maybe, actually struggling to see how to take in Builders and then use that
2021-07-19 11:45:31	dmj`	[02:40:46] int-e: there is a patreon for GRIN work yes
2021-07-19 11:45:31	dmj`	[02:41:13] Some of what I said is related to that
2021-07-19 11:45:31	GeorgeArmani	[03:11:30] Can someone help me understand this error message ?
2021-07-19 11:45:31	GeorgeArmani	[03:11:32] any' :: (a -> Bool) -> a -> Bool
2021-07-19 11:45:31	GeorgeArmani	[03:11:32] any' f xs = foldl step False xs where
2021-07-19 11:45:31	GeorgeArmani	[03:11:33]     step acc (y:ys)
2021-07-19 11:45:31	GeorgeArmani	[03:11:33]         | f y = True
2021-07-19 11:45:31	GeorgeArmani	[03:11:34]         | otherwise = acc
2021-07-19 11:45:31	GeorgeArmani	[03:11:41] Fold.hs:52:30: error:
2021-07-19 11:45:31	GeorgeArmani	[03:11:42]     • Occurs check: cannot construct the infinite type: a ~ t0 [a]
2021-07-19 11:45:31	GeorgeArmani	[03:11:42]     • In the third argument of ‘foldl’, namely ‘xs’
2021-07-19 11:45:31	GeorgeArmani	[03:11:43]       In the expression: foldl step False xs
2021-07-19 11:45:31	GeorgeArmani	[03:11:43]       In an equation for ‘any'’:
2021-07-19 11:45:31	GeorgeArmani	[03:11:44]           any' f xs
2021-07-19 11:45:31	GeorgeArmani	[03:11:44]             = foldl step False xs
2021-07-19 11:45:31	GeorgeArmani	[03:11:45]             where
2021-07-19 11:45:31	GeorgeArmani	[03:11:45]                 step acc (y : ys)
2021-07-19 11:45:31	GeorgeArmani	[03:11:46]                   | f y = True
2021-07-19 11:45:31	GeorgeArmani	[03:11:46]                   | otherwise = acc
2021-07-19 11:45:31	geekosaur	[03:13:31] please don't paste directly into the channel like that
2021-07-19 11:45:31	Axman6	[03:13:32] @where paste
2021-07-19 11:45:31	lambdabot	[03:13:32] Help us help you: please paste full code, input and/or output at e.g. https://paste.tomsmeding.com
2021-07-19 11:45:31	geekosaur	[03:14:59] but it's telling you that 'a' cannot at the same time be a Foldable over a list and an element of that list
2021-07-19 11:45:31	GeorgeArmani	[03:15:15] https://paste.tomsmeding.com/qsfDJyUC#file-1
2021-07-19 11:45:31	Axman6	[03:15:16] yeah take a close look at the type you've given any'
2021-07-19 11:45:31	geekosaur	[03:15:18] think about your type signature
2021-07-19 11:45:31	geekosaur	[03:18:15] it may also be helpful to give step the type signature you think it should have
2021-07-19 11:45:31	GeorgeArmani	[03:39:44] I'm really having a tough time sorting that out
2021-07-19 11:45:31	geekosaur	[03:41:22] what does the type "a" in your type signature represent?
2021-07-19 11:45:31	geekosaur	[03:41:49] remember that it's going to be the same type everywhere in that signature
2021-07-19 11:45:31	GeorgeArmani	[03:43:29] I think it should be a list every time its used?
2021-07-19 11:45:31	geekosaur	[03:43:48] is it in (a -> Bool)?
2021-07-19 11:45:31	GeorgeArmani	[03:47:05] ahhhh so should it be ------- any' :: (a -> Bool) -> [a] -> Bool
2021-07-19 11:45:31	geekosaur	[03:47:15] yes
2021-07-19 11:45:31	geekosaur	[03:49:09] I suspect from your original error that this will only fix one problem, though
2021-07-19 11:45:31	GeorgeArmani	[03:49:25] correct
2021-07-19 11:45:31	GeorgeArmani	[03:50:45] In fact, I had that type signature originally but changed it to deal with this error https://paste.tomsmeding.com/ntGaaQnX
2021-07-19 11:45:31	GeorgeArmani	[03:51:42] Wait just putting [xs] like that worked 
2021-07-19 11:45:31	GeorgeArmani	[03:52:05] https://paste.tomsmeding.com/qirkhcRw
2021-07-19 11:45:31	GeorgeArmani	[03:52:10] Im not sure why though
2021-07-19 11:45:31	GeorgeArmani	[03:55:08] I get it now. Thanks Geekosaur. 
2021-07-19 11:45:31	geekosaur	[03:55:53] yeh, you are splitting the list in step as well when you don't need to because fold already is
2021-07-19 11:45:31	geekosaur	[03:56:25] so it thinks you need a list of lists. that's why I suggested putting a type signature on step
2021-07-19 11:45:31	GeorgeArmani	[03:56:37] exactly, I deleted calling head in step and removed the [] around xs
2021-07-19 11:45:31	GeorgeArmani	[04:04:03] Sorry for asking so many questions. I am confused about the type signature for step.
2021-07-19 11:45:31	GeorgeArmani	[04:04:41] I thought it would be Bool -> a -> Bool , but it is throwing an error at compile
2021-07-19 11:45:31	h98	[04:07:51] what's your code right now? that type signature sounds right to me
2021-07-19 11:45:31	GeorgeArmani	[04:09:13] https://paste.tomsmeding.com/kU1zB95f
2021-07-19 11:45:31	geekosaur	[04:09:30] oh, right, this requires ScopedTypeVariables to specify a signature
2021-07-19 11:45:31	geekosaur	[04:10:30] otherwise the a you specify in the type signature for step is unrelated to the one specified for any', but that breaks f
2021-07-19 11:45:31	GeorgeArmani	[04:10:31] Ok ill look into that
2021-07-19 11:45:31	geekosaur	[04:11:11] sometimes ghc is annoying that way
2021-07-19 11:45:31	h98	[04:11:22] should compile as-is if you delete the type signature now
2021-07-19 11:45:31	GeorgeArmani	[04:11:42] ahhhh ok. That is a little frustrating. 
2021-07-19 11:45:31	GeorgeArmani	[04:12:04] yeah h98 thank you. I just wanted to make sure that I understood what was going on fully.
2021-07-19 11:45:31	geekosaur	[04:12:04] yes, but I suggested adding the type signature, having forgotten it wouldn';t work :(
2021-07-19 11:45:31	GeorgeArmani	[04:12:42] All good :) . Appreciate the help, Geekosaur.
2021-07-19 11:45:31	lechner	[04:52:56] Hi, is it possible to catch decompression errors from LZMA here?   https://salsa.debian.org/lintian/kickoff/-/blob/master/Collect.hs#L82
2021-07-19 11:45:31	dsal	[05:10:48] lechner: It uses MonadFail.  You could use exceptions
2021-07-19 11:45:31	dsal	[05:10:52] @package exceptions
2021-07-19 11:45:31	lambdabot	[05:10:53] https://hackage.haskell.org/package/exceptions
2021-07-19 11:45:31	Hecate	[05:24:13] o/
2021-07-19 11:45:31	Hecate	[05:24:26] I'm trying to better understand how I can use Comonad in my programs
2021-07-19 11:45:31	Hecate	[05:25:04] I've seen *one* usage of Comonad in a codebase, in which it acted as a priviledged accessor, like https://twitter.com/TechnoEmpress/status/1416992128643776513
2021-07-19 11:45:31	Hecate	[05:26:04] but I think the usecase really stops at running "whatever <- asks extract"
2021-07-19 11:45:31	Hecate	[05:27:01] But then it feels more like I've created one more indirection
2021-07-19 11:45:31	Hecate	[05:27:54] that being said if I need more polymorphism on the 'Comonad r' this could be good
2021-07-19 11:45:31	lechner	[05:32:05] dsal: thanks!
2021-07-19 11:45:31	Guest95	[05:43:02] Hello! I currently use Spacemacs as my Haskell code editor. What code editor would you recommend? Is Yi worth looking in to?
2021-07-19 11:45:31	Hecate	[05:46:17] Guest95: Yi was an interesting project but I fear it may be dead these days
2021-07-19 11:45:31	Hecate	[05:46:33] Guest95: I use neovim + lua plugins and config (if you're allergic to too much VimL)
2021-07-19 11:45:31	lechner	[05:56:50] Thanks for the pointer to yi. I may have found a minimal replacement for things like commit messages for mg, which is even less maintained and can't do Unicode
2021-07-19 11:45:31	***	Playback Complete.
2021-07-19 11:45:40	--	Channel created on Sun, 25 Apr 2021 01:04:39
2021-07-19 11:56:24	<--	Sgeo (~Sgeo@user/sgeo) has quit (Read error: Connection reset by peer)
2021-07-19 11:56:43	<--	wroathe (~wroathe@c-68-54-25-135.hsd1.mn.comcast.net) has quit (Ping timeout: 268 seconds)
2021-07-19 12:01:22	-->	vysn (~vysn@user/vysn) has joined #haskell
2021-07-19 12:02:22	<--	jmorris (uid433911@id-433911.stonehaven.irccloud.com) has quit (Quit: Connection closed for inactivity)
2021-07-19 12:04:39	-->	ishutin (~ishutin@85-238-93-30.pool.digikabel.hu) has joined #haskell
2021-07-19 12:12:16	--	jjhoo_ is now known as jjhoo
2021-07-19 12:12:55	-->	wroathe (~wroathe@c-68-54-25-135.hsd1.mn.comcast.net) has joined #haskell
2021-07-19 12:17:52	<--	wroathe (~wroathe@c-68-54-25-135.hsd1.mn.comcast.net) has quit (Ping timeout: 258 seconds)
2021-07-19 12:18:33	-->	_ht (~quassel@82-169-194-8.biz.kpn.net) has joined #haskell
2021-07-19 12:20:26	<--	Maxdamantus (~Maxdamant@user/maxdamantus) has quit (Ping timeout: 256 seconds)
2021-07-19 12:21:31	<--	oxide (~lambda@user/oxide) has quit (Read error: Connection reset by peer)
2021-07-19 12:21:55	-->	kuribas (~user@ptr-25vy0i7jsa6kv1vvjg7.18120a2.ip6.access.telenet.be) has joined #haskell
2021-07-19 12:27:17	-->	Obo (~roberto@70.pool90-171-81.dynamic.orange.es) has joined #haskell
2021-07-19 12:27:39	-->	chele (~chele@user/chele) has joined #haskell
2021-07-19 12:28:33	-->	aman (~aman@user/aman) has joined #haskell
2021-07-19 12:29:05	<--	wallymathieu (~wallymath@81-234-151-21-no94.tbcn.telia.com) has quit (Quit: My MacBook has gone to sleep. ZZZzzz…)
2021-07-19 12:30:27	<--	Erutuon (~Erutuon@user/erutuon) has quit (Ping timeout: 255 seconds)
2021-07-19 12:31:46	<--	aman (~aman@user/aman) has quit (Client Quit)
2021-07-19 12:32:56	-->	jmorris (uid433911@id-433911.stonehaven.irccloud.com) has joined #haskell
2021-07-19 12:35:33	<--	slowButPresent (~slowButPr@user/slowbutpresent) has quit (Quit: leaving)
2021-07-19 12:37:25	-->	Maxdamantus (~Maxdamant@user/maxdamantus) has joined #haskell
2021-07-19 12:38:04	-->	fendor (~fendor@77.119.223.215.wireless.dyn.drei.com) has joined #haskell
2021-07-19 12:39:55	<--	h98 (~h98@187.83.249.216.dyn.smithville.net) has quit (Quit: Client closed)
2021-07-19 12:41:38	<--	Vajb (~Vajb@hag-jnsbng11-58c3a1-224.dhcp.inet.fi) has quit (Read error: Connection reset by peer)
2021-07-19 12:42:29	-->	Vajb (~Vajb@2001:999:62:1d53:26b1:6c9b:c1ed:9c01) has joined #haskell
2021-07-19 12:46:41	-->	KUrare (~KUrare@user/kurare) has joined #haskell
2021-07-19 12:46:55	<--	Obo (~roberto@70.pool90-171-81.dynamic.orange.es) has quit (Quit: WeeChat 2.8)
2021-07-19 12:47:05	-->	Tuplanolla (~Tuplanoll@91-159-68-239.elisa-laajakaista.fi) has joined #haskell
2021-07-19 12:47:13	-->	Obo (~roberto@70.pool90-171-81.dynamic.orange.es) has joined #haskell
2021-07-19 12:50:52	<--	KUrare (~KUrare@user/kurare) has quit (Ping timeout: 252 seconds)
2021-07-19 12:51:03	<--	yauhsien (~yauhsien@61-231-35-149.dynamic-ip.hinet.net) has quit (Remote host closed the connection)
2021-07-19 12:54:54	-->	smtnet3 (~asdfasdfa@202.36.244.28) has joined #haskell
2021-07-19 12:56:33	<--	favonia (~favonia@user/favonia) has quit (Ping timeout: 255 seconds)
2021-07-19 12:56:47	-->	merijn (~merijn@83-160-49-249.ip.xs4all.nl) has joined #haskell
2021-07-19 12:58:48	-->	burnsidesLlama (~burnsides@dhcp168-011.wadham.ox.ac.uk) has joined #haskell
2021-07-19 12:58:57	-->	yauhsien (~yauhsien@61-231-35-149.dynamic-ip.hinet.net) has joined #haskell
2021-07-19 13:00:35	-->	hseg (~gesh@185.120.126.10) has joined #haskell
2021-07-19 13:01:11	<--	brandon (~geekosaur@xmonad/geekosaur) has quit (Ping timeout: 258 seconds)
2021-07-19 13:01:16	-->	analognoise1 (~analognoi@2600:8801:8c26:9e00:cdb0:ec42:cea0:b1e2) has joined #haskell
2021-07-19 13:02:12	<--	analognoise (~analognoi@83.136.182.93) has quit (Ping timeout: 245 seconds)
2021-07-19 13:04:08	-->	geekosaur (~geekosaur@xmonad/geekosaur) has joined #haskell
2021-07-19 13:04:12	--	geekosaur is now known as brandon
2021-07-19 13:09:25	-->	__monty__ (~toonn@user/toonn) has joined #haskell
2021-07-19 13:11:25	<--	Guest55 (~Guest55@50.47.115.102) has quit (Ping timeout: 246 seconds)
2021-07-19 13:11:32	<--	econo (uid147250@user/econo) has quit (Quit: Connection closed for inactivity)
2021-07-19 13:11:47	<--	vicfred (~vicfred@user/vicfred) has quit (Quit: Leaving)
2021-07-19 13:14:33	<--	analognoise1 (~analognoi@2600:8801:8c26:9e00:cdb0:ec42:cea0:b1e2) has quit (Ping timeout: 255 seconds)
2021-07-19 13:17:15	<--	Brianmancer (~Neuromanc@user/briandamag) has quit (Ping timeout: 255 seconds)
2021-07-19 13:21:34	-->	acidjnk (~acidjnk@p200300d0c72b9531f8c9d06c34eef88c.dip0.t-ipconnect.de) has joined #haskell
2021-07-19 13:27:11	<--	isekaijin (~pyon@user/pyon) has quit (Quit: WeeChat 3.2)
2021-07-19 13:29:29	<--	dre (~dre@2001:8003:c932:c301:9820:d974:d4b6:d3c4) has quit (Quit: Leaving)
2021-07-19 13:29:33	-->	michalz (~michalz@185.246.204.55) has joined #haskell
2021-07-19 13:36:37	-->	hendursa1 (~weechat@user/hendursaga) has joined #haskell
2021-07-19 13:39:39	<--	hendursaga (~weechat@user/hendursaga) has quit (Ping timeout: 244 seconds)
2021-07-19 13:41:35	-->	Gurkenglas (~Gurkengla@dslb-002-203-144-156.002.203.pools.vodafone-ip.de) has joined #haskell
2021-07-19 13:42:30	<--	shriekingnoise (~shrieking@186.137.144.80) has quit (Quit: Quit)
2021-07-19 13:47:32	-->	drd (~drd@93-39-151-19.ip76.fastwebnet.it) has joined #haskell
2021-07-19 13:47:34	-->	allbery_b (~geekosaur@xmonad/geekosaur) has joined #haskell
2021-07-19 13:50:06	<--	brandon (~geekosaur@xmonad/geekosaur) has quit (Ping timeout: 255 seconds)
2021-07-19 13:54:49	-->	MQ-17J (~MQ-17J@d14-69-206-129.try.wideopenwest.com) has joined #haskell
2021-07-19 13:58:39	-->	Lord_of_Life_ (~Lord@user/lord-of-life/x-2819915) has joined #haskell
2021-07-19 14:00:00	<--	tzh (~tzh@c-24-21-73-154.hsd1.or.comcast.net) has quit (Quit: zzz)
2021-07-19 14:01:05	<--	Lord_of_Life (~Lord@user/lord-of-life/x-2819915) has quit (Ping timeout: 255 seconds)
2021-07-19 14:01:18	--	Lord_of_Life_ is now known as Lord_of_Life
2021-07-19 14:01:49	<--	MQ-17J (~MQ-17J@d14-69-206-129.try.wideopenwest.com) has quit (Ping timeout: 246 seconds)
2021-07-19 14:03:21	<--	merijn (~merijn@83-160-49-249.ip.xs4all.nl) has quit (Ping timeout: 265 seconds)
2021-07-19 14:06:14	-->	MQ-17J (~MQ-17J@d14-69-206-129.try.wideopenwest.com) has joined #haskell
2021-07-19 14:07:16	<--	chris_ (~chris@81.96.113.213) has quit (Remote host closed the connection)
2021-07-19 14:08:19	<--	ChaiTRex (~ChaiTRex@user/chaitrex) has quit (Remote host closed the connection)
2021-07-19 14:08:45	-->	ChaiTRex (~ChaiTRex@user/chaitrex) has joined #haskell
2021-07-19 14:10:12	<--	lavaman (~lavaman@98.38.249.169) has quit (Remote host closed the connection)
2021-07-19 14:10:24	-->	lavaman (~lavaman@98.38.249.169) has joined #haskell
2021-07-19 14:10:32	<--	lavaman (~lavaman@98.38.249.169) has quit (Remote host closed the connection)
2021-07-19 14:11:04	-->	lavaman (~lavaman@98.38.249.169) has joined #haskell
2021-07-19 14:15:24	-->	davros (~davros@host86-185-61-40.range86-185.btcentralplus.com) has joined #haskell
2021-07-19 14:17:17	-->	guest719 (~user@49.5.6.87) has joined #haskell
2021-07-19 14:17:40	-->	lars8 (~bc817c21@217.29.117.252) has joined #haskell
2021-07-19 14:18:19	guest719	why `traverse` would immediatly exit when it meet a Left a?
2021-07-19 14:18:52	guest719	traverse (\i -> if odd i then Right () else Left i) [1..10]
2021-07-19 14:19:42	lars8	>  traverse (\i -> if odd i then Right () else Left i) [1..10]
2021-07-19 14:19:44	lambdabot	 Left 2
2021-07-19 14:21:41	lars8	> sequence [Left 1, Right 2]
2021-07-19 14:21:42	lambdabot	 Left 1
2021-07-19 14:21:46	lars8	@src sequence
2021-07-19 14:21:46	lambdabot	sequence []     = return []
2021-07-19 14:21:46	lambdabot	sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
2021-07-19 14:21:46	lambdabot	--OR
2021-07-19 14:21:46	lambdabot	sequence xs = foldr (liftM2 (:)) (return []) xs
2021-07-19 14:22:00	lars8	does that help?
2021-07-19 14:22:50	lars8	traverse f is basically sequence . map f
2021-07-19 14:23:22	guest719	but why it meet Left a will early exit?
2021-07-19 14:23:49	lars8	because that's what liftM2 does
2021-07-19 14:24:04	guest719	@src liftM2
2021-07-19 14:24:05	lambdabot	liftM2 f m1 m2 = do
2021-07-19 14:24:05	lambdabot	    x1 <- m1
2021-07-19 14:24:05	lambdabot	    x2 <- m2
2021-07-19 14:24:05	lambdabot	    return (f x1 x2)
2021-07-19 14:24:23	lars8	> liftM2 (+) (Right 1) (Right 2)
2021-07-19 14:24:25	lambdabot	 Right 3
2021-07-19 14:24:35	lars8	> liftM2 (+) (Right 1) (Left 2)
2021-07-19 14:24:36	lambdabot	 Left 2
2021-07-19 14:24:48	dminuoso	guest719: `Either a`, like `Maybe`, models computations with exceptions.
2021-07-19 14:25:07	dminuoso	So a `Left err` or `Nothing` has the same semantics as an exception, it shortcircuits the entire computation
2021-07-19 14:25:12	lars8	if any argument is Left, entire computation is Left
2021-07-19 14:25:17	guest719	oh, Left 2 will break the computation chain in >>=
2021-07-19 14:25:21	dminuoso	Yes.
2021-07-19 14:25:52	guest719	dminuoso and why it's that? define in >>= ?
2021-07-19 14:25:55	dminuoso	guest719: Yes.
2021-07-19 14:26:26	dminuoso	The applicative and monadic interface of `Maybe` and `Either s` simply models exceptions.
2021-07-19 14:26:27	guest719	dminuoso except Left a and Nothing, is there other would break computation chain?
2021-07-19 14:26:30	dminuoso	There's no deeper reason than that.
2021-07-19 14:26:37	-->	Erutuon (~Erutuon@user/erutuon) has joined #haskell
2021-07-19 14:26:39	dminuoso	Sure there are others
2021-07-19 14:26:46	guest719	for examples?
2021-07-19 14:27:06	dminuoso	ExceptT 
2021-07-19 14:27:19	dminuoso	Though that's just an `Either s` in disguise
2021-07-19 14:27:36	guest719	I can't help when you said Exception, I always think about run-time Exceptions
2021-07-19 14:27:48	dminuoso	Yes, these are pretty much like runtime exceptions!
2021-07-19 14:27:51	dminuoso	Consider:
2021-07-19 14:27:53	guest719	why haskell would give it another name
2021-07-19 14:28:02	dminuoso	These are value-level/user-defined exceptions
2021-07-19 14:28:02	guest719	wouldn't
2021-07-19 14:28:38	dminuoso	guest719: We also have regular RTS exceptions as you know them inside IO.
2021-07-19 14:28:48	dminuoso	But in pure computations it might still be useful to have shortcircuiting semantics
2021-07-19 14:28:57	dminuoso	Like with traverse.
2021-07-19 14:29:19	dminuoso	Say you have a tree, and you want to process each node - but in a way that if you generate an error at any, that the entire computation is considered failed.
2021-07-19 14:29:46	dminuoso	Then you can use `Maybe` or `Either s` (depending on whether you want to keep information about the error condition)
2021-07-19 14:30:06	dminuoso	Then producing `Nothing` is semantically equivalent to throwing an exception, except we can do this in pure code and without any special support from the runtime system.
2021-07-19 14:30:20	dminuoso	data Maybe a = Nothin | Just a
2021-07-19 14:30:25	dminuoso	instance Monad Maybe where ...
2021-07-19 14:30:42	dminuoso	Voila! You have created exception semantics on your own, no exception primitive support needed in the language.
2021-07-19 14:31:23	<--	Erutuon (~Erutuon@user/erutuon) has quit (Ping timeout: 265 seconds)
2021-07-19 14:32:48	<--	lavaman (~lavaman@98.38.249.169) has quit (Ping timeout: 252 seconds)
2021-07-19 14:33:00	albet70	can we think it as a failure computation?
2021-07-19 14:33:37	albet70	what about 1/0?
2021-07-19 14:33:46	albet70	1/0 is an Exception?
2021-07-19 14:34:05	albet70	IO failure is an Exception?
2021-07-19 14:35:09	albet70	fmap (+1) Nothing would be an Exception?
2021-07-19 14:35:30	dminuoso	`Nothing` acts as an exception, yes.
2021-07-19 14:35:55	dminuoso	1/0 is an interesting subject for several reasons
2021-07-19 14:36:46	dminuoso	% :t (1/0)
2021-07-19 14:36:47	yahb	dminuoso: ; <interactive>:1:3: error: Variable not in scope: (/) :: t0 -> t1 -> t
2021-07-19 14:36:59	dminuoso	% :q
2021-07-19 14:36:59	yahb	dminuoso: 
2021-07-19 14:37:00	dminuoso	% :t (1/0)
2021-07-19 14:37:01	yahb	dminuoso: Fractional a => a
2021-07-19 14:37:06	dminuoso	% :i Fractional
2021-07-19 14:37:08	yahb	dminuoso: type Fractional :: * -> Constraint; class Num a => Fractional a where; (/) :: a -> a -> a; recip :: a -> a; fromRational :: Rational -> a; {-# MINIMAL fromRational, (recip | (/)) #-}; -- Defined in `GHC.Real'; instance Fractional a => Fractional (Identity a) -- Defined in `Data.Functor.Identity'; instance forall a k (b :: k). Fractional a => Fractional (Const a b) -- Defined in `Data.Functor.Co
2021-07-19 14:37:20	dminuoso	% :t (/)
2021-07-19 14:37:20	yahb	dminuoso: Fractional a => a -> a -> a
2021-07-19 14:37:34	dminuoso	albet70: ^- so you see, this is either Float or Double, at which point IEEE 754 semantics apply.
2021-07-19 14:38:05	dminuoso	Under which 1/0 is defined to be either positive or negative infinity (depending on the sign of 0)
2021-07-19 14:38:27	dminuoso	So 1/0 is actually a well defined value, perhaps unintuitively.
2021-07-19 14:39:18	dminuoso	But, what you probably meant is:
2021-07-19 14:39:22	dminuoso	% 1 `div` 0
2021-07-19 14:39:23	yahb	dminuoso: *** Exception: divide by zero
2021-07-19 14:39:31	dminuoso	% :t div
2021-07-19 14:39:31	yahb	dminuoso: Integral a => a -> a -> a
2021-07-19 14:39:46	<--	Patternmaster (~georg@li1192-118.members.linode.com) has quit (Ping timeout: 252 seconds)
2021-07-19 14:39:58	-->	Patternmaster (~georg@li1192-118.members.linode.com) has joined #haskell
2021-07-19 14:40:02	<--	pavonia (~user@user/siracusa) has quit (Quit: Bye!)
2021-07-19 14:40:04	albet70	yes, div 0
2021-07-19 14:40:07	dminuoso	albet70: ^- so yeah, this is a partial computation. We could have also made it non-partial and given it the type `div :: Integral a => a -> a -> Maybe a`, which produces Nothing for that case.
2021-07-19 14:40:30	<--	jolly (~jolly@208.180.97.158) has quit (Ping timeout: 252 seconds)
2021-07-19 14:42:02	dminuoso	albet70: In general, it's better to encode a failure as `Maybe` or `Either s` rather than producing an error (like div does)
2021-07-19 14:42:34	dminuoso	albet70: The reason is, you cant catch an `error` sensibly (its impossible in pure code, and you have imprecise error semantics if you try to do this from IO). error is really a sad part in Haskell.
2021-07-19 14:42:55	dminuoso	But you can catch a Nothing just fine (you just pattern match with case-of)
2021-07-19 14:43:02	dminuoso	Dont even need IO for that.
2021-07-19 14:44:21	-->	lavaman (~lavaman@98.38.249.169) has joined #haskell
2021-07-19 14:45:25	albet70	but haskell does try catch to capture runtime errors like IO error
2021-07-19 14:45:48	albet70	and IO socket error, how to use Either to detect?
2021-07-19 14:46:01	dminuoso	haskell does not try and catch runtime errors at all
2021-07-19 14:46:08	dminuoso	They blow up your entire program
2021-07-19 14:47:30	dminuoso	You have to explicitly catch them in IO
2021-07-19 14:47:44	dminuoso	And it's subtly difficult to do this because of lazy evaluation
2021-07-19 14:47:47	dminuoso	Consider
2021-07-19 14:47:49	dminuoso	% :t evaluate
2021-07-19 14:47:49	yahb	dminuoso: a -> IO a
2021-07-19 14:48:40	dminuoso	This one only evaluates up until WHNF. You could still have errors lingering in not-yet-evaluated parts. There's tricks to get around this, but you need to be aware of this 
2021-07-19 14:48:57	<--	lavaman (~lavaman@98.38.249.169) has quit (Ping timeout: 250 seconds)
2021-07-19 14:49:34	dminuoso	It's why uses of `error` are highly discouraged, since it's completely unclear which library functions could possibly trigger an `error`. The most common one that regularly causes headaches for me is\
2021-07-19 14:49:36	dminuoso	% :t read
2021-07-19 14:49:36	yahb	dminuoso: Read a => String -> a
2021-07-19 14:49:56	dminuoso	If you think about it, it should be dead obvious that this is *very* partial (by very I mean almost all strings produce an invalid result, only very few strings produce a parsable value)
2021-07-19 14:50:24	dminuoso	But this type of error quickly bubbles up and cant be reasonably caught anymore
2021-07-19 14:50:55	dminuoso	A way better function instead is:
2021-07-19 14:50:57	dminuoso	% :t readMaybe
2021-07-19 14:50:57	yahb	dminuoso: ; <interactive>:1:1: error: Variable not in scope: readMaybe
2021-07-19 14:51:05	--	irc: disconnected from server
2021-07-19 18:40:02	-->	amanr (~therojjha@20.204.87.0) has joined #haskell
2021-07-19 18:40:02	--	Topic for #haskell is "https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org | Paste code/errors: https://paste.tomsmeding.com | tunes.org-style logging should be coming soon | Logs: https://ircbrowse.tomsmeding.com/browse/lchaskell"
2021-07-19 18:40:02	--	Topic set by geekosaur (~geekosaur@xmonad/geekosaur) on Mon, 14 Jun 2021 05:16:14
2021-07-19 18:40:02	--	Channel #haskell: 705 nicks (1 op, 0 voices, 704 normals)
2021-07-19 18:40:02	***	Buffer Playback...
2021-07-19 18:40:02	dminuoso	[20:44:10] lechner: Like I said.
2021-07-19 18:40:02	dsal	[20:44:16] Does anyone know how to do something interesting with Control.Monad.Trans.Select ?    There doesn't seem to be much written about it.
2021-07-19 18:40:02	dminuoso	[20:44:21] `host $ scheduler config` is equivalent to `host (scheduler config)
2021-07-19 18:40:02	lechner	[20:44:50] okay, why are the parentheses needed, please?
2021-07-19 18:40:02	davean	[20:44:56] lechner: to parse it
2021-07-19 18:40:02	geekosaur	[20:45:09] $ is "backwards parentheses
2021-07-19 18:40:02	lechner	[20:45:15] that i know
2021-07-19 18:40:02	lechner	[20:45:35] i think it's a (slightly) higher level question
2021-07-19 18:40:02	davean	[20:45:40] lechner: so things (sorta) group to the left by default
2021-07-19 18:40:02	geekosaur	[20:45:42] so if you remove a $ you usually have to insert the parenheses it was replacing. here, for (scheduler config)
2021-07-19 18:40:02	davean	[20:45:52] lechner: you need to put it into the grammer as a group, not seperate things
2021-07-19 18:40:02	lechner	[20:46:03] my JSON declarations are not strict
2021-07-19 18:40:02	davean	[20:46:22] WHo said anything about strictness?
2021-07-19 18:40:02	davean	[20:46:53] This is about grammar
2021-07-19 18:40:02	monochrom	[20:47:04] The computer is not telepathic. You can't just write "f g h" and "t x y" and have the computer guess "oh you mean (f g) h and t (x y)".
2021-07-19 18:40:02	lechner	[20:47:37] not even when asking for a final result (printf) ?
2021-07-19 18:40:02	monochrom	[20:47:55] But there is a little bit of left associativity so "f g h" means "(f g) h".
2021-07-19 18:40:02	lechner	[20:48:24] why is that evaluated in my case, though?
2021-07-19 18:40:02	nf	[20:52:20] you usually have to evaluate things in order to print them
2021-07-19 18:40:02	davean	[20:53:32] lechner: it doesn't know printf is your final result even
2021-07-19 18:40:02	lechner	[20:53:36] but is that done inside the parentheses around the argument to printf?
2021-07-19 18:40:02	davean	[20:53:44] Its not "done inside"
2021-07-19 18:40:02	davean	[20:53:51] you're saying what is applied to what
2021-07-19 18:40:02	lechner	[20:54:38] i think i misunderstood partial application
2021-07-19 18:40:02	davean	[21:02:30] Definition is not execution
2021-07-19 18:40:02	davean	[21:02:52] lechner: consider the option of doign that like with (.)
2021-07-19 18:40:02	davean	[21:02:58] *line
2021-07-19 18:40:02	maerwald	[21:04:47] monochrom: wingman can guess what you mean, haha
2021-07-19 18:40:02	maerwald	[21:05:02] if your types are correct, that is
2021-07-19 18:40:02	maerwald	[21:06:36] now you just need something to guess the types for you
2021-07-19 18:40:02	maerwald	[21:07:16] and then something that guesses what the program should do
2021-07-19 18:40:02	maerwald	[21:07:26] we'll have no engineering problems to solve anymore
2021-07-19 18:40:02	 *	maerwald [21:07:43] goes packing
2021-07-19 18:40:02	dexterfoo	[21:08:24] can I convert a 'Text' value directly into an Int?
2021-07-19 18:40:02	Hecate	[21:11:07] % import Data.Text.Read
2021-07-19 18:40:02	yahb	[21:11:08] Hecate: 
2021-07-19 18:40:02	Hecate	[21:11:12] % decimal "3"
2021-07-19 18:40:02	yahb	[21:11:13] Hecate: ; <interactive>:223:1: error:; Ambiguous occurrence `decimal'; It could refer to; either `Data.Text.Read.decimal', imported from `Data.Text.Read'; or `Numeric.Lens.decimal', imported from `Numeric.Lens'
2021-07-19 18:40:02	Hecate	[21:11:19] fair enough
2021-07-19 18:40:02	Hecate	[21:11:20] so
2021-07-19 18:40:02	monochrom	[21:11:30] fib :: Int -> Int -> Int -> Int -> Int  let wingman guess what I want!
2021-07-19 18:40:02	Hecate	[21:11:32] Data.Text.Read.decimal "3"
2021-07-19 18:40:02	Hecate	[21:11:35] % Data.Text.Read.decimal "3"
2021-07-19 18:40:02	yahb	[21:11:35] Hecate: ; <interactive>:224:24: error:; * Couldn't match type `[Char]' with `Data.Text.Internal.Text'; Expected: Data.Text.Internal.Text; Actual: GHC.Base.String; * In the first argument of `Data.Text.Read.decimal', namely `"3"'; In the expression: Data.Text.Read.decimal "3"; In an equation for `it': it = Data.Text.Read.decimal "3"
2021-07-19 18:40:02	Hecate	[21:11:39] curse
2021-07-19 18:40:02	Hecate	[21:11:46] % import qualified Data.Text as T
2021-07-19 18:40:02	yahb	[21:11:46] Hecate: 
2021-07-19 18:40:02	Hecate	[21:11:52] % Data.Text.Read.decimal (T.pack "3")
2021-07-19 18:40:02	yahb	[21:11:53] Hecate: Right (3,"")
2021-07-19 18:40:02	Hecate	[21:11:57] % Data.Text.Read.decimal (T.pack "3x")
2021-07-19 18:40:02	yahb	[21:11:57] Hecate: Right (3,"x")
2021-07-19 18:40:02	Hecate	[21:12:08] dexterfoo: check this ^
2021-07-19 18:40:02	lechner	[21:13:53] davean: how do i use . in that line, please?
2021-07-19 18:40:02	maerwald	[21:15:08] sometimes I wonder why I even write documentation... all it does is confuse me 2 weeks later
2021-07-19 18:40:02	maerwald	[21:15:39] "I tried to figure out what this does, but didn't manage. But I wrote down my crippled thought regardless"
2021-07-19 18:40:02	dexterfoo	[21:15:45] Hecate: thanks!
2021-07-19 18:40:02	Hecate	[21:16:28] maerwald: because you don't know how to talk to yourself yet :P
2021-07-19 18:40:02	Hecate	[21:16:34] dexterfoo: you're welcome :)
2021-07-19 18:40:02	maerwald	[21:16:44] Hecate: preciousssss
2021-07-19 18:40:02	lechner	[21:20:32] Hi, in     printf "%s:%d" $ map ($ struct) [stringAccessor intAccessor]     does map work only when the return types are the same?
2021-07-19 18:40:02	lechner	[21:20:55] actually, there is a comma in there
2021-07-19 18:40:02	geekosaur	[21:21:05] all elements of a list must have the same type, yes
2021-07-19 18:40:02	lechner	[21:22:27] thanks. i could prosumably use 'show'
2021-07-19 18:40:02	geekosaur	[21:23:05] that's the usual way to do it, yes
2021-07-19 18:40:02	geekosaur	[21:23:14] don't forget to change the %d to %s
2021-07-19 18:40:02	lechner	[21:24:18] at some point, that tips the scale toward  putStrLn
2021-07-19 18:40:02	geekosaur	[21:24:30] yes
2021-07-19 18:40:02	dsal	[21:27:27] lechner: You could make a function that does the "%s:%d" part pretty easily and NamedFieldPuns or RecordWildCards would make it fairly short.
2021-07-19 18:40:02	lechner	[21:29:28] dsal: that sounds like a great idea! let's do that in one minute please.
2021-07-19 18:40:02	lechner	[21:30:04] meanwhile i am learning. why doesn't that work:   printf "Expecting scheduler on %s:%s.\n" $ map ($ scheduler config) [Connection.host, show . Connection.listen_port]
2021-07-19 18:40:02	lechner	[21:31:55] the point here is the partial application of 'show'
2021-07-19 18:40:02	[exa]	[21:32:01] lechner: what's the error?
2021-07-19 18:40:02	lechner	[21:32:32] https://paste.debian.net/1204829/
2021-07-19 18:40:02	geekosaur	[21:32:45] I think you have multiple problems there
2021-07-19 18:40:02	geekosaur	[21:33:12] for one, a list is not a collection of applications
2021-07-19 18:40:02	dsal	[21:33:16] lechner: A list isn't two arguments.
2021-07-19 18:40:02	dsal	[21:33:26] Or phrased how geekosaur said it.
2021-07-19 18:40:02	[exa]	[21:33:55] lechner: why still keep printf? (just curious)
2021-07-19 18:40:02	lechner	[21:34:19] just chewing on other things :)
2021-07-19 18:40:02	lechner	[21:34:54] [exa]: i am not so fond of ++ "[" ++ exa ++ "]" ++ ....
2021-07-19 18:40:02	geekosaur	[21:35:14] there is concat
2021-07-19 18:40:02	oso	[21:35:15] `concat`?
2021-07-19 18:40:02	dsal	[21:35:43] I don't use ++ in general, but I do use fold for logging.
2021-07-19 18:40:02	monochrom	[21:36:04] $ kills printf type inference. Seriously. Just don't use $.
2021-07-19 18:40:02	[exa]	[21:36:42] lechner: `concat [all, this, stuff]` is a widely used pattern. Esp good when combined with `intercalate`
2021-07-19 18:40:02	lechner	[21:37:01] monochrom: for some reason it seemed i needed $
2021-07-19 18:40:02	dsal	[21:37:40] lechner: does it work with $ ?
2021-07-19 18:40:02	monochrom	[21:37:43] Sure, "map ($ x) [f, g, h]" has just cause.  I am referring to "printf fmt $ ..."
2021-07-19 18:40:02	lechner	[21:37:56] okay, i'll change that but why is my partial application wrong. could someone please restate?
2021-07-19 18:40:02	dsal	[21:37:57] :t ($)
2021-07-19 18:40:02	lambdabot	[21:37:58] (a -> b) -> a -> b
2021-07-19 18:40:02	geekosaur	[21:38:17] lechner, you are attempting to use a list as two applications
2021-07-19 18:40:02	lechner	[21:38:17] monochrom: i meant that one
2021-07-19 18:40:02	[exa]	[21:38:25] lechner: the partial application is right (at least so it seems to me), the problem is that you're giving printf 1 argument and specify 2 in format
2021-07-19 18:40:02	dsal	[21:38:37] lechner: If it doesn't work, then it's not fair to say that you needed it.
2021-07-19 18:40:02	geekosaur	[21:38:43] one list is one application, not two
2021-07-19 18:40:02	dsal	[21:39:17] > (+) $ 1 $ 2
2021-07-19 18:40:02	lambdabot	[21:39:18]  error:
2021-07-19 18:40:02	lambdabot	[21:39:18]      • Could not deduce (Num t0)
2021-07-19 18:40:02	lambdabot	[21:39:18]        from the context: (Num a, Num t, Num (t -> a))
2021-07-19 18:40:02	dsal	[21:39:55] $ isn't a syntactic feature.  It's just a function.  And it will break your applications if effective arity is > 1
2021-07-19 18:40:02	lechner	[21:40:01] [exa]: https://paste.debian.net/1204830/
2021-07-19 18:40:02	[exa]	[21:40:44] dsal: you'd need -XChurchNumerals
2021-07-19 18:40:02	dsal	[21:40:48] You might try breaking that into different statements to understand it better.
2021-07-19 18:40:02	geekosaur	[21:41:16] lechner, contemplate this:
2021-07-19 18:40:02	geekosaur	[21:41:25] > (+) [1,2]
2021-07-19 18:40:02	lambdabot	[21:41:27]  error:
2021-07-19 18:40:02	lambdabot	[21:41:27]      • No instance for (Num [Integer]) arising from a use of ‘e_112’
2021-07-19 18:40:02	lambdabot	[21:41:27]      • In the expression: e_112
2021-07-19 18:40:02	geekosaur	[21:41:43] hm, (+) is not the best example there
2021-07-19 18:40:02	monochrom	[21:41:54] (&&) [False, False]
2021-07-19 18:40:02	[exa]	[21:41:57] lechner: yeah there printf uses `map` as the first argument, likely not very printable
2021-07-19 18:40:02	geekosaur	[21:41:58] > (++) ["a","b"]
2021-07-19 18:40:02	lambdabot	[21:42:00]  <[[Char]] -> [[Char]]>
2021-07-19 18:40:02	lechner	[21:42:03] geekosaur: isn't that here four applications?   https://salsa.debian.org/lintian/kickoff/-/blob/master/Collect.hs#L68
2021-07-19 18:40:02	lechner	[21:42:40] [exa]: yeah, that part i get now
2021-07-19 18:40:02	monochrom	[21:42:40] one single list.
2021-07-19 18:40:02	geekosaur	[21:42:46] lechner, no, it is a 4-element list
2021-07-19 18:40:02	dsal	[21:42:56] :t map
2021-07-19 18:40:02	lambdabot	[21:42:57] (a -> b) -> [a] -> [b]
2021-07-19 18:40:02	geekosaur	[21:43:06] thisis not lisp, a list is not a group of applications
2021-07-19 18:40:02	dsal	[21:43:23] map takes a function and applies it to each element inside a list.  One list in, one list out.
2021-07-19 18:40:02	lechner	[21:44:39] that's what i am looking for, except one member (of all partially or unapplied functions) is specified as    a . b 
2021-07-19 18:40:02	dsal	[21:45:19] You're doing several things at once.  You will likely have more success if you break them down a bit.
2021-07-19 18:40:02	lechner	[21:45:53] dsal: let's go with your approach. i am reading up on puns
2021-07-19 18:40:02	dsal	[21:45:54] A list is one thing, but it's not what your printf wants.  So to work backwards, you'll have to figure out how to make what your printf wants.
2021-07-19 18:40:02	lechner	[21:46:03] yes
2021-07-19 18:40:02	lechner	[21:46:14] let's chuck printf
2021-07-19 18:40:02	dsal	[21:46:17] My approach is to make a function that formats  your connection string.
2021-07-19 18:40:02	dsal	[21:47:12] In MonadLogger, you can call that ToLogStr, but that's the opposite direction from "do less stuff"  :)
2021-07-19 18:40:02	lechner	[21:54:50] can i define an instance of 'show' to return the string     host ++ ":" ++ listen_port     for a type that has both?
2021-07-19 18:40:02	geekosaur	[21:55:05] you can but you shouldn't
2021-07-19 18:40:02	lechner	[21:55:20] why not, please?
2021-07-19 18:40:02	geekosaur	[21:55:47] an instance of Show should match an instance of Read and ideally be a fragment of Haskell source that will reproduce a value of the type within ghc /  ghci
2021-07-19 18:40:02	geekosaur	[21:56:37] otherwise you run into issues Show-ing or Read-ing structures that contain values of that type
2021-07-19 18:40:02	lechner	[21:56:39] could i add both?
2021-07-19 18:40:02	geekosaur	[21:57:38] what do you mean?
2021-07-19 18:40:02	lechner	[21:58:00] Show and Read
2021-07-19 18:40:02	dsal	[21:58:40] lechner: That's not what show is for.  This is why MonadLogger defines ToLogStr.  You can make your own.
2021-07-19 18:40:02	dminuoso	[21:59:47] geekosaur: Strictly speaking, that is only requires for deriving generated instances. This notion that they "should" seems to be based in rumour or just an observation of established practice.
2021-07-19 18:40:02	dsal	[21:59:47] You *can* define your own Show and Read if you're pretty sure you can encapsulate all of the structure you want.  It's not definitely the wrong idea all the time, but it's not easier than making something specific for logging and having your logger log with it.
2021-07-19 18:40:02	dsal	[22:00:39] I think it's the date/time stuff that has fancy Show instances that just make life miserable when you have them in data structures.
2021-07-19 18:40:02	lechner	[22:01:08] i should not use UTCTime in JSON decls?
2021-07-19 18:40:02	pavonia	[22:01:13] Custom Show instances are a PITA if you have to debug things. Just don't do it
2021-07-19 18:40:02	lechner	[22:01:22] okay
2021-07-19 18:40:02	monochrom	[22:01:42] Established practice is still something to respect.  Of course, "respect" allows exceptions.  OK I'm on a fence, I'll stop now.
2021-07-19 18:40:02	lechner	[22:02:04] i'm just learning
2021-07-19 18:40:02	sm	[22:04:01] for learning, do whatever you like :)
2021-07-19 18:40:02	exarkun	[22:04:58] Where's the Haskell implementation of https://en.wikipedia.org/wiki/Turtle_graphics ?
2021-07-19 18:40:02	lechner	[22:05:52] what's the precedence between $ and ++ please?
2021-07-19 18:40:02	dminuoso	[22:06:55] %i ($)
2021-07-19 18:40:02	dminuoso	[22:07:05] % :i ($)
2021-07-19 18:40:02	yahb	[22:07:05] dminuoso: ($) :: (a -> b) -> a -> b -- Defined in `GHC.Base'; infixr 0 $
2021-07-19 18:40:02	dminuoso	[22:07:07] % :i (++)
2021-07-19 18:40:02	yahb	[22:07:08] dminuoso: (++) :: [a] -> [a] -> [a] -- Defined in `GHC.Base'; infixr 5 ++
2021-07-19 18:40:02	dminuoso	[22:07:18] lechner: ^- See the fixity declarations?
2021-07-19 18:40:02	dminuoso	[22:08:05] The number is the precedence level
2021-07-19 18:40:02	dsal	[22:08:09] % :i (<>)
2021-07-19 18:40:02	yahb	[22:08:09] dsal: type GHC.Base.Semigroup :: * -> Constraint; class GHC.Base.Semigroup a where; (<>) :: a -> a -> a; ...; -- Defined in `GHC.Base'; infixr 6 <>
2021-07-19 18:40:02	dsal	[22:08:17] That's interesting.
2021-07-19 18:40:02	dminuoso	[22:08:20] And the `r` in infixr means its right-associative. We also have infixl for left associative
2021-07-19 18:40:02	dminuoso	[22:09:23] If no fixity is declared, an operator defaults to infixl 9.
2021-07-19 18:40:02	lechner	[22:09:33] dsal: ++ binds more tightly than $ right?
2021-07-19 18:40:02	dminuoso	[22:09:41] Yes.
2021-07-19 18:40:02	monochrom	[22:10:01] What do "0" and "5" tell you?
2021-07-19 18:40:02	lechner	[22:10:32] a relative ordering
2021-07-19 18:40:02	dsal	[22:10:35] I don't ever use ++.  I just never considered ++ was lower than <>
2021-07-19 18:40:02	lechner	[22:11:05] what is <> please? i have only seen that in purescript
2021-07-19 18:40:02	dsal	[22:11:14] :t (<>)
2021-07-19 18:40:02	lambdabot	[22:11:16] Semigroup a => a -> a -> a
2021-07-19 18:40:02	dsal	[22:11:17] :t (++)
2021-07-19 18:40:02	lambdabot	[22:11:19] [a] -> [a] -> [a]
2021-07-19 18:40:02	dsal	[22:11:35] ++ only works for lists.  <> is like ++ but works for many other types.
2021-07-19 18:40:02	xsperry	[22:11:40] lechner, you can think of it as a more general ++. it works with more than just lists
2021-07-19 18:40:02	lechner	[22:12:02] dsal: should is stick to concat instead of ++?
2021-07-19 18:40:02	dsal	[22:12:29] :t concat
2021-07-19 18:40:02	lambdabot	[22:12:30] Foldable t => t [a] -> [a]
2021-07-19 18:40:02	dsal	[22:12:37] :t fold
2021-07-19 18:40:02	lambdabot	[22:12:39] (Foldable t, Monoid m) => t m -> m
2021-07-19 18:40:02	dsal	[22:12:51] That doesn't do the same thing, but depending on what you're doing, it might be better.
2021-07-19 18:40:02	dsal	[22:13:18] I use <> often, I just don't use ++.  You can use ++ if you like.  I was just commenting on the precedence.
2021-07-19 18:40:02	dsal	[22:14:41] I've got logging functions like `logErrorL, logInfoL, logDbgL :: (Foldable f, MonadLogger m) => f T.Text-> m ()` which are helpful when I want to log a list of Texts.  e.g., `logInfoL = logInfoN . fold`
2021-07-19 18:40:02	lechner	[22:27:12] are those two lines acceptable for a newbie?  https://dpaste.org/sqiW#L96,97
2021-07-19 18:40:02	dminuoso	[22:28:48] Looks fine.
2021-07-19 18:40:02	lechner	[22:29:12] thanks to everyone for your help!
2021-07-19 18:40:02	dminuoso	[22:29:22] The `nice 19` looks dubious though.
2021-07-19 18:40:02	lechner	[22:29:48] what should it look like?
2021-07-19 18:40:02	lechner	[22:31:08] I'm trying to do this:   https://salsa.debian.org/lintian/kickoff/-/blob/master/runner#L57
2021-07-19 18:40:02	lechner	[23:05:32] why do ++ and concat not do the same thing, please?
2021-07-19 18:40:02	int-e	[23:05:51] they have different types?
2021-07-19 18:40:02	geekosaur	[23:06:39] what do you mean by "not do the same thing"?
2021-07-19 18:40:02	geekosaur	[23:06:45] :t (++)
2021-07-19 18:40:02	lambdabot	[23:06:46] [a] -> [a] -> [a]
2021-07-19 18:40:02	int-e	[23:06:46] concat takes a list of lists (well, a traversable of lists, but let's simplify) and appends those; ++ takes two lists and appends them
2021-07-19 18:40:02	geekosaur	[23:06:58] :t concat
2021-07-19 18:40:02	lambdabot	[23:06:59] Foldable t => t [a] -> [a]
2021-07-19 18:40:02	int-e	[23:07:05] foldable, my bad
2021-07-19 18:40:02	int-e	[23:07:14] Why do we use "t" for a Foldable.
2021-07-19 18:40:02	lechner	[23:07:47] are they different when used with String?
2021-07-19 18:40:02	int-e	[23:07:55] (That's what misled me, though it shouldn't have.)
2021-07-19 18:40:02	geekosaur	[23:07:58] I think this may be ghc inferring a type and calling it "t" because that's the default
2021-07-19 18:40:02	int-e	[23:08:07] > concat ["a","b","c"]
2021-07-19 18:40:02	lambdabot	[23:08:09]  "abc"
2021-07-19 18:40:02	geekosaur	[23:08:09] lechner, a String is just a list of Char
2021-07-19 18:40:02	int-e	[23:08:11] > "a" ++ "b"
2021-07-19 18:40:02	lambdabot	[23:08:12]  "ab"
2021-07-19 18:40:02	int-e	[23:08:19] it's still a completely different type
2021-07-19 18:40:02	dsal	[23:08:37] Two things and a list of two things are not the same type.
2021-07-19 18:40:02	int-e	[23:08:58] You can rewrite  xs ++ ys  as  concat [xs,ys]  if you like.
2021-07-19 18:40:02	lechner	[23:09:22] that's what i meant. thanks!
2021-07-19 18:40:02	int-e	[23:09:27] (it may come at a small performance penalty)
2021-07-19 18:40:02	int-e	[23:09:34] (I haven't checked)
2021-07-19 18:40:02	lechner	[23:10:22] performance is a binary event here atm
2021-07-19 18:40:02	int-e	[23:11:55] Checked, evidently  concat [xs, ys]  gets rewritten to  xs ++ ys, so there's no difference.
2021-07-19 18:40:02	int-e	[23:12:10] (when compiling with ghc with optimizations enabled)
2021-07-19 18:40:02	int-e	[23:13:41] I don't know what "binary event" means.
2021-07-19 18:40:02	arahael	[23:13:44] The joy of a bit of early-morning haskell before work. :D
2021-07-19 18:40:02	beaky	[23:14:08] hello does ghc do whole program optimization like mlton 
2021-07-19 18:40:02	arahael	[23:14:24] It's _remarkable_ how one can get by with sloppy code in haskell: You can trivially and painlessly refactor it.  So nice.
2021-07-19 18:40:02	int-e	[23:15:18] beaky: no, it compiles modules separately, though there's inlining across modules for small functions.
2021-07-19 18:40:02	arahael	[23:17:27] int-e: There was this last year, though: https://www.patreon.com/posts/introducing-ghc-38173710  Has anything happened in that space since then or has it fizzled out?
2021-07-19 18:40:02	int-e	[23:18:45] I don't really know. I saw that there was some discussion on GRIN on here 2 hours ago...
2021-07-19 18:40:02	geekosaur	[23:19:43] there is apparently still some ongoing work but it hasn't been upstreamed and isn't yet usable in production
2021-07-19 18:40:02	int-e	[23:21:49] Or is that 26 hours ago, my client has no dates in the timestamp, and my feeling for time is all messed up
2021-07-19 18:40:02	arahael	[23:22:39] I'm personally a bit torn between thinking that that research is awesome - and or wishing that compilation took way less memory, even though memory doesn't seem to affect me because I never have less than 16 GB of RAM these days.
2021-07-19 18:40:02	geekosaur	[23:23:25] 26 hours ago more likely
2021-07-19 18:40:02	geekosaur	[23:23:37] was when I was in the discussion at least
2021-07-19 18:40:02	int-e	[23:24:18] cf. https://paste.debian.net/hidden/d3d82af6/
2021-07-19 18:40:02	int-e	[23:25:17] Yes, it was 26 hours ago. I still don't know whether it's related to that patreon thing. The topic clearly overlaps heavily.
2021-07-19 18:40:02	int-e	[23:26:10] (don't bookmark that paste, I set it to expire in 24h)
2021-07-19 18:40:02	geekosaur	[23:27:15] people can get it from ircbrowse if they want it :)
2021-07-19 18:40:02	geekosaur	[23:27:40] admittedly it'd help if it were searchable, but can't have everything
2021-07-19 18:40:02	geekosaur	[23:29:29] that was the one I was talking about, at least. don't know with 100% certainty it was the one dmj` intended, but it seemed to match up
2021-07-19 18:40:02	dminuoso	[00:18:21] Mmm. Im doing an URL style percent encoding/decoding of bytestring. I have two Word8 and want to prepend them to a ByteString, what's the efficient way to do this here?
2021-07-19 18:40:02	Axman6	[00:19:32] I would have a look at the bytestring-base16 code to find efficient ways to do things. otherwise I'd probably just say use a builder if it's likely you'll be doing more appends/prepends
2021-07-19 18:40:02	dminuoso	[00:21:33] I was thinking along the lines of: let dualton c1 c2 = unsafeCreate 2 $ \p -> poke p c1 >> poke (p `plusPtr` 1) c2 in dualton x1 x2 <> rest
2021-07-19 18:40:02	dminuoso	[00:21:45] Axman6: Mmm.
2021-07-19 18:40:02	dminuoso	[00:22:10] Ah, yes. Perhaps that is the better way indeed
2021-07-19 18:40:02	Axman6	[00:22:57] if you know exactly how large the result will be there's definitely tricks to make it fast, but usually if the question is ')how do I construct a bytestring from parts" the answer is Builder
2021-07-19 18:40:02	dminuoso	[00:26:36] Mmm, so on the outside Im inside conduit. Maybe there's a way to stream a bytestring builder into a conduit
2021-07-19 18:40:02	dminuoso	[00:27:21] Apparently not, but that's fine
2021-07-19 18:40:02	dminuoso	[00:29:46] @tell burnsidesLlama It just occured to me, that the generalization you are looking for is `scanl` or `scanr`.
2021-07-19 18:40:02	lambdabot	[00:29:46] Consider it noted.
2021-07-19 18:40:02	Axman6	[00:36:38] dminuoso: using https://hackage.haskell.org/package/bytestring-0.11.1.0/docs/Data-ByteString-Builder-Internal.html#t:ChunkIOStream you can efficiently stream a bytestring
2021-07-19 18:40:02	Axman6	[00:41:38] ... maybe, actually struggling to see how to take in Builders and then use that
2021-07-19 18:40:02	dmj`	[02:40:46] int-e: there is a patreon for GRIN work yes
2021-07-19 18:40:02	dmj`	[02:41:13] Some of what I said is related to that
2021-07-19 18:40:02	GeorgeArmani	[03:11:30] Can someone help me understand this error message ?
2021-07-19 18:40:02	GeorgeArmani	[03:11:32] any' :: (a -> Bool) -> a -> Bool
2021-07-19 18:40:02	GeorgeArmani	[03:11:32] any' f xs = foldl step False xs where
2021-07-19 18:40:02	GeorgeArmani	[03:11:33]     step acc (y:ys)
2021-07-19 18:40:02	GeorgeArmani	[03:11:33]         | f y = True
2021-07-19 18:40:02	GeorgeArmani	[03:11:34]         | otherwise = acc
2021-07-19 18:40:02	GeorgeArmani	[03:11:41] Fold.hs:52:30: error:
2021-07-19 18:40:02	GeorgeArmani	[03:11:42]     • Occurs check: cannot construct the infinite type: a ~ t0 [a]
2021-07-19 18:40:02	GeorgeArmani	[03:11:42]     • In the third argument of ‘foldl’, namely ‘xs’
2021-07-19 18:40:02	GeorgeArmani	[03:11:43]       In the expression: foldl step False xs
2021-07-19 18:40:02	GeorgeArmani	[03:11:43]       In an equation for ‘any'’:
2021-07-19 18:40:02	GeorgeArmani	[03:11:44]           any' f xs
2021-07-19 18:40:02	GeorgeArmani	[03:11:44]             = foldl step False xs
2021-07-19 18:40:02	GeorgeArmani	[03:11:45]             where
2021-07-19 18:40:02	GeorgeArmani	[03:11:45]                 step acc (y : ys)
2021-07-19 18:40:02	GeorgeArmani	[03:11:46]                   | f y = True
2021-07-19 18:40:02	GeorgeArmani	[03:11:46]                   | otherwise = acc
2021-07-19 18:40:02	geekosaur	[03:13:31] please don't paste directly into the channel like that
2021-07-19 18:40:02	Axman6	[03:13:32] @where paste
2021-07-19 18:40:02	lambdabot	[03:13:32] Help us help you: please paste full code, input and/or output at e.g. https://paste.tomsmeding.com
2021-07-19 18:40:02	geekosaur	[03:14:59] but it's telling you that 'a' cannot at the same time be a Foldable over a list and an element of that list
2021-07-19 18:40:02	GeorgeArmani	[03:15:15] https://paste.tomsmeding.com/qsfDJyUC#file-1
2021-07-19 18:40:02	Axman6	[03:15:16] yeah take a close look at the type you've given any'
2021-07-19 18:40:02	geekosaur	[03:15:18] think about your type signature
2021-07-19 18:40:02	geekosaur	[03:18:15] it may also be helpful to give step the type signature you think it should have
2021-07-19 18:40:02	GeorgeArmani	[03:39:44] I'm really having a tough time sorting that out
2021-07-19 18:40:02	geekosaur	[03:41:22] what does the type "a" in your type signature represent?
2021-07-19 18:40:02	geekosaur	[03:41:49] remember that it's going to be the same type everywhere in that signature
2021-07-19 18:40:02	GeorgeArmani	[03:43:29] I think it should be a list every time its used?
2021-07-19 18:40:02	geekosaur	[03:43:48] is it in (a -> Bool)?
2021-07-19 18:40:02	GeorgeArmani	[03:47:05] ahhhh so should it be ------- any' :: (a -> Bool) -> [a] -> Bool
2021-07-19 18:40:02	geekosaur	[03:47:15] yes
2021-07-19 18:40:02	geekosaur	[03:49:09] I suspect from your original error that this will only fix one problem, though
2021-07-19 18:40:02	GeorgeArmani	[03:49:25] correct
2021-07-19 18:40:02	GeorgeArmani	[03:50:45] In fact, I had that type signature originally but changed it to deal with this error https://paste.tomsmeding.com/ntGaaQnX
2021-07-19 18:40:02	GeorgeArmani	[03:51:42] Wait just putting [xs] like that worked 
2021-07-19 18:40:02	GeorgeArmani	[03:52:05] https://paste.tomsmeding.com/qirkhcRw
2021-07-19 18:40:02	GeorgeArmani	[03:52:10] Im not sure why though
2021-07-19 18:40:02	GeorgeArmani	[03:55:08] I get it now. Thanks Geekosaur. 
2021-07-19 18:40:02	geekosaur	[03:55:53] yeh, you are splitting the list in step as well when you don't need to because fold already is
2021-07-19 18:40:02	geekosaur	[03:56:25] so it thinks you need a list of lists. that's why I suggested putting a type signature on step
2021-07-19 18:40:02	GeorgeArmani	[03:56:37] exactly, I deleted calling head in step and removed the [] around xs
2021-07-19 18:40:02	GeorgeArmani	[04:04:03] Sorry for asking so many questions. I am confused about the type signature for step.
2021-07-19 18:40:02	GeorgeArmani	[04:04:41] I thought it would be Bool -> a -> Bool , but it is throwing an error at compile
2021-07-19 18:40:02	h98	[04:07:51] what's your code right now? that type signature sounds right to me
2021-07-19 18:40:02	GeorgeArmani	[04:09:13] https://paste.tomsmeding.com/kU1zB95f
2021-07-19 18:40:02	geekosaur	[04:09:30] oh, right, this requires ScopedTypeVariables to specify a signature
2021-07-19 18:40:02	geekosaur	[04:10:30] otherwise the a you specify in the type signature for step is unrelated to the one specified for any', but that breaks f
2021-07-19 18:40:02	GeorgeArmani	[04:10:31] Ok ill look into that
2021-07-19 18:40:02	geekosaur	[04:11:11] sometimes ghc is annoying that way
2021-07-19 18:40:02	h98	[04:11:22] should compile as-is if you delete the type signature now
2021-07-19 18:40:02	GeorgeArmani	[04:11:42] ahhhh ok. That is a little frustrating. 
2021-07-19 18:40:02	GeorgeArmani	[04:12:04] yeah h98 thank you. I just wanted to make sure that I understood what was going on fully.
2021-07-19 18:40:02	geekosaur	[04:12:04] yes, but I suggested adding the type signature, having forgotten it wouldn';t work :(
2021-07-19 18:40:02	GeorgeArmani	[04:12:42] All good :) . Appreciate the help, Geekosaur.
2021-07-19 18:40:02	lechner	[04:52:56] Hi, is it possible to catch decompression errors from LZMA here?   https://salsa.debian.org/lintian/kickoff/-/blob/master/Collect.hs#L82
2021-07-19 18:40:02	dsal	[05:10:48] lechner: It uses MonadFail.  You could use exceptions
2021-07-19 18:40:02	dsal	[05:10:52] @package exceptions
2021-07-19 18:40:02	lambdabot	[05:10:53] https://hackage.haskell.org/package/exceptions
2021-07-19 18:40:02	Hecate	[05:24:13] o/
2021-07-19 18:40:02	Hecate	[05:24:26] I'm trying to better understand how I can use Comonad in my programs
2021-07-19 18:40:02	Hecate	[05:25:04] I've seen *one* usage of Comonad in a codebase, in which it acted as a priviledged accessor, like https://twitter.com/TechnoEmpress/status/1416992128643776513
2021-07-19 18:40:02	Hecate	[05:26:04] but I think the usecase really stops at running "whatever <- asks extract"
2021-07-19 18:40:02	Hecate	[05:27:01] But then it feels more like I've created one more indirection
2021-07-19 18:40:02	Hecate	[05:27:54] that being said if I need more polymorphism on the 'Comonad r' this could be good
2021-07-19 18:40:02	lechner	[05:32:05] dsal: thanks!
2021-07-19 18:40:02	Guest95	[05:43:02] Hello! I currently use Spacemacs as my Haskell code editor. What code editor would you recommend? Is Yi worth looking in to?
2021-07-19 18:40:02	Hecate	[05:46:17] Guest95: Yi was an interesting project but I fear it may be dead these days
2021-07-19 18:40:02	Hecate	[05:46:33] Guest95: I use neovim + lua plugins and config (if you're allergic to too much VimL)
2021-07-19 18:40:02	lechner	[05:56:50] Thanks for the pointer to yi. I may have found a minimal replacement for things like commit messages for mg, which is even less maintained and can't do Unicode
2021-07-19 18:40:02	guest719	[08:48:19] why `traverse` would immediatly exit when it meet a Left a?
2021-07-19 18:40:02	guest719	[08:48:51] traverse (\i -> if odd i then Right () else Left i) [1..10]
2021-07-19 18:40:02	lars8	[08:49:42] >  traverse (\i -> if odd i then Right () else Left i) [1..10]
2021-07-19 18:40:02	lambdabot	[08:49:44]  Left 2
2021-07-19 18:40:02	lars8	[08:51:41] > sequence [Left 1, Right 2]
2021-07-19 18:40:02	lambdabot	[08:51:42]  Left 1
2021-07-19 18:40:02	lars8	[08:51:46] @src sequence
2021-07-19 18:40:02	lambdabot	[08:51:46] sequence []     = return []
2021-07-19 18:40:02	lambdabot	[08:51:46] sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
2021-07-19 18:40:02	lambdabot	[08:51:46] --OR
2021-07-19 18:40:02	lambdabot	[08:51:46] sequence xs = foldr (liftM2 (:)) (return []) xs
2021-07-19 18:40:02	lars8	[08:52:00] does that help?
2021-07-19 18:40:02	lars8	[08:52:50] traverse f is basically sequence . map f
2021-07-19 18:40:02	guest719	[08:53:22] but why it meet Left a will early exit?
2021-07-19 18:40:02	lars8	[08:53:49] because that's what liftM2 does
2021-07-19 18:40:02	guest719	[08:54:04] @src liftM2
2021-07-19 18:40:02	lambdabot	[08:54:05] liftM2 f m1 m2 = do
2021-07-19 18:40:02	lambdabot	[08:54:05]     x1 <- m1
2021-07-19 18:40:02	lambdabot	[08:54:05]     x2 <- m2
2021-07-19 18:40:02	lambdabot	[08:54:05]     return (f x1 x2)
2021-07-19 18:40:02	lars8	[08:54:23] > liftM2 (+) (Right 1) (Right 2)
2021-07-19 18:40:02	lambdabot	[08:54:25]  Right 3
2021-07-19 18:40:02	lars8	[08:54:35] > liftM2 (+) (Right 1) (Left 2)
2021-07-19 18:40:02	lambdabot	[08:54:36]  Left 2
2021-07-19 18:40:02	dminuoso	[08:54:48] guest719: `Either a`, like `Maybe`, models computations with exceptions.
2021-07-19 18:40:02	dminuoso	[08:55:07] So a `Left err` or `Nothing` has the same semantics as an exception, it shortcircuits the entire computation
2021-07-19 18:40:02	lars8	[08:55:12] if any argument is Left, entire computation is Left
2021-07-19 18:40:02	guest719	[08:55:17] oh, Left 2 will break the computation chain in >>=
2021-07-19 18:40:02	dminuoso	[08:55:21] Yes.
2021-07-19 18:40:02	guest719	[08:55:52] dminuoso and why it's that? define in >>= ?
2021-07-19 18:40:02	dminuoso	[08:55:55] guest719: Yes.
2021-07-19 18:40:02	dminuoso	[08:56:26] The applicative and monadic interface of `Maybe` and `Either s` simply models exceptions.
2021-07-19 18:40:02	guest719	[08:56:27] dminuoso except Left a and Nothing, is there other would break computation chain?
2021-07-19 18:40:02	dminuoso	[08:56:30] There's no deeper reason than that.
2021-07-19 18:40:02	dminuoso	[08:56:39] Sure there are others
2021-07-19 18:40:02	guest719	[08:56:46] for examples?
2021-07-19 18:40:02	dminuoso	[08:57:06] ExceptT 
2021-07-19 18:40:02	dminuoso	[08:57:19] Though that's just an `Either s` in disguise
2021-07-19 18:40:02	guest719	[08:57:36] I can't help when you said Exception, I always think about run-time Exceptions
2021-07-19 18:40:02	dminuoso	[08:57:48] Yes, these are pretty much like runtime exceptions!
2021-07-19 18:40:02	dminuoso	[08:57:51] Consider:
2021-07-19 18:40:02	guest719	[08:57:53] why haskell would give it another name
2021-07-19 18:40:02	dminuoso	[08:58:02] These are value-level/user-defined exceptions
2021-07-19 18:40:02	guest719	[08:58:02] wouldn't
2021-07-19 18:40:02	dminuoso	[08:58:38] guest719: We also have regular RTS exceptions as you know them inside IO.
2021-07-19 18:40:02	dminuoso	[08:58:48] But in pure computations it might still be useful to have shortcircuiting semantics
2021-07-19 18:40:02	dminuoso	[08:58:57] Like with traverse.
2021-07-19 18:40:02	dminuoso	[08:59:18] Say you have a tree, and you want to process each node - but in a way that if you generate an error at any, that the entire computation is considered failed.
2021-07-19 18:40:02	dminuoso	[08:59:46] Then you can use `Maybe` or `Either s` (depending on whether you want to keep information about the error condition)
2021-07-19 18:40:02	dminuoso	[09:00:06] Then producing `Nothing` is semantically equivalent to throwing an exception, except we can do this in pure code and without any special support from the runtime system.
2021-07-19 18:40:02	dminuoso	[09:00:20] data Maybe a = Nothin | Just a
2021-07-19 18:40:02	dminuoso	[09:00:25] instance Monad Maybe where ...
2021-07-19 18:40:02	dminuoso	[09:00:42] Voila! You have created exception semantics on your own, no exception primitive support needed in the language.
2021-07-19 18:40:02	albet70	[09:03:00] can we think it as a failure computation?
2021-07-19 18:40:02	albet70	[09:03:37] what about 1/0?
2021-07-19 18:40:02	albet70	[09:03:46] 1/0 is an Exception?
2021-07-19 18:40:02	albet70	[09:04:05] IO failure is an Exception?
2021-07-19 18:40:02	albet70	[09:05:09] fmap (+1) Nothing would be an Exception?
2021-07-19 18:40:02	dminuoso	[09:05:30] `Nothing` acts as an exception, yes.
2021-07-19 18:40:02	dminuoso	[09:05:55] 1/0 is an interesting subject for several reasons
2021-07-19 18:40:02	dminuoso	[09:06:46] % :t (1/0)
2021-07-19 18:40:02	yahb	[09:06:46] dminuoso: ; <interactive>:1:3: error: Variable not in scope: (/) :: t0 -> t1 -> t
2021-07-19 18:40:02	dminuoso	[09:06:59] % :q
2021-07-19 18:40:02	yahb	[09:06:59] dminuoso: 
2021-07-19 18:40:02	dminuoso	[09:07:00] % :t (1/0)
2021-07-19 18:40:02	yahb	[09:07:01] dminuoso: Fractional a => a
2021-07-19 18:40:02	dminuoso	[09:07:06] % :i Fractional
2021-07-19 18:40:02	yahb	[09:07:08] dminuoso: type Fractional :: * -> Constraint; class Num a => Fractional a where; (/) :: a -> a -> a; recip :: a -> a; fromRational :: Rational -> a; {-# MINIMAL fromRational, (recip | (/)) #-}; -- Defined in `GHC.Real'; instance Fractional a => Fractional (Identity a) -- Defined in `Data.Functor.Identity'; instance forall a k (b :: k). Fractional a => Fractional (Const a b) -- Defined in `Data.Functor.Co
2021-07-19 18:40:02	dminuoso	[09:07:19] % :t (/)
2021-07-19 18:40:02	yahb	[09:07:20] dminuoso: Fractional a => a -> a -> a
2021-07-19 18:40:02	dminuoso	[09:07:34] albet70: ^- so you see, this is either Float or Double, at which point IEEE 754 semantics apply.
2021-07-19 18:40:02	dminuoso	[09:08:05] Under which 1/0 is defined to be either positive or negative infinity (depending on the sign of 0)
2021-07-19 18:40:02	dminuoso	[09:08:27] So 1/0 is actually a well defined value, perhaps unintuitively.
2021-07-19 18:40:02	dminuoso	[09:09:18] But, what you probably meant is:
2021-07-19 18:40:02	dminuoso	[09:09:22] % 1 `div` 0
2021-07-19 18:40:02	yahb	[09:09:22] dminuoso: *** Exception: divide by zero
2021-07-19 18:40:02	dminuoso	[09:09:31] % :t div
2021-07-19 18:40:02	yahb	[09:09:31] dminuoso: Integral a => a -> a -> a
2021-07-19 18:40:02	albet70	[09:10:04] yes, div 0
2021-07-19 18:40:02	dminuoso	[09:10:07] albet70: ^- so yeah, this is a partial computation. We could have also made it non-partial and given it the type `div :: Integral a => a -> a -> Maybe a`, which produces Nothing for that case.
2021-07-19 18:40:02	dminuoso	[09:12:02] albet70: In general, it's better to encode a failure as `Maybe` or `Either s` rather than producing an error (like div does)
2021-07-19 18:40:02	dminuoso	[09:12:34] albet70: The reason is, you cant catch an `error` sensibly (its impossible in pure code, and you have imprecise error semantics if you try to do this from IO). error is really a sad part in Haskell.
2021-07-19 18:40:02	dminuoso	[09:12:55] But you can catch a Nothing just fine (you just pattern match with case-of)
2021-07-19 18:40:02	dminuoso	[09:13:02] Dont even need IO for that.
2021-07-19 18:40:02	albet70	[09:15:25] but haskell does try catch to capture runtime errors like IO error
2021-07-19 18:40:02	albet70	[09:15:48] and IO socket error, how to use Either to detect?
2021-07-19 18:40:02	dminuoso	[09:16:01] haskell does not try and catch runtime errors at all
2021-07-19 18:40:02	dminuoso	[09:16:07] They blow up your entire program
2021-07-19 18:40:02	dminuoso	[09:17:30] You have to explicitly catch them in IO
2021-07-19 18:40:02	dminuoso	[09:17:44] And it's subtly difficult to do this because of lazy evaluation
2021-07-19 18:40:02	dminuoso	[09:17:47] Consider
2021-07-19 18:40:02	dminuoso	[09:17:49] % :t evaluate
2021-07-19 18:40:02	yahb	[09:17:49] dminuoso: a -> IO a
2021-07-19 18:40:02	dminuoso	[09:18:39] This one only evaluates up until WHNF. You could still have errors lingering in not-yet-evaluated parts. There's tricks to get around this, but you need to be aware of this 
2021-07-19 18:40:02	dminuoso	[09:19:34] It's why uses of `error` are highly discouraged, since it's completely unclear which library functions could possibly trigger an `error`. The most common one that regularly causes headaches for me is\
2021-07-19 18:40:02	dminuoso	[09:19:36] % :t read
2021-07-19 18:40:02	yahb	[09:19:36] dminuoso: Read a => String -> a
2021-07-19 18:40:02	dminuoso	[09:19:56] If you think about it, it should be dead obvious that this is *very* partial (by very I mean almost all strings produce an invalid result, only very few strings produce a parsable value)
2021-07-19 18:40:02	dminuoso	[09:20:24] But this type of error quickly bubbles up and cant be reasonably caught anymore
2021-07-19 18:40:02	dminuoso	[09:20:55] A way better function instead is:
2021-07-19 18:40:02	dminuoso	[09:20:57] % :t readMaybe
2021-07-19 18:40:02	yahb	[09:20:57] dminuoso: ; <interactive>:1:1: error: Variable not in scope: readMaybe
2021-07-19 18:40:02	dminuoso	[09:21:07] % import Data.Text (readMaybe)
2021-07-19 18:40:02	yahb	[09:21:07] dminuoso: ; <interactive>:1:19: error: Module `Data.Text' does not export `readMaybe'
2021-07-19 18:40:02	dminuoso	[09:21:17] % import Text.Read (readMaybe)
2021-07-19 18:40:02	yahb	[09:21:18] dminuoso: 
2021-07-19 18:40:02	dminuoso	[09:21:19] % :t readMaybe
2021-07-19 18:40:02	yahb	[09:21:19] dminuoso: Read a => String -> Maybe a
2021-07-19 18:40:02	guest719	[10:06:07] dminuoso about traverse "<dminuoso> Say you have a tree, and you want to process each node - but in a way that if you generate an error at any, that the entire computation is considered failed." could we use foldr >=> pure here? 
2021-07-19 18:40:02	guest719	[10:06:36] a bunch of function inside a list, then foldr
2021-07-19 18:40:02	guest719	[10:07:08] apply on this tree, if one node failed, then return immediatly
2021-07-19 18:40:02	jumper149	[10:14:45] Is it wrong to say "MonadPlus is obsolete"? Just like `return` is obsolete because of `pure`?
2021-07-19 18:40:02	moondog	[10:25:06] hi, quick question, suppose I'd like to parse Haskell files to find particular method calls and it's argument types, where should I start? Is there any tooling for that to avoid writing everything from scratch?
2021-07-19 18:40:02	dminuoso	[10:25:24] guest719: Firstly, `f >=> pure = f`
2021-07-19 18:40:02	dminuoso	[10:25:44] guest719: And what you are thinking of already is traverse precisely.
2021-07-19 18:40:02	dminuoso	[10:25:47] % :t traverse
2021-07-19 18:40:02	yahb	[10:25:47] dminuoso: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
2021-07-19 18:40:02	guest719	[10:26:33] dminuoso fmap can't do early exit because it's type, but >>= can do early exit
2021-07-19 18:40:02	dminuoso	[10:26:48] guest719: Yes, and traverse uses >> internally
2021-07-19 18:40:02	dminuoso	[10:26:55] (So it's a bit more general even)
2021-07-19 18:40:02	guest719	[10:26:56] dminuoso I remeber there're different between fmap and >>=
2021-07-19 18:40:02	dminuoso	[10:27:10] % :t (>>)
2021-07-19 18:40:02	yahb	[10:27:10] dminuoso: Monad m => m a -> m b -> m b
2021-07-19 18:40:02	guest719	[10:27:11] >>= can do if-else, and fmap can't do if-else
2021-07-19 18:40:02	dminuoso	[10:27:17] Well, strictly speaking:
2021-07-19 18:40:02	dminuoso	[10:27:20] % :t (*>)
2021-07-19 18:40:02	yahb	[10:27:20] dminuoso: Applicative f => f a -> f b -> f b
2021-07-19 18:40:02	dminuoso	[10:27:54] guest719: `traverse` can be thought to use (*>) internally, which is just an Applicative version of >>
2021-07-19 18:40:02	dminuoso	[10:28:04] Roughly the idea is:
2021-07-19 18:40:02	dminuoso	[10:29:39] We take this function (a -> f b) (say `String -> IO Int`)from above, and we `fmap` over the structure (say `[String]`). Then, each value is replaced with a computation of some type (say `IO Int`), so the whole structure then is `[IO Int]`.
2021-07-19 18:40:02	dibblego	[10:29:55] you might be thinking of traverse_
2021-07-19 18:40:02	dminuoso	[10:29:58] Then we `sequence` this, which turns `[IO Int] -> IO [Int]`
2021-07-19 18:40:02	dminuoso	[10:32:32] Imagine this to be: sequence (x:xs) = (:) <$> x <*> sequence xs; sequence [] = pure []
2021-07-19 18:40:02	dminuoso	[10:32:58] dibblego: Ah yeah. I guess that was wrong of me.
2021-07-19 18:40:02	dminuoso	[10:33:06] While I was typing the definition, I realized my mistake.
2021-07-19 18:40:02	dminuoso	[10:33:44] % mySequence (x:xs) = (:) <$> x <*> mySequence xs; mySequence [] = pure []
2021-07-19 18:40:02	yahb	[10:33:44] dminuoso: 
2021-07-19 18:40:02	dminuoso	[10:33:46] % :t mySequence
2021-07-19 18:40:02	yahb	[10:33:46] dminuoso: Applicative f => [f a] -> f [a]
2021-07-19 18:40:02	dibblego	[10:33:52] I think sequence is more obvious in the way you are trying to explain it, like this:
2021-07-19 18:40:02	dminuoso	[10:33:53] % mySequence [Just 10, Just 20, Just 30]
2021-07-19 18:40:02	yahb	[10:33:53] dminuoso: Just [10,20,30]
2021-07-19 18:40:02	dibblego	[10:34:20] (::.) = liftA2 (:); lift0 = pure; sequence (x:xs) = x ::. sequence xs; sequence [] = lift0 []
2021-07-19 18:40:02	dibblego	[10:35:56] once liftA2 is understood conceptually, then (*>) is quite simply: const id with some liftA2-ness
2021-07-19 18:40:02	albet70	[11:18:46] so could we say traverse another version of fmap which it can do earlier exit?
2021-07-19 18:40:02	[exa]	[11:21:01] "another" may be a weak label for the myriad of extra stuff it can do :]
2021-07-19 18:40:02	dminuoso	[11:28:04] albet70: Mmm, not just that.
2021-07-19 18:40:02	dminuoso	[11:28:38] albet70: Say you have a Tree of values, say of type String. For each string you want to query some database, and replace the string with some value you read from the database, say something of type User.
2021-07-19 18:40:02	dminuoso	[11:29:00] then you can do: do { userTree <- traverse fetchUserFromString stringTree; ... }
2021-07-19 18:40:02	dminuoso	[11:29:46] albet70: The key thing to realize is that Applicative/Monad encode certain.. "effects". For `Maybe/Either e` the effect is that of an exception, for IO it's outside world interaction, for list it's non-determinism, etc..
2021-07-19 18:40:02	dminuoso	[11:30:00] So we map each element to an effectful computation, and then sequence them
2021-07-19 18:40:02	dminuoso	[11:30:38] Important bit to notice, is that traverse fundamentally does not change the "shape" of that structure. So if you traverse over a tree, the shape of it remains (so you cant drop or create nodes)
2021-07-19 18:40:02	dminuoso	[11:31:44] traverse on a list for example gives us a more generalized version of effectful loops. So a Python loop in which you do say database queries can be written with `traverse`
2021-07-19 18:40:02	dminuoso	[11:31:57] But `traverse` allows us to do even more, not just database queries
2021-07-19 18:40:02	dminuoso	[11:32:03] And it works on not just lists, but also trees.
2021-07-19 18:40:02	dibblego	[12:04:11] traverse is exactly fmap, if you use Identity in place of the general Applicative 
2021-07-19 18:40:02	dibblego	[12:04:32] but it also does other Applicative things, not just Identity
2021-07-19 18:40:02	hseg	[12:45:53] hi. have this generator http://ix.io/3tqe, and I would like to generalize it so its input generators can depend on each other's results (i.e. want to be able to pass [a -> Gen a])
2021-07-19 18:40:02	hseg	[12:46:15] have tried just doing that, but it involves a lot of churn
2021-07-19 18:40:02	hseg	[12:46:30] is there a more mtl'y way of writing this that can help avoid this churn
2021-07-19 18:40:02	hseg	[12:46:33] ?
2021-07-19 18:40:02	hseg	[12:48:03] presumably, I'd want to have inputs be sth like [n a] with MonadGen n and some constraint expressing that whatever effects n gives are liftable to m 
2021-07-19 18:40:02	hseg	[12:48:43] but that looks overly involved
2021-07-19 18:40:02	zangi	[12:58:35] probably a paradox, but does having IO means haskell is impure? :)
2021-07-19 18:40:02	Axman6	[12:58:42] no
2021-07-19 18:40:02	zangi	[12:59:30] does IO itself impure? what does it mean to be "pure" in haskell sense?
2021-07-19 18:40:02	Axman6	[12:59:49] IO is pure, the execution of it may not be. dibblego is excellent at explaining why 
2021-07-19 18:40:02	 *	Axman6 [12:59:59] handballs the conversation to dibblego
2021-07-19 18:40:02	DigitalKiwi	[13:00:15] what about unsafeCoerce
2021-07-19 18:40:02	zangi	[13:00:52] who's dibblego?
2021-07-19 18:40:02	DigitalKiwi	[13:01:13] why's dibblego
2021-07-19 18:40:02	Axman6	[13:01:43] HE authored much of the NICTA/Data61/System-F FP course, where we explain why IO is pure
2021-07-19 18:40:02	Axman6	[13:01:46] He*
2021-07-19 18:40:02	zangi	[13:02:18] does he have any article about this issue?
2021-07-19 18:40:02	DigitalKiwi	[13:02:20] ofc we all know the answer to how's dibblego (by plane)
2021-07-19 18:40:02	DigitalKiwi	[13:02:35] ba dum tsch
2021-07-19 18:40:02	DigitalKiwi	[13:03:14] https://github.com/system-f/fp-course
2021-07-19 18:40:02	DigitalKiwi	[13:03:41] https://www.youtube.com/watch?v=NzIZzvbplSM&list=PLly9WMAVMrayYo2c-1E_rIRwBXG_FbLBW
2021-07-19 18:40:02	zangi	[13:04:27] DigitalKiwi++
2021-07-19 18:40:02	zangi	[13:05:09] thanks, anyway does it mean IO in haskell is different to IO in other (imperative) languages?
2021-07-19 18:40:02	[exa]	[13:07:53] zangi: haskell is pure; the ugly impure execution of the IO action recipes written in haskell is only done by computers
2021-07-19 18:40:02	kuribas	[13:08:27] [exa]: but then any language is pure?
2021-07-19 18:40:02	[exa]	[13:09:12] nah, some languages rely on that impurity
2021-07-19 18:40:02	***	Playback Complete.
2021-07-19 18:40:11	--	Channel created on Sun, 25 Apr 2021 01:04:39
2021-07-19 18:40:27	[exa]	(and some certain others are just dirty)
2021-07-19 18:41:44	<--	burnsidesLlama (~burnsides@dhcp168-011.wadham.ox.ac.uk) has quit (Remote host closed the connection)
2021-07-19 18:44:07	-->	anandprabhu (~anandprab@94.202.243.198) has joined #haskell
2021-07-19 18:45:18	DigitalKiwi	i like my coffee like i like my programming languages; strong, statically typed, purely functional with type inference and lazy evaluation.
2021-07-19 18:46:18	-->	shriekingnoise (~shrieking@186.137.144.80) has joined #haskell
2021-07-19 18:47:41	<--	anandprabhu (~anandprab@94.202.243.198) has quit (Client Quit)
2021-07-19 18:48:13	lechner	Hi, how can I use MonadFail to handle exceptions from Codec.Compression.Lzma, please?
2021-07-19 18:57:37	<--	jackhill (~jackhill@kalessin.dragonsnail.net) has quit (Ping timeout: 245 seconds)
2021-07-19 18:58:16	<--	jiribenes (~jiribenes@rosa.jiribenes.com) has quit (Ping timeout: 246 seconds)
2021-07-19 18:59:45	-->	aplainzetakind (~johndoe@captainludd.powered.by.lunarbnc.net) has joined #haskell
2021-07-19 19:00:45	<--	peterhil (~peterhil@mobile-access-b04801-219.dhcp.inet.fi) has quit (Ping timeout: 258 seconds)
2021-07-19 19:03:02	-->	jackhill (~jackhill@kalessin.dragonsnail.net) has joined #haskell
2021-07-19 19:04:21	<--	merijn (~merijn@83-160-49-249.ip.xs4all.nl) has quit (Ping timeout: 268 seconds)
2021-07-19 19:04:58	Boarders	is there a variant combinator in megaparsec that is like: do {t <- takeWhileP Nothing (/= '\n'); char '\n'; pure t}
2021-07-19 19:07:46	<--	Maxdamantus (~Maxdamant@user/maxdamantus) has quit (Ping timeout: 268 seconds)
2021-07-19 19:07:48	<--	cuz (~user@2601:182:cc02:8b0:5d77:6ee9:7f95:9dca) has quit (Ping timeout: 255 seconds)
2021-07-19 19:08:53	-->	Sgeo (~Sgeo@user/sgeo) has joined #haskell
2021-07-19 19:10:37	tdammers	https://hackage.haskell.org/package/parser-combinators-1.3.0/docs/Control-Applicative-Combinators.html#v:manyTill maybe?
2021-07-19 19:11:20	dmj`	lechner: did you try using `catch`
2021-07-19 19:13:45	-->	burnsidesLlama (~burnsides@dhcp168-011.wadham.ox.ac.uk) has joined #haskell
2021-07-19 19:14:40	Boarders	manyTill is very related but not quite the same
2021-07-19 19:15:32	lechner	dmj`:  i'm still reading, and working on my general Haskell learning curve
2021-07-19 19:18:54	<--	hendursa1 (~weechat@user/hendursaga) has quit (Quit: hendursa1)
2021-07-19 19:19:09	<--	burnsidesLlama (~burnsides@dhcp168-011.wadham.ox.ac.uk) has quit (Ping timeout: 258 seconds)
2021-07-19 19:19:23	-->	hendursaga (~weechat@user/hendursaga) has joined #haskell
2021-07-19 19:20:10	-->	lavaman (~lavaman@98.38.249.169) has joined #haskell
2021-07-19 19:21:22	lechner	dmj`: but i do have working program (which i wrote) where I could try your suggestion. how do i use catch, please?    https://salsa.debian.org/lintian/kickoff/-/blob/master/Collect.hs#L82
2021-07-19 19:21:53	--	aforemny_ is now known as aforemny
2021-07-19 19:24:40	<--	lavaman (~lavaman@98.38.249.169) has quit (Ping timeout: 252 seconds)
2021-07-19 19:24:47	<--	michalz (~michalz@185.246.204.55) has quit (Remote host closed the connection)
2021-07-19 19:25:26	<--	Kaiepi (~Kaiepi@nwcsnbsc03w-47-54-173-93.dhcp-dynamic.fibreop.nb.bellaliant.net) has quit (Remote host closed the connection)
2021-07-19 19:25:46	-->	Kaiepi (~Kaiepi@nwcsnbsc03w-47-54-173-93.dhcp-dynamic.fibreop.nb.bellaliant.net) has joined #haskell
2021-07-19 19:31:51	-->	econo (uid147250@user/econo) has joined #haskell
2021-07-19 19:32:12	-->	tzh (~tzh@c-24-21-73-154.hsd1.wa.comcast.net) has joined #haskell
2021-07-19 19:32:33	<--	jackhill (~jackhill@kalessin.dragonsnail.net) has quit (Ping timeout: 255 seconds)
2021-07-19 19:35:19	--	sander is now known as sndr
2021-07-19 19:35:40	<--	MQ-17J (~MQ-17J@d14-69-206-129.try.wideopenwest.com) has quit (Ping timeout: 252 seconds)
2021-07-19 19:35:55	-->	MQ-17J (~MQ-17J@d14-69-206-129.try.wideopenwest.com) has joined #haskell
2021-07-19 19:36:39	tzh	hey so i'm working on a haskell game; does anybody have any suggestions for an input library that would work well? previously i've used reactive-banana, which worked well enough even if its FRP nature made it a little clunky for use in a highly-interactive program. i saw some people mention using arrowized FRP libraries likes Yampa/dunai but that seems more like something to use for physics integration than for things like 'how to click on 
2021-07-19 19:36:40	tzh	a menu'
2021-07-19 19:39:15	<--	fef (~thedawn@user/thedawn) has quit (Ping timeout: 244 seconds)
2021-07-19 19:39:21	-->	cuz (~user@38.140.58.234) has joined #haskell
2021-07-19 19:39:30	<--	chomwitt (~chomwitt@2a02:587:dc04:b400:12c3:7bff:fe6d:d374) has quit (Ping timeout: 268 seconds)
2021-07-19 19:40:43	-->	jippiedoe (~david@2a02-a44c-e14e-1-1bc4-b398-e9ad-3132.fixed6.kpn.net) has joined #haskell
2021-07-19 19:43:08	<--	MQ-17J (~MQ-17J@d14-69-206-129.try.wideopenwest.com) has quit (Ping timeout: 265 seconds)
2021-07-19 19:43:42	--	irc: disconnected from server
2021-07-20 10:40:20	-->	amanr (~therojjha@20.204.87.0) has joined #haskell
2021-07-20 10:40:20	--	Topic for #haskell is "https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org | Paste code/errors: https://paste.tomsmeding.com | tunes.org-style logging should be coming soon | Logs: https://ircbrowse.tomsmeding.com/browse/lchaskell"
2021-07-20 10:40:20	--	Topic set by geekosaur (~geekosaur@xmonad/geekosaur) on Mon, 14 Jun 2021 05:16:14
2021-07-20 10:40:20	--	Channel #haskell: 702 nicks (1 op, 0 voices, 701 normals)
2021-07-20 10:40:20	***	Buffer Playback...
2021-07-20 10:40:20	dminuoso	[10:27:17] Well, strictly speaking:
2021-07-20 10:40:20	dminuoso	[10:27:20] % :t (*>)
2021-07-20 10:40:20	yahb	[10:27:20] dminuoso: Applicative f => f a -> f b -> f b
2021-07-20 10:40:20	dminuoso	[10:27:54] guest719: `traverse` can be thought to use (*>) internally, which is just an Applicative version of >>
2021-07-20 10:40:20	dminuoso	[10:28:04] Roughly the idea is:
2021-07-20 10:40:20	dminuoso	[10:29:39] We take this function (a -> f b) (say `String -> IO Int`)from above, and we `fmap` over the structure (say `[String]`). Then, each value is replaced with a computation of some type (say `IO Int`), so the whole structure then is `[IO Int]`.
2021-07-20 10:40:20	dibblego	[10:29:55] you might be thinking of traverse_
2021-07-20 10:40:20	dminuoso	[10:29:58] Then we `sequence` this, which turns `[IO Int] -> IO [Int]`
2021-07-20 10:40:20	dminuoso	[10:32:32] Imagine this to be: sequence (x:xs) = (:) <$> x <*> sequence xs; sequence [] = pure []
2021-07-20 10:40:20	dminuoso	[10:32:58] dibblego: Ah yeah. I guess that was wrong of me.
2021-07-20 10:40:20	dminuoso	[10:33:06] While I was typing the definition, I realized my mistake.
2021-07-20 10:40:20	dminuoso	[10:33:44] % mySequence (x:xs) = (:) <$> x <*> mySequence xs; mySequence [] = pure []
2021-07-20 10:40:20	yahb	[10:33:44] dminuoso: 
2021-07-20 10:40:20	dminuoso	[10:33:46] % :t mySequence
2021-07-20 10:40:20	yahb	[10:33:46] dminuoso: Applicative f => [f a] -> f [a]
2021-07-20 10:40:20	dibblego	[10:33:52] I think sequence is more obvious in the way you are trying to explain it, like this:
2021-07-20 10:40:20	dminuoso	[10:33:53] % mySequence [Just 10, Just 20, Just 30]
2021-07-20 10:40:20	yahb	[10:33:53] dminuoso: Just [10,20,30]
2021-07-20 10:40:20	dibblego	[10:34:20] (::.) = liftA2 (:); lift0 = pure; sequence (x:xs) = x ::. sequence xs; sequence [] = lift0 []
2021-07-20 10:40:20	dibblego	[10:35:56] once liftA2 is understood conceptually, then (*>) is quite simply: const id with some liftA2-ness
2021-07-20 10:40:20	albet70	[11:18:46] so could we say traverse another version of fmap which it can do earlier exit?
2021-07-20 10:40:20	[exa]	[11:21:01] "another" may be a weak label for the myriad of extra stuff it can do :]
2021-07-20 10:40:20	dminuoso	[11:28:04] albet70: Mmm, not just that.
2021-07-20 10:40:20	dminuoso	[11:28:38] albet70: Say you have a Tree of values, say of type String. For each string you want to query some database, and replace the string with some value you read from the database, say something of type User.
2021-07-20 10:40:20	dminuoso	[11:29:00] then you can do: do { userTree <- traverse fetchUserFromString stringTree; ... }
2021-07-20 10:40:20	dminuoso	[11:29:46] albet70: The key thing to realize is that Applicative/Monad encode certain.. "effects". For `Maybe/Either e` the effect is that of an exception, for IO it's outside world interaction, for list it's non-determinism, etc..
2021-07-20 10:40:20	dminuoso	[11:30:00] So we map each element to an effectful computation, and then sequence them
2021-07-20 10:40:20	dminuoso	[11:30:38] Important bit to notice, is that traverse fundamentally does not change the "shape" of that structure. So if you traverse over a tree, the shape of it remains (so you cant drop or create nodes)
2021-07-20 10:40:20	dminuoso	[11:31:44] traverse on a list for example gives us a more generalized version of effectful loops. So a Python loop in which you do say database queries can be written with `traverse`
2021-07-20 10:40:20	dminuoso	[11:31:57] But `traverse` allows us to do even more, not just database queries
2021-07-20 10:40:20	dminuoso	[11:32:03] And it works on not just lists, but also trees.
2021-07-20 10:40:20	dibblego	[12:04:11] traverse is exactly fmap, if you use Identity in place of the general Applicative 
2021-07-20 10:40:20	dibblego	[12:04:32] but it also does other Applicative things, not just Identity
2021-07-20 10:40:20	hseg	[12:45:53] hi. have this generator http://ix.io/3tqe, and I would like to generalize it so its input generators can depend on each other's results (i.e. want to be able to pass [a -> Gen a])
2021-07-20 10:40:20	hseg	[12:46:15] have tried just doing that, but it involves a lot of churn
2021-07-20 10:40:20	hseg	[12:46:30] is there a more mtl'y way of writing this that can help avoid this churn
2021-07-20 10:40:20	hseg	[12:46:33] ?
2021-07-20 10:40:20	hseg	[12:48:03] presumably, I'd want to have inputs be sth like [n a] with MonadGen n and some constraint expressing that whatever effects n gives are liftable to m 
2021-07-20 10:40:20	hseg	[12:48:43] but that looks overly involved
2021-07-20 10:40:20	zangi	[12:58:35] probably a paradox, but does having IO means haskell is impure? :)
2021-07-20 10:40:20	Axman6	[12:58:42] no
2021-07-20 10:40:20	zangi	[12:59:30] does IO itself impure? what does it mean to be "pure" in haskell sense?
2021-07-20 10:40:20	Axman6	[12:59:49] IO is pure, the execution of it may not be. dibblego is excellent at explaining why 
2021-07-20 10:40:20	 *	Axman6 [12:59:59] handballs the conversation to dibblego
2021-07-20 10:40:20	DigitalKiwi	[13:00:15] what about unsafeCoerce
2021-07-20 10:40:20	zangi	[13:00:52] who's dibblego?
2021-07-20 10:40:20	DigitalKiwi	[13:01:13] why's dibblego
2021-07-20 10:40:20	Axman6	[13:01:43] HE authored much of the NICTA/Data61/System-F FP course, where we explain why IO is pure
2021-07-20 10:40:20	Axman6	[13:01:46] He*
2021-07-20 10:40:20	zangi	[13:02:18] does he have any article about this issue?
2021-07-20 10:40:20	DigitalKiwi	[13:02:20] ofc we all know the answer to how's dibblego (by plane)
2021-07-20 10:40:20	DigitalKiwi	[13:02:35] ba dum tsch
2021-07-20 10:40:20	DigitalKiwi	[13:03:14] https://github.com/system-f/fp-course
2021-07-20 10:40:20	DigitalKiwi	[13:03:41] https://www.youtube.com/watch?v=NzIZzvbplSM&list=PLly9WMAVMrayYo2c-1E_rIRwBXG_FbLBW
2021-07-20 10:40:20	zangi	[13:04:27] DigitalKiwi++
2021-07-20 10:40:20	zangi	[13:05:09] thanks, anyway does it mean IO in haskell is different to IO in other (imperative) languages?
2021-07-20 10:40:20	[exa]	[13:07:53] zangi: haskell is pure; the ugly impure execution of the IO action recipes written in haskell is only done by computers
2021-07-20 10:40:20	kuribas	[13:08:27] [exa]: but then any language is pure?
2021-07-20 10:40:20	[exa]	[13:09:12] nah, some languages rely on that impurity
2021-07-20 10:40:20	[exa]	[13:10:27] (and some certain others are just dirty)
2021-07-20 10:40:20	DigitalKiwi	[13:15:18] i like my coffee like i like my programming languages; strong, statically typed, purely functional with type inference and lazy evaluation.
2021-07-20 10:40:20	lechner	[13:18:13] Hi, how can I use MonadFail to handle exceptions from Codec.Compression.Lzma, please?
2021-07-20 10:40:20	Boarders	[13:34:58] is there a variant combinator in megaparsec that is like: do {t <- takeWhileP Nothing (/= '\n'); char '\n'; pure t}
2021-07-20 10:40:20	tdammers	[13:40:37] https://hackage.haskell.org/package/parser-combinators-1.3.0/docs/Control-Applicative-Combinators.html#v:manyTill maybe?
2021-07-20 10:40:20	dmj`	[13:41:19] lechner: did you try using `catch`
2021-07-20 10:40:20	Boarders	[13:44:40] manyTill is very related but not quite the same
2021-07-20 10:40:20	lechner	[13:45:32] dmj`:  i'm still reading, and working on my general Haskell learning curve
2021-07-20 10:40:20	lechner	[13:51:21] dmj`: but i do have working program (which i wrote) where I could try your suggestion. how do i use catch, please?    https://salsa.debian.org/lintian/kickoff/-/blob/master/Collect.hs#L82
2021-07-20 10:40:20	tzh	[14:06:39] hey so i'm working on a haskell game; does anybody have any suggestions for an input library that would work well? previously i've used reactive-banana, which worked well enough even if its FRP nature made it a little clunky for use in a highly-interactive program. i saw some people mention using arrowized FRP libraries likes Yampa/dunai but that seems more like something to use for physics integration than for things like 'how to click on 
2021-07-20 10:40:20	tzh	[14:06:40] a menu'
2021-07-20 10:40:20	kuribas	[14:14:12] tzh: reactive-banana isn't an input library, it's a FRP library.
2021-07-20 10:40:20	kuribas	[14:14:20] You can use it with any UI library.
2021-07-20 10:40:20	maerwald	[14:15:21] SDL2?
2021-07-20 10:40:20	[exa]	[14:15:37] tzh: immediate-mode GUIs (google imgui) are priceless for games, except I don't know if we have any for haskell yet
2021-07-20 10:40:20	tzh	[14:15:51] kuribas: okay yes it's not a raw input-catching library; i'm actually using glfw for that. what i'm looking for is an input _processing_ library, to impose some order onto my input flow so it's not a bunch of ad-hoc garbage
2021-07-20 10:40:20	kuribas	[14:16:18] tzh: reactive-banana should be fine.
2021-07-20 10:40:20	tzh	[14:21:02] the main issue with reactive-banana is that it gets pretty clunky since it only runs in IO and thus can never directly run actual buffer writes... (well, okay, there are ways but that becomes a mess of running all input-processing code inside a render monad, with an unknown timing to my render loop). which means i need to have its output actions queue render actions like buffer allocations/writes, and then outside of the event loop pull 
2021-07-20 10:40:20	tzh	[14:21:03] them out so they can actually be run, which seems a little clunky and counter to the FRP experience, but i don't really see how that could be avoided given how opengl rendering works. so really i'd just like for that experience to be a bit smoother
2021-07-20 10:40:20	dmj`	[15:18:00] lechner:  do { result <- try (evaluate (decompress bytes)) :: IO (Either SomeException ByteString); case result of { Left e -> print e; Right bytes -> print (length bytes) } }
2021-07-20 10:40:20	Las[m]	[15:22:29] Question about bound threads: Will unbound threads use an OS thread created by forkOS?
2021-07-20 10:40:20	monochrom	[15:26:24] Probably in an ideal world shouldn't matter but in practice the GHC implementers wouldn't troll themselves by doing that.
2021-07-20 10:40:20	monochrom	[15:28:14] In practice there is pure Haskell code that can hold up an OS thread uninterruptible. Now what can you do when the rightful owner of the OS thread needs it?
2021-07-20 10:40:20	c_wraith	[15:30:03] honestly, that's not a very important edge case, given that the same pure code that will hold a thread uninterruptably will also block garbage collection, and therefore the entire program via stop-the-world GC
2021-07-20 10:40:20	c_wraith	[15:31:12] If you write a loop that does that, you get what you deserve whether bound threads are involved or not.
2021-07-20 10:40:20	c_wraith	[15:31:51] (this is why mueval starts new processes, not just threads)
2021-07-20 10:40:20	jumper149	[15:43:28] The diagram here: https://wiki.haskell.org/Typeclassopedia
2021-07-20 10:40:20	jumper149	[15:43:49] It is missing the superclass `Alternative` of `MonadPlus` :(
2021-07-20 10:40:20	Boarders	[15:54:34] in haddock if I want to include an example that is too long then is the thing to put definitions in a codeblock or make the example multi-line or something else?
2021-07-20 10:40:20	sm	[15:55:56] Boarders: you can have
2021-07-20 10:40:20	sm	[15:55:57] @
2021-07-20 10:40:20	sm	[15:55:57] multi line example...
2021-07-20 10:40:20	sm	[15:55:57] @
2021-07-20 10:40:20	Boarders	[15:58:40] how do you indicate with that what it should evaluate to?
2021-07-20 10:40:20	sm	[15:59:45] (maybe that got truncated. @ delimiters.)
2021-07-20 10:40:20	sm	[16:00:15] Boarders: are you asking about doctests ? the doctest doc will tell
2021-07-20 10:40:20	sm	[16:02:34] https://github.com/sol/doctest#readme
2021-07-20 10:40:20	gentauro	[16:21:01] does anybody has the link to a tweet staging: «category theory is the mathematics of mathematics»?
2021-07-20 10:40:20	gentauro	[16:21:19] I think it was from a female cs prof (I recall)
2021-07-20 10:40:20	Boarders	[16:22:56] https://twitter.com/emilyriehl/status/979375728373518336?s=20
2021-07-20 10:40:20	lechner	[16:24:55] dmj`: it compiled, but did not stop the program from terminating. i got the same message as before:  "Codec.Compression.Lzma.decompressWith: decoding error LzmaRetOK"      https://dpaste.org/FGQs#L7,84,85,86,87
2021-07-20 10:40:20	c_wraith	[16:24:57] In that tweet she credits Eugenia Cheng, which is a name I've heard before.
2021-07-20 10:40:20	lechner	[16:31:13] just make sure you pronounce it right, please    http://eugeniacheng.com/pronunciation/
2021-07-20 10:40:20	dmj`	[16:41:23] lechner: I think the issue is that you're not forking a thread to handle new clients, so your server terminates immediately, since the main thread of execution exits.. You're just blocking on a socket receive until the client exits, then your process terminates. You need to fork threads for each client and ensure the main thread of execution is running indefinitely
2021-07-20 10:40:20	lechner	[16:43:30] dmj`: without a decoding error, this does run forever   https://dpaste.org/FGQs#L105
2021-07-20 10:40:20	lechner	[16:43:47] via iterateM_
2021-07-20 10:40:20	lechner	[16:45:07] it is in fact my motivation to catch the error
2021-07-20 10:40:20	gentauro	[16:52:23] 18:22 < Boarders> https://twitter.com/emilyriehl/status/979375728373518336
2021-07-20 10:40:20	gentauro	[16:52:29] Boarders: that's the one. Thx :)
2021-07-20 10:40:20	jumper149	[17:16:10] I want to choose a Haskell formatter. Are there any nice comparisons? Maybe a blog post?
2021-07-20 10:40:20	[exa]	[17:17:00] jumper149: probably best to ask yourself why you want the formatting at first
2021-07-20 10:40:20	dsal	[17:17:07] Haskell In Depth went over them slightly, but didn't offer an opinion.
2021-07-20 10:40:20	dsal	[17:17:32] IMO, ormolu is weird and wrong, but it's the new kid and at least some people like it.
2021-07-20 10:40:20	dminuoso	[17:17:33] I chose emacs as my formatter. I can press enter, and it formats the code nicely.
2021-07-20 10:40:20	dminuoso	[17:17:49] If it does it wrong, I can change the indentation with a single keypress.
2021-07-20 10:40:20	[exa]	[17:17:55] fourmolu is kinda less bad than ormolu
2021-07-20 10:40:20	 *	geekosaur [17:18:17] formats man8ually as no formatter matches his preference
2021-07-20 10:40:20	dsal	[17:18:30] I use stylish-haskell when I remember.  It usually does OK.
2021-07-20 10:40:20	jumper149	[17:18:41] I want formatting to be consistent over a project. And I would like something that makes sense with git.
2021-07-20 10:40:20	maerwald	[17:18:48] brittany got close to my needs, but it tends to pull apart code so much that stuff becomes overly verbose
2021-07-20 10:40:20	dsal	[17:18:55] I mainly like my imports tidy.
2021-07-20 10:40:20	dminuoso	[17:18:59] jumper149: A consistent style is already a bizarre thing.
2021-07-20 10:40:20	dsal	[17:19:02] jumper149: git just stores blobs, so that's not a big deal.  :)
2021-07-20 10:40:20	dminuoso	[17:19:11] jumper149: Code formatting communicates intent and structure, its highly contextual.
2021-07-20 10:40:20	maerwald	[17:19:39] dminuoso: yes, the consistency argument is mostly nonsense imo. The "I'm too lazy argument" I can get behind
2021-07-20 10:40:20	maerwald	[17:19:42] because I am
2021-07-20 10:40:20	dsal	[17:19:43] ormolu was inspired by elm's canonical format in a lot of way and they prioritized making it easy to read diffs generated by whatever tools they happened to use.  This is a terrible mistake, IMO.
2021-07-20 10:40:20	monochrom	[17:19:45] Perhaps "makes sense with git" means "makes sense with diff".
2021-07-20 10:40:20	dminuoso	[17:19:49] It's sort of the equivalent of saying "a paragraph must always have 3 sentences". It's a stupid proposition to begin with.
2021-07-20 10:40:20	jumper149	[17:20:01] monochrom: exactly!
2021-07-20 10:40:20	dminuoso	[17:20:21] Yes, if each paragraph has 3 sentences, you have a consistent formatting of your natural language. But it really hampers readability
2021-07-20 10:40:20	dsal	[17:20:25] Most of the time when I'm reading code, I'm not reading diffs.  I'd rather prioritize the code over the diffs.
2021-07-20 10:40:20	monochrom	[17:20:32] People keep XYing their diction all the time. Remember that one time when someone said "haddock" to mean doctest?
2021-07-20 10:40:20	maerwald	[17:21:49] dsal: in a lot of PRs I've seen at work there was no way to understand anything from the diff without a walkthrough by the author. Even looking at my own PRs I don't understand anything. In some companies the author writes a walkthrough in the diff comments, but even then: diffs lie
2021-07-20 10:40:20	maerwald	[17:22:16] you don't see the code you changed, only the lines you changed
2021-07-20 10:40:20	jumper149	[17:22:26] I particularly want a formatter for stuff like same style Haddocks (-- vs {- -}), sorted imports and extensions.
2021-07-20 10:40:20	dminuoso	[17:22:43] jumper149: For import/extensions sorting, I find stylish-haskell to be agreeable.
2021-07-20 10:40:20	dminuoso	[17:22:49] (It just breaks in the presence of QQs and TH)
2021-07-20 10:40:20	maerwald	[17:22:54] and CPP
2021-07-20 10:40:20	dminuoso	[17:23:16] jumper149: But note, you should chose your tool to fit *your* style.
2021-07-20 10:40:20	dsal	[17:23:16] maerwald: yeah.  I have that problem reading diffs sometimes.  Like, cool you changed x to y... but what was x and what's y?
2021-07-20 10:40:20	maerwald	[17:23:34] also: reverse dependencies of your code
2021-07-20 10:40:20	maerwald	[17:23:57] you might need to re-read the entire codebase from a different perspective
2021-07-20 10:40:20	maerwald	[17:24:21] while the scrum master is asking why the PR is still not merged
2021-07-20 10:40:20	maerwald	[17:24:56] but hey... not everyone works in security critical code: just push and hope for the best
2021-07-20 10:40:20	monochrom	[17:25:02] "the closer you look, the less you see"
2021-07-20 10:40:20	dminuoso	[17:25:30] monochrom: Yes, that was the mentality of openssl. Distance yourself from the code and embrace Heartbleed!
2021-07-20 10:40:20	dsal	[17:25:32] These modern "diff-friendly" things take something small, clear and readable and make me have to scroll to understand what's going on.  https://www.irccloud.com/pastebin/dhodxIZ7/ok.elm
2021-07-20 10:40:20	monochrom	[17:25:42] haha
2021-07-20 10:40:20	geekosaur	[17:26:11] I somewhat regularly have to click on the extend buttons in github to understand a diff
2021-07-20 10:40:20	geekosaur	[17:26:26] which is the simple version of this
2021-07-20 10:40:20	monochrom	[17:26:54] Clearly, the logical conclusion is one token per line. >:)
2021-07-20 10:40:20	dsal	[17:27:08] There are lots of cases where formatters seem to do that.
2021-07-20 10:40:20	maerwald	[17:27:12] There is a very grumpy C coder on my LinkedIn feed, always riling about security and code correctness. Then one day he wrote why: his bug actually killed people, because it was some control system about pressure valves.
2021-07-20 10:40:20	dsal	[17:27:16] With lines between them.
2021-07-20 10:40:20	dsal	[17:28:09] monochrom: Like, imagine how hard this would be to read if that 'o' shared a line with any of the other code:  https://www.irccloud.com/pastebin/lIpmTDCu/format.elm
2021-07-20 10:40:20	maerwald	[17:28:18] but I don't know what he thinks of code formatters
2021-07-20 10:40:20	maerwald	[17:28:39] then again: that's a solved issue in C anyway
2021-07-20 10:40:20	dsal	[17:29:15] I really like tools that do static analysis and stuff in my code to tell me when I could do things better.   That's an unreasonably hard problem to solve well, though.
2021-07-20 10:40:20	maerwald	[17:34:59] I think the main question is: do you align code or just do syntactical indenting
2021-07-20 10:40:20	euouae	[17:36:50] Hello
2021-07-20 10:40:20	euouae	[17:37:15] I want to create a lazy list whose nth element is a function of its predecessor 
2021-07-20 10:40:20	monochrom	[17:37:27] iterate
2021-07-20 10:40:20	euouae	[17:37:38] What do you mean 
2021-07-20 10:40:20	monochrom	[17:37:49] Look for that function name in the standard library.
2021-07-20 10:40:20	euouae	[17:39:21] Thank you !
2021-07-20 10:40:20	maerwald	[17:39:53] @hoogle iterate
2021-07-20 10:40:20	lambdabot	[17:39:53] Prelude iterate :: (a -> a) -> a -> [a]
2021-07-20 10:40:20	lambdabot	[17:39:54] Data.List iterate :: (a -> a) -> a -> [a]
2021-07-20 10:40:20	lambdabot	[17:39:54] Data.List.NonEmpty iterate :: (a -> a) -> a -> NonEmpty a
2021-07-20 10:40:20	maerwald	[17:40:27] @where hoogle
2021-07-20 10:40:20	lambdabot	[17:40:27] http://haskell.org/hoogle http://hoogle.haskell.org http://fpcomplete.com/hoogle – See also Hayoo, which searches more packages: http://hayoo.fh-wedel.de/
2021-07-20 10:40:20	maerwald	[17:40:40] hayoo is dead no?
2021-07-20 10:40:20	maerwald	[17:41:01] and the fpcomplete link too
2021-07-20 10:40:20	monochrom	[17:41:16] yikes
2021-07-20 10:40:20	geekosaur	[17:41:44] yeh, nobody's updated that
2021-07-20 10:40:20	euouae	[17:42:39] Has anyone tried Haskell on a supercomputer?
2021-07-20 10:40:20	geekosaur	[17:42:48] @where+ hoogle https://hoogle.haskell.org see also https://haskell.org/hoogle which searches a different default set of libraries
2021-07-20 10:40:20	lambdabot	[17:42:48] I will remember.
2021-07-20 10:40:20	geekosaur	[17:43:04] define supercomputer
2021-07-20 10:40:20	maerwald	[17:43:15] for me, both links are the same
2021-07-20 10:40:20	geekosaur	[17:43:33] interesting, maybe they made the old one go away
2021-07-20 10:40:20	maerwald	[17:43:34] haskell.org/hoogle redirects to hoogle.haskell.org
2021-07-20 10:40:20	euouae	[17:43:40] Hmm I’m trying to run a lot of computations and get an answer 
2021-07-20 10:40:20	euouae	[17:43:53] for now I have like 100 cores etc 
2021-07-20 10:40:20	geekosaur	[17:43:56] @where+ hoogle https://hoogle.haskell.org
2021-07-20 10:40:20	lambdabot	[17:43:56] Nice!
2021-07-20 10:40:20	dmj`	[17:44:49] Someone should write a library for parsing XML with GHC.Generics
2021-07-20 10:40:20	geekosaur	[17:45:46] iirc ghc's performance gets worse the more cores you have :( (but maybe this has improved, that was around 7.x)
2021-07-20 10:40:20	geekosaur	[17:46:06] mostly because of stop-the-world gc, though
2021-07-20 10:40:20	euouae	[17:46:51] Okay interesting 
2021-07-20 10:40:20	davean	[17:46:59] It gets harder to make it perform well with more cores, it doesn't inhernety not perform well.
2021-07-20 10:40:20	maerwald	[17:47:06] dmj`: why are you using xml :>
2021-07-20 10:40:20	davean	[17:47:08] But no super computing task is single process
2021-07-20 10:40:20	euouae	[17:47:21] Davean my knowledge is limited 
2021-07-20 10:40:20	davean	[17:47:22] I mean if you could fit it on one system it wouldn't really be using a modern supercomputer
2021-07-20 10:40:20	euouae	[17:47:50] I am not great at Haskell and never programmed for supercomputers before
2021-07-20 10:40:20	euouae	[17:49:49] But Haskell is really attractive for math 
2021-07-20 10:40:20	davean	[17:49:52] I think I've heard of some super computer Haskell use. I'd say everything to do with super computers is pretty definitionally specialized
2021-07-20 10:40:20	euouae	[17:50:17] Yeah basically you need to be very knowledgeable in the domain davean 
2021-07-20 10:40:20	euouae	[17:50:25] And I’m just trying to get by 
2021-07-20 10:40:20	maerwald	[17:50:30] is this about bitcoin mining?
2021-07-20 10:40:20	davean	[17:50:33] The domain, but also that specific computer
2021-07-20 10:40:20	davean	[17:50:38] maerwald: I sure hope not!
2021-07-20 10:40:20	euouae	[17:50:46] No lol it’s research 
2021-07-20 10:40:20	dmj`	[17:50:50] maerwald: AWS S3 still uses XML, https://docs.aws.amazon.com/AmazonS3/latest/API/API_ListObjectsV2.html
2021-07-20 10:40:20	euouae	[17:51:17] Bitcoin stuff is so scummy o want nothing with. It
2021-07-20 10:40:20	davean	[17:52:26] maerwald: Many code bugs kill a large number of fractional people
2021-07-20 10:40:20	euouae	[17:53:01] Davean I don’t understand how situational it could be though 
2021-07-20 10:40:20	euouae	[17:53:22] what I have is some pure math computations applied to many different numbers (say)
2021-07-20 10:40:20	davean	[17:53:54] euouae: The structure of the super computers differ, and the primary issue with super computers is communication
2021-07-20 10:40:20	davean	[17:54:03] You optimize communication, not compute
2021-07-20 10:40:20	euouae	[17:54:11] For now I’m on a single node 
2021-07-20 10:40:20	davean	[17:54:14] The network structures are all different for different optimalities
2021-07-20 10:40:20	davean	[17:54:26] Yes, and theres no modern single node super computers
2021-07-20 10:40:20	euouae	[17:54:54] It’s not necessarily a supercomputer since it’s single node but I’m starting from that 
2021-07-20 10:40:20	davean	[17:54:55] even on a single processor, you have to deal with inter-core communication issues, they're just less
2021-07-20 10:40:20	euouae	[17:55:07] Inter core? 
2021-07-20 10:40:20	euouae	[17:55:22] Are you talking about worker communication?
2021-07-20 10:40:20	euouae	[17:55:28] I’m not following 
2021-07-20 10:40:20	geekosaur	[17:57:54] things like shared memory access
2021-07-20 10:40:20	euouae	[17:58:13] Why is that important ?
2021-07-20 10:40:20	euouae	[17:58:29] I think in my problem no memory is shared 
2021-07-20 10:40:20	euouae	[17:58:54] It’s like map f xs but parallel 
2021-07-20 10:40:20	geekosaur	[17:59:09] if you're handling out subproblems to different threads/cores to be worked on, then there is at least some shared memory
2021-07-20 10:40:20	euouae	[17:59:12] More or less, maybe with a stop condition
2021-07-20 10:40:20	euouae	[17:59:36] Okay but this is the most basic form of it right?
2021-07-20 10:40:20	euouae	[18:04:02] Anyway those issues are part of the algorithm right?
2021-07-20 10:40:20	euouae	[18:04:14] Not some other aspect of the peoblrm
2021-07-20 10:40:20	euouae	[18:04:20] problem*
2021-07-20 10:40:20	davean	[18:04:54] I mean your algorithm isn't determined
2021-07-20 10:40:20	davean	[18:05:02] you design one to optimize for the HW
2021-07-20 10:40:20	geekosaur	[18:05:06] you'd best hope they are, but that would mean it's been specialized to your supercomputer
2021-07-20 10:40:20	davean	[18:05:51] what alg. is best depends on what your counting, and what the various costs are
2021-07-20 10:40:20	davean	[18:06:02] along with your expected problem parameters
2021-07-20 10:40:20	euouae	[18:06:45] So it’s really hard or are you just talking about the optimal case?
2021-07-20 10:40:20	monochrom	[18:07:14] I would think "really hard" and "the optimal case" go well together.
2021-07-20 10:40:20	davean	[18:07:55] Depends on the problem
2021-07-20 10:40:20	davean	[18:08:14] if you're scaling it up past a very small case though I'm talking about what it usually takes to do a servicable job at it
2021-07-20 10:40:20	euouae	[18:08:49] Davean are you speaking from experience with industry or research 
2021-07-20 10:40:20	euouae	[18:09:12] obviously any optimization means more profit in industry I imagine it’s really right
2021-07-20 10:40:20	davean	[18:09:15] yes, though my research wasn't particularly compute intensive even if it was "AI"
2021-07-20 10:40:20	euouae	[18:09:50] But in research there can be diminishing returns because your problem isn’t computationally feasible anyway after n=10 etc
2021-07-20 10:40:20	euouae	[18:10:22] Okay… hmmm. Is it possible for me to get into this at all or am I hopeless?
2021-07-20 10:40:20	davean	[18:10:36] euouae: I mean theres a huge difference between Floyd-Warshall and A*
2021-07-20 10:40:20	davean	[18:10:43] euouae: but they both sorta solve the same problem space
2021-07-20 10:40:20	geekosaur	[18:10:44] nobody here can tell that as we don't know your problem
2021-07-20 10:40:20	euouae	[18:10:59] I don’t know those davean
2021-07-20 10:40:20	euouae	[18:11:55] Okay maybe I’ll ask again if I have something more to show 
2021-07-20 10:40:20	davean	[18:11:56] ANd oh no, Floyd-Warshall is O(|V|^3), and A* is only O(|E|)! Clearly A* is always better? Except not at all
2021-07-20 10:40:20	euouae	[18:12:45] Big constants davean?
2021-07-20 10:40:20	davean	[18:12:45] well |E| can be ~ |V|^2, and what if you want the best paths, not approximations, but you're metric isn't admissible? And you want it for all of them? Or even just one side of those?
2021-07-20 10:40:20	davean	[18:12:51] euouae: no, nothing to do with constants
2021-07-20 10:40:20	davean	[18:13:41] Algrithmicly Floyd-Warshall is the same complexity for some use cases, because while they solve the same-ish problems, they do it for different uses
2021-07-20 10:40:20	davean	[18:13:57] if you do something |V|^2 |V times, thats |V|^3
2021-07-20 10:40:20	davean	[18:14:17] But Floyd-Warshall requires more communication
2021-07-20 10:40:20	davean	[18:14:27] A* is the "embarasingly" paralleler case
2021-07-20 10:40:20	davean	[18:14:53] so if you're CPUs are very seperated, maybe you want to work more like that again, except not you can go back and plan the communication of F-W ...
2021-07-20 10:40:20	euouae	[18:16:14] Oh man I’m not following 
2021-07-20 10:40:20	euouae	[19:04:02] Hello why am I getting a stack overflow for this? sum $ map f [T x y z | x<-xs, y<-xs, z<-xs ] where xs has 256 elements 
2021-07-20 10:40:20	euouae	[19:04:22] and f calculates the area of the triangle with vertices x y and z
2021-07-20 10:40:20	Hecate	[19:04:25] euouae: stack or heap? 
2021-07-20 10:40:20	euouae	[19:04:34] Says stack on Gucci 
2021-07-20 10:40:20	euouae	[19:04:36] Ghci 
2021-07-20 10:40:20	davean	[19:05:44] 256^3?
2021-07-20 10:40:20	h98	[19:05:47] 256^3 = 16,777,216
2021-07-20 10:40:20	euouae	[19:05:57] I was hoping that it wouldn’t have to expand a 256^3 list before summing 
2021-07-20 10:40:20	geekosaur	[19:06:03] is this sum being foldl again?
2021-07-20 10:40:20	euouae	[19:06:23] Are you asking me?
2021-07-20 10:40:20	geekosaur	[19:06:30] no
2021-07-20 10:40:20	hseg	[19:07:00] hi. have this generator http://ix.io/3tqe, and I would like to generalize it so its input generators can depend on each other's results (i.e. want to be able to pass [a -> Gen a])
2021-07-20 10:40:20	Rembane	[19:07:11] euouae: What happens if you replace sum with foldr1 (+) ? 
2021-07-20 10:40:20	hseg	[19:07:20] have tried just doing that, but it involves a lot of churn
2021-07-20 10:40:20	hseg	[19:07:26] is there a more mtl'y way of writing this that can help avoid this churn
2021-07-20 10:40:20	hseg	[19:07:28] ?
2021-07-20 10:40:20	Hecate	[19:08:18] euouae: until you're on the version of GHC that has sum strict without optimisations, please enable them when you do stuff like that, otherwise space leaks will knock at your door
2021-07-20 10:40:20	geekosaur	[19:09:10] well, you also have to be on a version of ghc which allows optiimization in ghci
2021-07-20 10:40:20	euouae	[19:09:11] Okay so 8.6.5 is old 
2021-07-20 10:40:20	euouae	[19:09:45] Rembane got same thing much later 
2021-07-20 10:40:20	Rembane	[19:10:05] euouae: Got it! 
2021-07-20 10:40:20	euouae	[19:10:09] Ok I guess I have to enable optimizations 
2021-07-20 10:40:20	euouae	[19:10:13] Got what ?
2021-07-20 10:40:20	davean	[19:10:23] foldr' (+) 0 instead of sum sohuld fix it also
2021-07-20 10:40:20	davean	[19:11:22] (That doesn't require optimizations)
2021-07-20 10:40:20	maerwald	[19:11:36] anyone good with libarchive? Do you have a guarantee that when reading list of archive entries that the first entry is the root folder (if any)?
2021-07-20 10:40:20	davean	[19:12:31] maerwald: I certainly can make a tar that thats not true of.
2021-07-20 10:40:20	maerwald	[19:12:54] yeah... I want to strip the root folder, but libarchive API doesn't have that
2021-07-20 10:40:20	davean	[19:12:59] libarchive would have to pre-read the entire tar to avoid it, at best
2021-07-20 10:40:20	geekosaur	[19:13:27] and there are versions of tar that re-output a folder after its contents to allow the other end to more easily set mtime etc.
2021-07-20 10:40:20	maerwald	[19:14:17] the alternative is to unpack as-is, make sure you're on the same device and then do an atomic move operation, stripping the root folder away
2021-07-20 10:40:20	euouae	[19:14:24] Davean also gives me stack overflow 
2021-07-20 10:40:20	maerwald	[19:14:27] but on windows, any file operation is doomed to have locking issues
2021-07-20 10:40:20	euouae	[19:14:46] You might be able to hack libarchive 
2021-07-20 10:40:20	maerwald	[19:14:51] no time
2021-07-20 10:40:20	davean	[19:16:30] maerwald: Conceptually you'd have to do 2 passes over a tar for that, at best
2021-07-20 10:40:20	maerwald	[19:16:51] I think the idea would be to lazily read all entries... fmap over them and strip the root dir, lazily create a new tar archive from the entries and then lazily unpack it
2021-07-20 10:40:20	davean	[19:17:05] why create a new tar archive?
2021-07-20 10:40:20	euouae	[19:17:07] Man pages are outdated 
2021-07-20 10:40:20	davean	[19:17:11] why not just process them as you unpack?
2021-07-20 10:40:20	euouae	[19:17:14] Maybe read the source code 
2021-07-20 10:40:20	maerwald	[19:17:16] davean: there's no function to unpack from entries
2021-07-20 10:40:20	h98	[19:17:44] euouae did you try foldr (\x y -> (f x) + y) 0 [T x y z ....]?
2021-07-20 10:40:20	euouae	[19:18:46] Maerwald: seems related https://github.com/libarchive/libarchive/wiki/WishList#seek-in-archives
2021-07-20 10:40:20	euouae	[19:19:05] H98 would thy be better?
2021-07-20 10:40:20	maerwald	[19:19:23] euouae: the haskell bindings might not be exhaustive
2021-07-20 10:40:20	euouae	[19:19:53] Yeah you’d have to make that but even then I’m painting to the fact that it’s on a wishlist maereald 
2021-07-20 10:40:20	maerwald	[19:20:11] I'd have to write my own version of `toDisk :: Entry FilePath ByteString -> IO ()`
2021-07-20 10:40:20	maerwald	[19:20:19] which sounds trivial, but isn't
2021-07-20 10:40:20	euouae	[19:20:39] Go for a solution that isn’t efficient but works?
2021-07-20 10:40:20	maerwald	[19:20:46] hardlinks, softlinks, preserving file properties
2021-07-20 10:40:20	euouae	[19:21:34] H98 also gives stack overflow 
2021-07-20 10:40:20	euouae	[19:27:21] So the issue is ghci being silly right 
2021-07-20 10:40:20	h98	[19:29:49] yeah I think so
2021-07-20 10:40:20	h98	[19:29:52] I tried this: https://paste.tomsmeding.com/QVCoWxOz
2021-07-20 10:40:20	h98	[19:30:14] if I compile and run it i get 6467616768 after a few seconds
2021-07-20 10:40:20	h98	[19:30:26] if I call test in ghci I get a stack overflow
2021-07-20 10:40:20	h98	[19:30:30] version 8.10.4
2021-07-20 10:40:20	euouae	[19:32:16] Thank you !
2021-07-20 10:40:20	euouae	[19:32:27] Did you have to enable optimizations ?
2021-07-20 10:40:20	h98	[19:33:13] I have no idea how, so I don't think so
2021-07-20 10:40:20	euouae	[19:34:14] Thanks 
2021-07-20 10:40:20	geekosaur	[19:34:22] ghci can't do optimizations except in very recent versions
2021-07-20 10:40:20	h98	[19:38:00] oh but foldl' works
2021-07-20 10:40:20	h98	[19:38:38] https://paste.tomsmeding.com/dLbV73r1 same thing, but no overflow in ghci
2021-07-20 10:40:20	h98	[19:39:35] RWH p. 97 talks about this
2021-07-20 10:40:20	dsal	[19:42:52] why is `sum` bad?  Is this one of those things where fixing it breaks something probably nobody cares about?
2021-07-20 10:40:20	monochrom	[19:46:08] I compiled with -O, no stack overflow, in fact immediate answer.
2021-07-20 10:40:20	monochrom	[19:46:47] main = print (let xs = [1..256] in sum [ x+y+z | x <- xs, y <- xs, z <- xs ])
2021-07-20 10:40:20	geekosaur	[19:46:58] dsal, there was a whole discussion on -cafe about various things using foldl instead of foldl'
2021-07-20 10:40:20	geekosaur	[19:47:15] and thereby being prone to stack overflows
2021-07-20 10:40:20	geekosaur	[19:47:28] sum being the prime example
2021-07-20 10:40:20	_73	[19:47:35] what is the right abstraction to avoid explicit recursion on a function using a monadic action. I tried to write it as a foldr but wasn't able to succeed. Here is my code that does use explicit recursion: http://dpaste.com/2SKMBLTA8
2021-07-20 10:40:20	dsal	[19:48:32] :t foldM
2021-07-20 10:40:20	lambdabot	[19:48:33] (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m b
2021-07-20 10:40:20	geekosaur	[19:48:48] I think it comes down to nobody thought about it and the original Prelude was written for comprehensibility by newcomers rather than performance
2021-07-20 10:40:20	dsal	[19:49:05] @src sum
2021-07-20 10:40:20	lambdabot	[19:49:06] sum = foldl (+) 0
2021-07-20 10:40:20	monochrom	[19:49:22] Oh don't worry about @src, it's independently handwritten.
2021-07-20 10:40:20	monochrom	[19:49:28] Hell, s/worry/trust/
2021-07-20 10:40:20	dsal	[19:49:39] Yeah.  I just tend to assume it's a simplification for understanding.
2021-07-20 10:40:20	monochrom	[19:50:10] Yeah, great educational tool.
2021-07-20 10:40:20	geekosaur	[19:50:44] and @src is mostly lifted from the Report, and is similarly intended for reading rather than running
2021-07-20 10:40:20	_73	[19:52:55] I got it work with foldM thanks
2021-07-20 10:40:20	euouae	[20:00:53] Heh I got “killed” after I run ghc 
2021-07-20 10:40:20	euouae	[20:01:14] What does that mean ?
2021-07-20 10:40:20	geekosaur	[20:01:29] the OOM killer got you
2021-07-20 10:40:20	geekosaur	[20:01:57] i.e. the Linux kernel decided your process was eating too much memory and nuked it
2021-07-20 10:40:20	geekosaur	[20:03:39] (or similar for OS X, etc.; only Windows will differ but it has its own way of dealing with that)
2021-07-20 10:40:20	euouae	[20:04:39] Hmm alright the oom reaper 
2021-07-20 10:40:20	ddb	[20:16:07] geekosaur: is that discussion about things using foldl instead of foldl' logged or archived anywhere?
2021-07-20 10:40:20	maerwald	[20:17:23] can you have extaustiveness check with NamedFieldPuns?
2021-07-20 10:40:20	maerwald	[20:18:25] let's say you have Foo = Foo { foo1 :: String, foo2 :: String, foo3 :: String } and you want to pattern match on it without relying on the order, but also make sure you don't miss something when a new record is added
2021-07-20 10:40:20	maerwald	[20:19:49] Relying on order is shitty when all the records are of the same type
2021-07-20 10:40:20	geekosaur	[20:22:19] ddb, somewhere on the haskell-cafe mailing list archives
2021-07-20 10:40:20	hseg	[21:01:02] feels like this can be expressed in standard terms, any ideas? http://ix.io/3tsp
2021-07-20 10:40:20	hseg	[21:02:17] idea is to sum a list, then if possible without changing the sign, replace the last element by its difference from the sum so it all sums to 0
2021-07-20 10:40:20	hseg	[21:02:46] (need to maintain signs, and the list is sorted by absolute value)
2021-07-20 10:40:20	dsal	[21:07:50] > let xs = init [1, 2, 3] in xs <> [0 - sum xs]   -- hseg like this?  I'm a bit confused by your specification.
2021-07-20 10:40:20	lambdabot	[21:07:51]  [1,2,-3]
2021-07-20 10:40:20	hseg	[21:08:49] spec is: (assuming output is Just): ((==) `on` compare 0) xs (fixSum xs), sum (fixSum xs) == 0
2021-07-20 10:40:20	hseg	[21:09:35] and I'm choosing to limit the cases i'm fixing to those (==) `on` init
2021-07-20 10:40:20	hseg	[21:10:37] hrm. your code is probably clearer -- just need to compose with a guard to make sure it satisfies spec
2021-07-20 10:40:20	hseg	[21:10:54] though if there were some way of avoiding the append, that would be nice
2021-07-20 10:40:20	EvanR	[21:13:59] you want to change the last element of a list?
2021-07-20 10:40:20	hseg	[21:14:03] y
2021-07-20 10:40:20	EvanR	[21:14:07] oof
2021-07-20 10:40:20	hseg	[21:14:53] could fix it so it's correct-by-construction, but that makes my generator code very ugly
2021-07-20 10:40:20	EvanR	[21:14:57] can you designate the first element the element that needs to be changed
2021-07-20 10:40:20	hseg	[21:15:28] nope -- sorted ascending by absolute value
2021-07-20 10:40:20	EvanR	[21:15:44] how about descending
2021-07-20 10:40:20	hseg	[21:15:58] and there's enough stuff depending on this already that I'd rather not push that redesign
2021-07-20 10:40:20	hseg	[21:16:46] should just take the l and continue -- probably not going to be significant enough to matter
2021-07-20 10:40:20	hseg	[21:16:51] (lists will be short)
2021-07-20 10:40:20	hseg	[21:17:09] at least it's O(n) vs O(1), not O(n) vs O(n^k)
2021-07-20 10:40:20	EvanR	[21:17:10] i like to split things up into steps rather than code golfing
2021-07-20 10:40:20	hseg	[21:17:30] ?
2021-07-20 10:40:20	hseg	[21:17:44] where are you seeing golfing in my code?
2021-07-20 10:40:20	EvanR	[21:17:49] or in this case, perhaps write a combinator that traverses a list and uses a function argument to decide how to modify the last element
2021-07-20 10:40:20	EvanR	[21:18:02] i only saw 1 line of code, so it seems like golf xD
2021-07-20 10:40:20	hseg	[21:18:10] :)
2021-07-20 10:40:20	hseg	[21:18:44] posted code earlier, but that could work
2021-07-20 10:40:20	hseg	[21:19:42] k, not bad enough to matter
2021-07-20 10:40:20	EvanR	[21:19:43] a combination fold and specialized list reconstructor. And scanl may already be that
2021-07-20 10:40:20	davean	[21:20:42] hseg: how does this handle the singleton list?
2021-07-20 10:40:20	hseg	[21:21:04] [0] -> Just [0], [x] -> Nothing
2021-07-20 10:40:20	EvanR	[21:21:31] oh failure, nvm
2021-07-20 10:40:20	davean	[21:21:41] Oh damn, thats ... ok
2021-07-20 10:40:20	EvanR	[21:22:26] if you're changing the last element wouldn't [x] |-> Just [0]
2021-07-20 10:40:20	davean	[21:22:36] EvanR: Thats why I asked!
2021-07-20 10:40:20	davean	[21:23:11] I had suspicions about the spec
2021-07-20 10:40:20	hseg	[21:23:13] no, because i need elementwise (==) `on` compare 0
2021-07-20 10:40:20	hseg	[21:23:37] which is more important to me than success fixing the sum
2021-07-20 10:40:20	EvanR	[21:24:30] less a spec and more a would be nice list xD
2021-07-20 10:40:20	davean	[21:24:44] Yah, I think you need to think about your actual problem space hseg 
2021-07-20 10:40:20	davean	[21:24:52] I suspect you haven't come to understanding of your actual goals
2021-07-20 10:40:20	hseg	[21:25:26] am writing a quickcheck generator. all I need is that it generate enough correct values quickly
2021-07-20 10:40:20	davean	[21:25:42] No, thats not what you need for good quickchecks
2021-07-20 10:40:20	davean	[21:25:54] Thats what you need for invalid quickchecks
2021-07-20 10:40:20	hseg	[21:26:09] because I also need a good shrink?
2021-07-20 10:40:20	hseg	[21:26:18] (need one regardless (: )
2021-07-20 10:40:20	davean	[21:26:19] No, shrink is secondary and never required
2021-07-20 10:40:20	davean	[21:26:41] Quickcheck generators have to cover the domain, or at least the preimage
2021-07-20 10:40:20	hseg	[21:26:54] basically all I'm using this for is for randomly sampling the domain
2021-07-20 10:40:20	davean	[21:27:11] But you've just described NOT sampling the domain
2021-07-20 10:40:20	davean	[21:27:28] you'd just described sampling a particular subdomain of the domain
2021-07-20 10:40:20	davean	[21:28:03] And even suggested it isn't the preimage
2021-07-20 10:40:20	davean	[21:28:07] (strongly)
2021-07-20 10:40:20	davean	[21:28:36] Making the quickcheck results close to meaingless
2021-07-20 10:40:20	hseg	[21:29:01] perhaps. am not using the full power of quickcheck, regardless
2021-07-20 10:40:20	davean	[21:29:11] This isn't about power, this is about validity
2021-07-20 10:40:20	hseg	[21:29:38] yes? so I know I will get false positives/negatives
2021-07-20 10:40:20	davean	[21:30:03] So whats the point of running this code at all? You know as much before it runs as after
2021-07-20 10:40:20	hseg	[21:30:08] as long as I'm still having recognizable true negatives, I'm not worried about it
2021-07-20 10:40:20	hseg	[21:31:02] I'm testing a hypothesis that an invariant I have in mind is fine enough to predict the value of a function
2021-07-20 10:40:20	hseg	[21:31:29] so as long as my samplings show it isn't, I don't care that I haven't sampled the entire space
2021-07-20 10:40:20	EvanR	[21:31:43] maybe this is a probabalistic application
2021-07-20 10:40:20	hseg	[21:31:53] not probabilistic. hypothesis testing
2021-07-20 10:40:20	EvanR	[21:32:08] counterexample finding?
2021-07-20 10:40:20	hseg	[21:32:16] exactly
2021-07-20 10:40:20	EvanR	[21:32:20] cool
2021-07-20 10:40:20	EvanR	[21:32:29] it only takes 1 xD
2021-07-20 10:40:20	hseg	[21:32:34] exactly
2021-07-20 10:40:20	hseg	[21:32:46] and unfortunately, I have >>>1
2021-07-20 10:40:20	hseg	[21:33:37] so I need to refine the invariant I'm using
2021-07-20 10:40:20	hseg	[21:33:52] not clear how, though
2021-07-20 10:40:20	hseg	[21:34:29] welp. that's what research is for, ig
2021-07-20 10:40:20	EvanR	[21:34:31] eventually you will not find any counterexamples
2021-07-20 10:40:20	hseg	[21:34:54] yeah. am hoping that by then, will have actual proof that my invariant works
2021-07-20 10:40:20	hseg	[21:36:12] especially considering this is trying to give a closed form for a recursive formula, have high hopes it is possible
2021-07-20 10:40:20	bpv	[21:59:00] How is it going?
2021-07-20 10:40:20	nova	[23:34:03] I am currently using arch with ghcup and cabal, but cabal takes SO long to install packages that it is simply not usable. I am about to try nixos or gentoo, and I was wondering if anyone here uses their respective package managers to manager haskell packages (pandoc, pandoc-citeproc [this takes forever to recompile pandoc], xmonad, xmobar, etc). If so, does one hold an edge over the other?
2021-07-20 10:40:20	nova	[23:37:24] I was using pacman, but I had to remove all of my haskell packages because it was even worse than ghcup (but at least it was fast)
2021-07-20 10:40:20	sclv	[23:39:30] we’re developers here mainly. compile times are what they are
2021-07-20 10:40:20	dsal	[23:41:16] nova: I'm a pretty big fan of nixos.  Nonetheless, first compilation can take a bit.
2021-07-20 10:40:20	davean	[23:41:29] You compile things once and you're done, meh?
2021-07-20 10:40:20	nova	[23:42:35] what about upgrades
2021-07-20 10:40:20	dsal	[23:43:12] Upgrades of what?
2021-07-20 10:40:20	yin[m]	[23:43:46] any way we can avoid having to add `Show a =>` to a bunch of type signatures when "No instance for (Show a) arising from a use of ..." just for a quick Debug.trace?
2021-07-20 10:40:20	dsal	[23:43:53] I do nix updates all the time because I like giving my computer busy work.  heh.  They're reversible, though.  If things go wrong, I can undo them.
2021-07-20 10:40:20	dsal	[23:44:17] yin[m]: You need some way to represent the values you're tracing.
2021-07-20 10:40:20	davean	[23:44:49] nova: uh, upgrades do the amount of work in the delta of the packages changed?
2021-07-20 10:40:20	nova	[23:45:22] does nix have to rebuild after downloading deltas?
2021-07-20 10:40:20	dsal	[23:45:44] nix can use binaries if they're available.  It'll build if they're not.
2021-07-20 10:40:20	davean	[23:45:45] If it doesn't have the builds cached
2021-07-20 10:40:20	yin[m]	[23:46:50] sure, and I know they are, but ghc complains that if what I'm trying to show is an a and the funcion I'm in doesn't have the Show constraint in it, i cant see it. are my only options to comment all the relevant type signatures or add the Show constraint everywhere? isn't there something like an unsafeShow?
2021-07-20 10:40:20	yin[m]	[23:47:19] i just want a quick print for debugging purposes
2021-07-20 10:40:20	yin[m]	[23:47:48] * sure, and I know they are, but ghc complains that if what I'm trying to show is an a and the funcion I'm in doesn't have the Show a => constraint in it, i cant see it. are my only options to comment all the relevant type signatures or add the Show constraint everywhere? isn't there something like an unsafeShow?
2021-07-20 10:40:20	geekosaur	[23:51:41] yin[m]: absent a Show constraint there may not even be code to do the Show
2021-07-20 10:40:20	geekosaur	[23:54:02] more correctly, without that constraint ghc doesn't know that the type involved has the code to do Show — and more to the point, doesn't have access to that code
2021-07-20 10:40:20	geekosaur	[23:54:20] (as ghc implements constraints)
2021-07-20 10:40:20	geekosaur	[23:56:52] a theoretical unsafeShow would still require some way to get access to the Show code for the type. in particular if it knows the type only at runtime, it would have to be passed in via a dictionary still
2021-07-20 10:40:20	davean	[23:59:31] geekosaur: how dirty should I be in answering how to do that?
2021-07-20 10:40:20	geekosaur	[00:03:38] oh brother
2021-07-20 10:40:20	amesgen[m]	[00:03:49] yin: you might be interested in `anythingToString`: https://hackage.haskell.org/package/recover-rtti-0.4.0.0/docs/Debug-RecoverRTTI.html
2021-07-20 10:40:20	davean	[00:04:03] geekosaur: ok, ok I won't break out my dirty tricks
2021-07-20 10:40:20	geekosaur	[00:04:23] I'm not surprised there's some kind of hack but I'm not sure handing out hacks is the best idea here
2021-07-20 10:40:20	davean	[00:04:38] Oh, its an actively bad idea
2021-07-20 10:40:20	zzz	[00:12:48] bow im curious
2021-07-20 10:40:20	zzz	[00:12:56] s/bow/now
2021-07-20 10:40:20	yin[m]	[00:13:07] inpromise I'll ignore it
2021-07-20 10:40:20	geekosaur	[00:13:26] there are some evil ways to manufacture dictionaries on the fly
2021-07-20 10:40:20	oso	[01:10:29] what's this arcane error i'm getting while trying to build and how can i fix it? i've tried a few things like explicitly  denoting types but can't get around it https://paste.tomsmeding.com/SIas3Dgn
2021-07-20 10:40:20	dsal	[01:11:13] You could use type applications.
2021-07-20 10:40:20	dsal	[01:11:15] Or ignore it.
2021-07-20 10:40:20	geekosaur	[01:12:03] and stop using -Werrorl or at least turn it off for defaulting
2021-07-20 10:40:20	geekosaur	[01:12:28] where it's kinda obnoxious because defaulting basically exists for this use case
2021-07-20 10:40:20	dsal	[01:12:51] Most of the time where I've had defaulting warnings, I've not cared.
2021-07-20 10:40:20	oso	[01:13:41] looking into defaulting, thanks
2021-07-20 10:40:20	geekosaur	[01:14:18] the problem is that there are cases where you pretty much can't specify the type
2021-07-20 10:40:20	geekosaur	[01:15:50] although here you could, you just have to annotate almost everything with a type
2021-07-20 10:40:20	oso	[01:16:10] i only had to annotate the 100 as a double, actually, that got rid of the warning
2021-07-20 10:40:20	oso	[01:18:08] thanks for pointing me in the right direction
2021-07-20 10:40:20	h98	[01:59:15] I love how GHC gets confused by numbers in instance resolution....is "1" a Word32 or a Ptr a -> Ptr b -> IO Word32? Who knows what he meant!
2021-07-20 10:40:20	Boarders	[03:51:19] does GHC have standalone kind signatures now?
2021-07-20 10:40:20	Boarders	[03:52:14] I can't seem to find it in the user guide so I must be looking in the wrong places
2021-07-20 10:40:20	justsomeguy	[04:05:38] In the book I'm reading, it says "Functional programming languages are all based on lambda calculus." Isn't this wrong? -- Lisp (non-scheme, older versions only), I think, was based on McCarthy's recursive function notation. I've also encountered some quotes about ALGOL 68 being described partly in lambda calculus, which leads me to ask -- what does it mean for a language to be based on lambda
2021-07-20 10:40:20	justsomeguy	[04:05:40] calculus in the first place?
2021-07-20 10:40:20	Boarders	[04:06:54] lisp was definitely based on the lambda calculus even if mccarthy made improvements to it as a programming language
2021-07-20 10:40:20	justsomeguy	[04:07:50] There's a quote in this article by McCarthy saying otherwise ... https://danielsz.github.io/blog/2019-08-05T21_14.html
2021-07-20 10:40:20	justsomeguy	[04:08:30] Or, err, a quote by McCarthy in this article by Danielsz.
2021-07-20 10:40:20	justsomeguy	[04:08:47] (Words are hard, sometimes.)
2021-07-20 10:40:20	Boarders	[04:09:16] everyone else involved in lisp seemed to think it was "based on" the lambda calculus so I wouldn't take what McCarthy's quote means too seriously
2021-07-20 10:40:20	Boarders	[04:09:33] especially for instance the writers of scheme
2021-07-20 10:40:20	Boarders	[04:10:05] who wrote a whole series of papers explaining how to encode various programming language construct in lambda calculus
2021-07-20 10:40:20	justsomeguy	[04:10:27] Hmm... ok.
2021-07-20 10:40:20	Boarders	[04:11:17] this is a relevant paper: https://dspace.mit.edu/handle/1721.1/6091
2021-07-20 10:40:20	justsomeguy	[04:12:05] I'm still not sure the calculus matters. If a PL was developed that is based on SKI combinator calculus, and had functional features (referential transparency, first-class functions) would you consider that a functional language?
2021-07-20 10:40:20	 *	justsomeguy [04:12:18] is checking out the paper now
2021-07-20 10:40:20	justsomeguy	[04:13:36] But I think I'm probably taking that quote from the book too literally.
2021-07-20 10:40:20	lechner	[04:14:06] which book?
2021-07-20 10:40:20	justsomeguy	[04:14:21] Haskell programming from first princpiles (haskellbook.com)
2021-07-20 10:40:20	justsomeguy	[04:15:21] I'm, uhh, currently over-analysing the first chapter as part of a strange procrastination ritual.
2021-07-20 10:40:20	lechner	[04:16:49] sometimes it's worthwhile to get your bearings right
2021-07-20 10:40:20	justsomeguy	[04:17:42] Well, at least I'm still learning new things from it.
2021-07-20 10:40:20	dsal	[04:31:36] It's a great book. Depends on what you need to get out of it, though.  I didn't care much about that particular bit of theory.
2021-07-20 10:40:20	justsomeguy	[04:45:07] I've been developing a love hate relationship with it. I like the order that it teaches things in, and also how it leaves a lot of breadcrumbs to explore further. On the other hand, I often wish it to be more explcit about what the learning objectives for each chapter are, and have better code examples of where a newly introduced abstraction will be useful. It's also just too long, and not
2021-07-20 10:40:20	justsomeguy	[04:45:09] structured well enough to keep track of things (section names aren't descriptive enough, no figure numbers).
2021-07-20 10:40:20	justsomeguy	[04:45:36] But part of that is also just me learning how to read a big book.
2021-07-20 10:40:20	 *	justsomeguy [04:46:48] hasn't attempted to read a large non-fiction book where he can't "keep it all in his head" at once before this.
2021-07-20 10:40:20	dsal	[05:09:27] Well, the lambda calculus thing is the first chapter, so like, I'm not sure how you got such a judgment.  :)
2021-07-20 10:40:20	dsal	[05:09:39] But it mostly just walks you through building a lot of the fundamentals.
2021-07-20 10:40:20	***	Playback Complete.
2021-07-20 10:40:27	--	Channel created on Sun, 25 Apr 2021 01:04:39
2021-07-20 10:40:36	--	irc: disconnected from server
2021-07-20 10:40:41	-->	amanr (~therojjha@20.204.87.0) has joined #haskell
2021-07-20 10:40:41	--	Topic for #haskell is "https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org | Paste code/errors: https://paste.tomsmeding.com | tunes.org-style logging should be coming soon | Logs: https://ircbrowse.tomsmeding.com/browse/lchaskell"
2021-07-20 10:40:41	--	Topic set by geekosaur (~geekosaur@xmonad/geekosaur) on Mon, 14 Jun 2021 05:16:14
2021-07-20 10:40:41	--	Channel #haskell: 702 nicks (1 op, 0 voices, 701 normals)
2021-07-20 10:40:41	***	Buffer Playback...
2021-07-20 10:40:41	dminuoso	[10:27:17] Well, strictly speaking:
2021-07-20 10:40:41	dminuoso	[10:27:20] % :t (*>)
2021-07-20 10:40:41	yahb	[10:27:20] dminuoso: Applicative f => f a -> f b -> f b
2021-07-20 10:40:41	dminuoso	[10:27:54] guest719: `traverse` can be thought to use (*>) internally, which is just an Applicative version of >>
2021-07-20 10:40:41	dminuoso	[10:28:04] Roughly the idea is:
2021-07-20 10:40:41	dminuoso	[10:29:39] We take this function (a -> f b) (say `String -> IO Int`)from above, and we `fmap` over the structure (say `[String]`). Then, each value is replaced with a computation of some type (say `IO Int`), so the whole structure then is `[IO Int]`.
2021-07-20 10:40:41	dibblego	[10:29:55] you might be thinking of traverse_
2021-07-20 10:40:41	dminuoso	[10:29:58] Then we `sequence` this, which turns `[IO Int] -> IO [Int]`
2021-07-20 10:40:41	dminuoso	[10:32:32] Imagine this to be: sequence (x:xs) = (:) <$> x <*> sequence xs; sequence [] = pure []
2021-07-20 10:40:41	dminuoso	[10:32:58] dibblego: Ah yeah. I guess that was wrong of me.
2021-07-20 10:40:41	dminuoso	[10:33:06] While I was typing the definition, I realized my mistake.
2021-07-20 10:40:41	dminuoso	[10:33:44] % mySequence (x:xs) = (:) <$> x <*> mySequence xs; mySequence [] = pure []
2021-07-20 10:40:41	yahb	[10:33:44] dminuoso: 
2021-07-20 10:40:41	dminuoso	[10:33:46] % :t mySequence
2021-07-20 10:40:41	yahb	[10:33:46] dminuoso: Applicative f => [f a] -> f [a]
2021-07-20 10:40:41	dibblego	[10:33:52] I think sequence is more obvious in the way you are trying to explain it, like this:
2021-07-20 10:40:41	dminuoso	[10:33:53] % mySequence [Just 10, Just 20, Just 30]
2021-07-20 10:40:41	yahb	[10:33:53] dminuoso: Just [10,20,30]
2021-07-20 10:40:41	dibblego	[10:34:20] (::.) = liftA2 (:); lift0 = pure; sequence (x:xs) = x ::. sequence xs; sequence [] = lift0 []
2021-07-20 10:40:41	dibblego	[10:35:56] once liftA2 is understood conceptually, then (*>) is quite simply: const id with some liftA2-ness
2021-07-20 10:40:41	albet70	[11:18:46] so could we say traverse another version of fmap which it can do earlier exit?
2021-07-20 10:40:41	[exa]	[11:21:01] "another" may be a weak label for the myriad of extra stuff it can do :]
2021-07-20 10:40:41	dminuoso	[11:28:04] albet70: Mmm, not just that.
2021-07-20 10:40:41	dminuoso	[11:28:38] albet70: Say you have a Tree of values, say of type String. For each string you want to query some database, and replace the string with some value you read from the database, say something of type User.
2021-07-20 10:40:41	dminuoso	[11:29:00] then you can do: do { userTree <- traverse fetchUserFromString stringTree; ... }
2021-07-20 10:40:41	dminuoso	[11:29:46] albet70: The key thing to realize is that Applicative/Monad encode certain.. "effects". For `Maybe/Either e` the effect is that of an exception, for IO it's outside world interaction, for list it's non-determinism, etc..
2021-07-20 10:40:41	dminuoso	[11:30:00] So we map each element to an effectful computation, and then sequence them
2021-07-20 10:40:41	dminuoso	[11:30:38] Important bit to notice, is that traverse fundamentally does not change the "shape" of that structure. So if you traverse over a tree, the shape of it remains (so you cant drop or create nodes)
2021-07-20 10:40:41	dminuoso	[11:31:44] traverse on a list for example gives us a more generalized version of effectful loops. So a Python loop in which you do say database queries can be written with `traverse`
2021-07-20 10:40:41	dminuoso	[11:31:57] But `traverse` allows us to do even more, not just database queries
2021-07-20 10:40:41	dminuoso	[11:32:03] And it works on not just lists, but also trees.
2021-07-20 10:40:41	dibblego	[12:04:11] traverse is exactly fmap, if you use Identity in place of the general Applicative 
2021-07-20 10:40:41	dibblego	[12:04:32] but it also does other Applicative things, not just Identity
2021-07-20 10:40:41	hseg	[12:45:53] hi. have this generator http://ix.io/3tqe, and I would like to generalize it so its input generators can depend on each other's results (i.e. want to be able to pass [a -> Gen a])
2021-07-20 10:40:41	hseg	[12:46:15] have tried just doing that, but it involves a lot of churn
2021-07-20 10:40:41	hseg	[12:46:30] is there a more mtl'y way of writing this that can help avoid this churn
2021-07-20 10:40:41	hseg	[12:46:33] ?
2021-07-20 10:40:41	hseg	[12:48:03] presumably, I'd want to have inputs be sth like [n a] with MonadGen n and some constraint expressing that whatever effects n gives are liftable to m 
2021-07-20 10:40:41	hseg	[12:48:43] but that looks overly involved
2021-07-20 10:40:41	zangi	[12:58:35] probably a paradox, but does having IO means haskell is impure? :)
2021-07-20 10:40:41	Axman6	[12:58:42] no
2021-07-20 10:40:41	zangi	[12:59:30] does IO itself impure? what does it mean to be "pure" in haskell sense?
2021-07-20 10:40:41	Axman6	[12:59:49] IO is pure, the execution of it may not be. dibblego is excellent at explaining why 
2021-07-20 10:40:41	 *	Axman6 [12:59:59] handballs the conversation to dibblego
2021-07-20 10:40:41	DigitalKiwi	[13:00:15] what about unsafeCoerce
2021-07-20 10:40:41	zangi	[13:00:52] who's dibblego?
2021-07-20 10:40:41	DigitalKiwi	[13:01:13] why's dibblego
2021-07-20 10:40:41	Axman6	[13:01:43] HE authored much of the NICTA/Data61/System-F FP course, where we explain why IO is pure
2021-07-20 10:40:41	Axman6	[13:01:46] He*
2021-07-20 10:40:41	zangi	[13:02:18] does he have any article about this issue?
2021-07-20 10:40:41	DigitalKiwi	[13:02:20] ofc we all know the answer to how's dibblego (by plane)
2021-07-20 10:40:41	DigitalKiwi	[13:02:35] ba dum tsch
2021-07-20 10:40:41	DigitalKiwi	[13:03:14] https://github.com/system-f/fp-course
2021-07-20 10:40:41	DigitalKiwi	[13:03:41] https://www.youtube.com/watch?v=NzIZzvbplSM&list=PLly9WMAVMrayYo2c-1E_rIRwBXG_FbLBW
2021-07-20 10:40:41	zangi	[13:04:27] DigitalKiwi++
2021-07-20 10:40:41	zangi	[13:05:09] thanks, anyway does it mean IO in haskell is different to IO in other (imperative) languages?
2021-07-20 10:40:41	[exa]	[13:07:53] zangi: haskell is pure; the ugly impure execution of the IO action recipes written in haskell is only done by computers
2021-07-20 10:40:41	kuribas	[13:08:27] [exa]: but then any language is pure?
2021-07-20 10:40:41	[exa]	[13:09:12] nah, some languages rely on that impurity
2021-07-20 10:40:41	[exa]	[13:10:27] (and some certain others are just dirty)
2021-07-20 10:40:41	DigitalKiwi	[13:15:18] i like my coffee like i like my programming languages; strong, statically typed, purely functional with type inference and lazy evaluation.
2021-07-20 10:40:41	lechner	[13:18:13] Hi, how can I use MonadFail to handle exceptions from Codec.Compression.Lzma, please?
2021-07-20 10:40:41	Boarders	[13:34:58] is there a variant combinator in megaparsec that is like: do {t <- takeWhileP Nothing (/= '\n'); char '\n'; pure t}
2021-07-20 10:40:41	tdammers	[13:40:37] https://hackage.haskell.org/package/parser-combinators-1.3.0/docs/Control-Applicative-Combinators.html#v:manyTill maybe?
2021-07-20 10:40:41	dmj`	[13:41:19] lechner: did you try using `catch`
2021-07-20 10:40:41	Boarders	[13:44:40] manyTill is very related but not quite the same
2021-07-20 10:40:41	lechner	[13:45:32] dmj`:  i'm still reading, and working on my general Haskell learning curve
2021-07-20 10:40:41	lechner	[13:51:21] dmj`: but i do have working program (which i wrote) where I could try your suggestion. how do i use catch, please?    https://salsa.debian.org/lintian/kickoff/-/blob/master/Collect.hs#L82
2021-07-20 10:40:41	tzh	[14:06:39] hey so i'm working on a haskell game; does anybody have any suggestions for an input library that would work well? previously i've used reactive-banana, which worked well enough even if its FRP nature made it a little clunky for use in a highly-interactive program. i saw some people mention using arrowized FRP libraries likes Yampa/dunai but that seems more like something to use for physics integration than for things like 'how to click on 
2021-07-20 10:40:41	tzh	[14:06:40] a menu'
2021-07-20 10:40:41	kuribas	[14:14:12] tzh: reactive-banana isn't an input library, it's a FRP library.
2021-07-20 10:40:41	kuribas	[14:14:20] You can use it with any UI library.
2021-07-20 10:40:41	maerwald	[14:15:21] SDL2?
2021-07-20 10:40:41	[exa]	[14:15:37] tzh: immediate-mode GUIs (google imgui) are priceless for games, except I don't know if we have any for haskell yet
2021-07-20 10:40:41	tzh	[14:15:51] kuribas: okay yes it's not a raw input-catching library; i'm actually using glfw for that. what i'm looking for is an input _processing_ library, to impose some order onto my input flow so it's not a bunch of ad-hoc garbage
2021-07-20 10:40:41	kuribas	[14:16:18] tzh: reactive-banana should be fine.
2021-07-20 10:40:41	tzh	[14:21:02] the main issue with reactive-banana is that it gets pretty clunky since it only runs in IO and thus can never directly run actual buffer writes... (well, okay, there are ways but that becomes a mess of running all input-processing code inside a render monad, with an unknown timing to my render loop). which means i need to have its output actions queue render actions like buffer allocations/writes, and then outside of the event loop pull 
2021-07-20 10:40:41	tzh	[14:21:03] them out so they can actually be run, which seems a little clunky and counter to the FRP experience, but i don't really see how that could be avoided given how opengl rendering works. so really i'd just like for that experience to be a bit smoother
2021-07-20 10:40:41	dmj`	[15:18:00] lechner:  do { result <- try (evaluate (decompress bytes)) :: IO (Either SomeException ByteString); case result of { Left e -> print e; Right bytes -> print (length bytes) } }
2021-07-20 10:40:41	Las[m]	[15:22:29] Question about bound threads: Will unbound threads use an OS thread created by forkOS?
2021-07-20 10:40:41	monochrom	[15:26:24] Probably in an ideal world shouldn't matter but in practice the GHC implementers wouldn't troll themselves by doing that.
2021-07-20 10:40:41	monochrom	[15:28:14] In practice there is pure Haskell code that can hold up an OS thread uninterruptible. Now what can you do when the rightful owner of the OS thread needs it?
2021-07-20 10:40:41	c_wraith	[15:30:03] honestly, that's not a very important edge case, given that the same pure code that will hold a thread uninterruptably will also block garbage collection, and therefore the entire program via stop-the-world GC
2021-07-20 10:40:41	c_wraith	[15:31:12] If you write a loop that does that, you get what you deserve whether bound threads are involved or not.
2021-07-20 10:40:41	c_wraith	[15:31:51] (this is why mueval starts new processes, not just threads)
2021-07-20 10:40:41	jumper149	[15:43:28] The diagram here: https://wiki.haskell.org/Typeclassopedia
2021-07-20 10:40:41	jumper149	[15:43:49] It is missing the superclass `Alternative` of `MonadPlus` :(
2021-07-20 10:40:41	Boarders	[15:54:34] in haddock if I want to include an example that is too long then is the thing to put definitions in a codeblock or make the example multi-line or something else?
2021-07-20 10:40:41	sm	[15:55:56] Boarders: you can have
2021-07-20 10:40:41	sm	[15:55:57] @
2021-07-20 10:40:41	sm	[15:55:57] multi line example...
2021-07-20 10:40:41	sm	[15:55:57] @
2021-07-20 10:40:41	Boarders	[15:58:40] how do you indicate with that what it should evaluate to?
2021-07-20 10:40:41	sm	[15:59:45] (maybe that got truncated. @ delimiters.)
2021-07-20 10:40:41	sm	[16:00:15] Boarders: are you asking about doctests ? the doctest doc will tell
2021-07-20 10:40:41	sm	[16:02:34] https://github.com/sol/doctest#readme
2021-07-20 10:40:41	gentauro	[16:21:01] does anybody has the link to a tweet staging: «category theory is the mathematics of mathematics»?
2021-07-20 10:40:41	gentauro	[16:21:19] I think it was from a female cs prof (I recall)
2021-07-20 10:40:41	Boarders	[16:22:56] https://twitter.com/emilyriehl/status/979375728373518336?s=20
2021-07-20 10:40:41	lechner	[16:24:55] dmj`: it compiled, but did not stop the program from terminating. i got the same message as before:  "Codec.Compression.Lzma.decompressWith: decoding error LzmaRetOK"      https://dpaste.org/FGQs#L7,84,85,86,87
2021-07-20 10:40:41	c_wraith	[16:24:57] In that tweet she credits Eugenia Cheng, which is a name I've heard before.
2021-07-20 10:40:41	lechner	[16:31:13] just make sure you pronounce it right, please    http://eugeniacheng.com/pronunciation/
2021-07-20 10:40:41	dmj`	[16:41:23] lechner: I think the issue is that you're not forking a thread to handle new clients, so your server terminates immediately, since the main thread of execution exits.. You're just blocking on a socket receive until the client exits, then your process terminates. You need to fork threads for each client and ensure the main thread of execution is running indefinitely
2021-07-20 10:40:41	lechner	[16:43:30] dmj`: without a decoding error, this does run forever   https://dpaste.org/FGQs#L105
2021-07-20 10:40:41	lechner	[16:43:47] via iterateM_
2021-07-20 10:40:41	lechner	[16:45:07] it is in fact my motivation to catch the error
2021-07-20 10:40:41	gentauro	[16:52:23] 18:22 < Boarders> https://twitter.com/emilyriehl/status/979375728373518336
2021-07-20 10:40:41	gentauro	[16:52:29] Boarders: that's the one. Thx :)
2021-07-20 10:40:41	jumper149	[17:16:10] I want to choose a Haskell formatter. Are there any nice comparisons? Maybe a blog post?
2021-07-20 10:40:41	[exa]	[17:17:00] jumper149: probably best to ask yourself why you want the formatting at first
2021-07-20 10:40:41	dsal	[17:17:07] Haskell In Depth went over them slightly, but didn't offer an opinion.
2021-07-20 10:40:41	dsal	[17:17:32] IMO, ormolu is weird and wrong, but it's the new kid and at least some people like it.
2021-07-20 10:40:41	dminuoso	[17:17:33] I chose emacs as my formatter. I can press enter, and it formats the code nicely.
2021-07-20 10:40:41	dminuoso	[17:17:49] If it does it wrong, I can change the indentation with a single keypress.
2021-07-20 10:40:41	[exa]	[17:17:55] fourmolu is kinda less bad than ormolu
2021-07-20 10:40:41	 *	geekosaur [17:18:17] formats man8ually as no formatter matches his preference
2021-07-20 10:40:41	dsal	[17:18:30] I use stylish-haskell when I remember.  It usually does OK.
2021-07-20 10:40:41	jumper149	[17:18:41] I want formatting to be consistent over a project. And I would like something that makes sense with git.
2021-07-20 10:40:41	maerwald	[17:18:48] brittany got close to my needs, but it tends to pull apart code so much that stuff becomes overly verbose
2021-07-20 10:40:41	dsal	[17:18:55] I mainly like my imports tidy.
2021-07-20 10:40:41	dminuoso	[17:18:59] jumper149: A consistent style is already a bizarre thing.
2021-07-20 10:40:41	dsal	[17:19:02] jumper149: git just stores blobs, so that's not a big deal.  :)
2021-07-20 10:40:41	dminuoso	[17:19:11] jumper149: Code formatting communicates intent and structure, its highly contextual.
2021-07-20 10:40:41	maerwald	[17:19:39] dminuoso: yes, the consistency argument is mostly nonsense imo. The "I'm too lazy argument" I can get behind
2021-07-20 10:40:41	maerwald	[17:19:42] because I am
2021-07-20 10:40:41	dsal	[17:19:43] ormolu was inspired by elm's canonical format in a lot of way and they prioritized making it easy to read diffs generated by whatever tools they happened to use.  This is a terrible mistake, IMO.
2021-07-20 10:40:41	monochrom	[17:19:45] Perhaps "makes sense with git" means "makes sense with diff".
2021-07-20 10:40:41	dminuoso	[17:19:49] It's sort of the equivalent of saying "a paragraph must always have 3 sentences". It's a stupid proposition to begin with.
2021-07-20 10:40:41	jumper149	[17:20:01] monochrom: exactly!
2021-07-20 10:40:41	dminuoso	[17:20:21] Yes, if each paragraph has 3 sentences, you have a consistent formatting of your natural language. But it really hampers readability
2021-07-20 10:40:41	dsal	[17:20:25] Most of the time when I'm reading code, I'm not reading diffs.  I'd rather prioritize the code over the diffs.
2021-07-20 10:40:41	monochrom	[17:20:32] People keep XYing their diction all the time. Remember that one time when someone said "haddock" to mean doctest?
2021-07-20 10:40:41	maerwald	[17:21:49] dsal: in a lot of PRs I've seen at work there was no way to understand anything from the diff without a walkthrough by the author. Even looking at my own PRs I don't understand anything. In some companies the author writes a walkthrough in the diff comments, but even then: diffs lie
2021-07-20 10:40:41	maerwald	[17:22:16] you don't see the code you changed, only the lines you changed
2021-07-20 10:40:41	jumper149	[17:22:26] I particularly want a formatter for stuff like same style Haddocks (-- vs {- -}), sorted imports and extensions.
2021-07-20 10:40:41	dminuoso	[17:22:43] jumper149: For import/extensions sorting, I find stylish-haskell to be agreeable.
2021-07-20 10:40:41	dminuoso	[17:22:49] (It just breaks in the presence of QQs and TH)
2021-07-20 10:40:41	maerwald	[17:22:54] and CPP
2021-07-20 10:40:41	dminuoso	[17:23:16] jumper149: But note, you should chose your tool to fit *your* style.
2021-07-20 10:40:41	dsal	[17:23:16] maerwald: yeah.  I have that problem reading diffs sometimes.  Like, cool you changed x to y... but what was x and what's y?
2021-07-20 10:40:41	maerwald	[17:23:34] also: reverse dependencies of your code
2021-07-20 10:40:41	maerwald	[17:23:57] you might need to re-read the entire codebase from a different perspective
2021-07-20 10:40:41	maerwald	[17:24:21] while the scrum master is asking why the PR is still not merged
2021-07-20 10:40:41	maerwald	[17:24:56] but hey... not everyone works in security critical code: just push and hope for the best
2021-07-20 10:40:41	monochrom	[17:25:02] "the closer you look, the less you see"
2021-07-20 10:40:41	dminuoso	[17:25:30] monochrom: Yes, that was the mentality of openssl. Distance yourself from the code and embrace Heartbleed!
2021-07-20 10:40:41	dsal	[17:25:32] These modern "diff-friendly" things take something small, clear and readable and make me have to scroll to understand what's going on.  https://www.irccloud.com/pastebin/dhodxIZ7/ok.elm
2021-07-20 10:40:41	monochrom	[17:25:42] haha
2021-07-20 10:40:41	geekosaur	[17:26:11] I somewhat regularly have to click on the extend buttons in github to understand a diff
2021-07-20 10:40:41	geekosaur	[17:26:26] which is the simple version of this
2021-07-20 10:40:41	monochrom	[17:26:54] Clearly, the logical conclusion is one token per line. >:)
2021-07-20 10:40:41	dsal	[17:27:08] There are lots of cases where formatters seem to do that.
2021-07-20 10:40:41	maerwald	[17:27:12] There is a very grumpy C coder on my LinkedIn feed, always riling about security and code correctness. Then one day he wrote why: his bug actually killed people, because it was some control system about pressure valves.
2021-07-20 10:40:41	dsal	[17:27:16] With lines between them.
2021-07-20 10:40:41	dsal	[17:28:09] monochrom: Like, imagine how hard this would be to read if that 'o' shared a line with any of the other code:  https://www.irccloud.com/pastebin/lIpmTDCu/format.elm
2021-07-20 10:40:41	maerwald	[17:28:18] but I don't know what he thinks of code formatters
2021-07-20 10:40:41	maerwald	[17:28:39] then again: that's a solved issue in C anyway
2021-07-20 10:40:41	dsal	[17:29:15] I really like tools that do static analysis and stuff in my code to tell me when I could do things better.   That's an unreasonably hard problem to solve well, though.
2021-07-20 10:40:41	maerwald	[17:34:59] I think the main question is: do you align code or just do syntactical indenting
2021-07-20 10:40:41	euouae	[17:36:50] Hello
2021-07-20 10:40:41	euouae	[17:37:15] I want to create a lazy list whose nth element is a function of its predecessor 
2021-07-20 10:40:41	monochrom	[17:37:27] iterate
2021-07-20 10:40:41	euouae	[17:37:38] What do you mean 
2021-07-20 10:40:41	monochrom	[17:37:49] Look for that function name in the standard library.
2021-07-20 10:40:41	euouae	[17:39:21] Thank you !
2021-07-20 10:40:41	maerwald	[17:39:53] @hoogle iterate
2021-07-20 10:40:41	lambdabot	[17:39:53] Prelude iterate :: (a -> a) -> a -> [a]
2021-07-20 10:40:41	lambdabot	[17:39:54] Data.List iterate :: (a -> a) -> a -> [a]
2021-07-20 10:40:41	lambdabot	[17:39:54] Data.List.NonEmpty iterate :: (a -> a) -> a -> NonEmpty a
2021-07-20 10:40:41	maerwald	[17:40:27] @where hoogle
2021-07-20 10:40:41	lambdabot	[17:40:27] http://haskell.org/hoogle http://hoogle.haskell.org http://fpcomplete.com/hoogle – See also Hayoo, which searches more packages: http://hayoo.fh-wedel.de/
2021-07-20 10:40:41	maerwald	[17:40:40] hayoo is dead no?
2021-07-20 10:40:41	maerwald	[17:41:01] and the fpcomplete link too
2021-07-20 10:40:41	monochrom	[17:41:16] yikes
2021-07-20 10:40:41	geekosaur	[17:41:44] yeh, nobody's updated that
2021-07-20 10:40:41	euouae	[17:42:39] Has anyone tried Haskell on a supercomputer?
2021-07-20 10:40:41	geekosaur	[17:42:48] @where+ hoogle https://hoogle.haskell.org see also https://haskell.org/hoogle which searches a different default set of libraries
2021-07-20 10:40:41	lambdabot	[17:42:48] I will remember.
2021-07-20 10:40:41	geekosaur	[17:43:04] define supercomputer
2021-07-20 10:40:41	maerwald	[17:43:15] for me, both links are the same
2021-07-20 10:40:41	geekosaur	[17:43:33] interesting, maybe they made the old one go away
2021-07-20 10:40:41	maerwald	[17:43:34] haskell.org/hoogle redirects to hoogle.haskell.org
2021-07-20 10:40:41	euouae	[17:43:40] Hmm I’m trying to run a lot of computations and get an answer 
2021-07-20 10:40:41	euouae	[17:43:53] for now I have like 100 cores etc 
2021-07-20 10:40:41	geekosaur	[17:43:56] @where+ hoogle https://hoogle.haskell.org
2021-07-20 10:40:41	lambdabot	[17:43:56] Nice!
2021-07-20 10:40:41	dmj`	[17:44:49] Someone should write a library for parsing XML with GHC.Generics
2021-07-20 10:40:41	geekosaur	[17:45:46] iirc ghc's performance gets worse the more cores you have :( (but maybe this has improved, that was around 7.x)
2021-07-20 10:40:41	geekosaur	[17:46:06] mostly because of stop-the-world gc, though
2021-07-20 10:40:41	euouae	[17:46:51] Okay interesting 
2021-07-20 10:40:41	davean	[17:46:59] It gets harder to make it perform well with more cores, it doesn't inhernety not perform well.
2021-07-20 10:40:41	maerwald	[17:47:06] dmj`: why are you using xml :>
2021-07-20 10:40:41	davean	[17:47:08] But no super computing task is single process
2021-07-20 10:40:41	euouae	[17:47:21] Davean my knowledge is limited 
2021-07-20 10:40:41	davean	[17:47:22] I mean if you could fit it on one system it wouldn't really be using a modern supercomputer
2021-07-20 10:40:41	euouae	[17:47:50] I am not great at Haskell and never programmed for supercomputers before
2021-07-20 10:40:41	euouae	[17:49:49] But Haskell is really attractive for math 
2021-07-20 10:40:41	davean	[17:49:52] I think I've heard of some super computer Haskell use. I'd say everything to do with super computers is pretty definitionally specialized
2021-07-20 10:40:41	euouae	[17:50:17] Yeah basically you need to be very knowledgeable in the domain davean 
2021-07-20 10:40:41	euouae	[17:50:25] And I’m just trying to get by 
2021-07-20 10:40:41	maerwald	[17:50:30] is this about bitcoin mining?
2021-07-20 10:40:41	davean	[17:50:33] The domain, but also that specific computer
2021-07-20 10:40:41	davean	[17:50:38] maerwald: I sure hope not!
2021-07-20 10:40:41	euouae	[17:50:46] No lol it’s research 
2021-07-20 10:40:41	dmj`	[17:50:50] maerwald: AWS S3 still uses XML, https://docs.aws.amazon.com/AmazonS3/latest/API/API_ListObjectsV2.html
2021-07-20 10:40:41	euouae	[17:51:17] Bitcoin stuff is so scummy o want nothing with. It
2021-07-20 10:40:41	davean	[17:52:26] maerwald: Many code bugs kill a large number of fractional people
2021-07-20 10:40:41	euouae	[17:53:01] Davean I don’t understand how situational it could be though 
2021-07-20 10:40:41	euouae	[17:53:22] what I have is some pure math computations applied to many different numbers (say)
2021-07-20 10:40:41	davean	[17:53:54] euouae: The structure of the super computers differ, and the primary issue with super computers is communication
2021-07-20 10:40:41	davean	[17:54:03] You optimize communication, not compute
2021-07-20 10:40:41	euouae	[17:54:11] For now I’m on a single node 
2021-07-20 10:40:41	davean	[17:54:14] The network structures are all different for different optimalities
2021-07-20 10:40:41	davean	[17:54:26] Yes, and theres no modern single node super computers
2021-07-20 10:40:41	euouae	[17:54:54] It’s not necessarily a supercomputer since it’s single node but I’m starting from that 
2021-07-20 10:40:41	davean	[17:54:55] even on a single processor, you have to deal with inter-core communication issues, they're just less
2021-07-20 10:40:41	euouae	[17:55:07] Inter core? 
2021-07-20 10:40:41	euouae	[17:55:22] Are you talking about worker communication?
2021-07-20 10:40:41	euouae	[17:55:28] I’m not following 
2021-07-20 10:40:41	geekosaur	[17:57:54] things like shared memory access
2021-07-20 10:40:41	euouae	[17:58:13] Why is that important ?
2021-07-20 10:40:41	euouae	[17:58:29] I think in my problem no memory is shared 
2021-07-20 10:40:41	euouae	[17:58:54] It’s like map f xs but parallel 
2021-07-20 10:40:41	geekosaur	[17:59:09] if you're handling out subproblems to different threads/cores to be worked on, then there is at least some shared memory
2021-07-20 10:40:41	euouae	[17:59:12] More or less, maybe with a stop condition
2021-07-20 10:40:41	euouae	[17:59:36] Okay but this is the most basic form of it right?
2021-07-20 10:40:41	euouae	[18:04:02] Anyway those issues are part of the algorithm right?
2021-07-20 10:40:41	euouae	[18:04:14] Not some other aspect of the peoblrm
2021-07-20 10:40:41	euouae	[18:04:20] problem*
2021-07-20 10:40:41	davean	[18:04:54] I mean your algorithm isn't determined
2021-07-20 10:40:41	davean	[18:05:02] you design one to optimize for the HW
2021-07-20 10:40:41	geekosaur	[18:05:06] you'd best hope they are, but that would mean it's been specialized to your supercomputer
2021-07-20 10:40:41	davean	[18:05:51] what alg. is best depends on what your counting, and what the various costs are
2021-07-20 10:40:41	davean	[18:06:02] along with your expected problem parameters
2021-07-20 10:40:41	euouae	[18:06:45] So it’s really hard or are you just talking about the optimal case?
2021-07-20 10:40:41	monochrom	[18:07:14] I would think "really hard" and "the optimal case" go well together.
2021-07-20 10:40:41	davean	[18:07:55] Depends on the problem
2021-07-20 10:40:41	davean	[18:08:14] if you're scaling it up past a very small case though I'm talking about what it usually takes to do a servicable job at it
2021-07-20 10:40:41	euouae	[18:08:49] Davean are you speaking from experience with industry or research 
2021-07-20 10:40:41	euouae	[18:09:12] obviously any optimization means more profit in industry I imagine it’s really right
2021-07-20 10:40:41	davean	[18:09:15] yes, though my research wasn't particularly compute intensive even if it was "AI"
2021-07-20 10:40:41	euouae	[18:09:50] But in research there can be diminishing returns because your problem isn’t computationally feasible anyway after n=10 etc
2021-07-20 10:40:41	euouae	[18:10:22] Okay… hmmm. Is it possible for me to get into this at all or am I hopeless?
2021-07-20 10:40:41	davean	[18:10:36] euouae: I mean theres a huge difference between Floyd-Warshall and A*
2021-07-20 10:40:41	davean	[18:10:43] euouae: but they both sorta solve the same problem space
2021-07-20 10:40:41	geekosaur	[18:10:44] nobody here can tell that as we don't know your problem
2021-07-20 10:40:41	euouae	[18:10:59] I don’t know those davean
2021-07-20 10:40:41	euouae	[18:11:55] Okay maybe I’ll ask again if I have something more to show 
2021-07-20 10:40:41	davean	[18:11:56] ANd oh no, Floyd-Warshall is O(|V|^3), and A* is only O(|E|)! Clearly A* is always better? Except not at all
2021-07-20 10:40:41	euouae	[18:12:45] Big constants davean?
2021-07-20 10:40:41	davean	[18:12:45] well |E| can be ~ |V|^2, and what if you want the best paths, not approximations, but you're metric isn't admissible? And you want it for all of them? Or even just one side of those?
2021-07-20 10:40:41	davean	[18:12:51] euouae: no, nothing to do with constants
2021-07-20 10:40:41	davean	[18:13:41] Algrithmicly Floyd-Warshall is the same complexity for some use cases, because while they solve the same-ish problems, they do it for different uses
2021-07-20 10:40:41	davean	[18:13:57] if you do something |V|^2 |V times, thats |V|^3
2021-07-20 10:40:41	davean	[18:14:17] But Floyd-Warshall requires more communication
2021-07-20 10:40:41	davean	[18:14:27] A* is the "embarasingly" paralleler case
2021-07-20 10:40:41	davean	[18:14:53] so if you're CPUs are very seperated, maybe you want to work more like that again, except not you can go back and plan the communication of F-W ...
2021-07-20 10:40:41	euouae	[18:16:14] Oh man I’m not following 
2021-07-20 10:40:41	euouae	[19:04:02] Hello why am I getting a stack overflow for this? sum $ map f [T x y z | x<-xs, y<-xs, z<-xs ] where xs has 256 elements 
2021-07-20 10:40:41	euouae	[19:04:22] and f calculates the area of the triangle with vertices x y and z
2021-07-20 10:40:41	Hecate	[19:04:25] euouae: stack or heap? 
2021-07-20 10:40:41	euouae	[19:04:34] Says stack on Gucci 
2021-07-20 10:40:41	euouae	[19:04:36] Ghci 
2021-07-20 10:40:41	davean	[19:05:44] 256^3?
2021-07-20 10:40:41	h98	[19:05:47] 256^3 = 16,777,216
2021-07-20 10:40:41	euouae	[19:05:57] I was hoping that it wouldn’t have to expand a 256^3 list before summing 
2021-07-20 10:40:41	geekosaur	[19:06:03] is this sum being foldl again?
2021-07-20 10:40:41	euouae	[19:06:23] Are you asking me?
2021-07-20 10:40:41	geekosaur	[19:06:30] no
2021-07-20 10:40:41	hseg	[19:07:00] hi. have this generator http://ix.io/3tqe, and I would like to generalize it so its input generators can depend on each other's results (i.e. want to be able to pass [a -> Gen a])
2021-07-20 10:40:41	Rembane	[19:07:11] euouae: What happens if you replace sum with foldr1 (+) ? 
2021-07-20 10:40:41	hseg	[19:07:20] have tried just doing that, but it involves a lot of churn
2021-07-20 10:40:41	hseg	[19:07:26] is there a more mtl'y way of writing this that can help avoid this churn
2021-07-20 10:40:41	hseg	[19:07:28] ?
2021-07-20 10:40:41	Hecate	[19:08:18] euouae: until you're on the version of GHC that has sum strict without optimisations, please enable them when you do stuff like that, otherwise space leaks will knock at your door
2021-07-20 10:40:41	geekosaur	[19:09:10] well, you also have to be on a version of ghc which allows optiimization in ghci
2021-07-20 10:40:41	euouae	[19:09:11] Okay so 8.6.5 is old 
2021-07-20 10:40:41	euouae	[19:09:45] Rembane got same thing much later 
2021-07-20 10:40:41	Rembane	[19:10:05] euouae: Got it! 
2021-07-20 10:40:41	euouae	[19:10:09] Ok I guess I have to enable optimizations 
2021-07-20 10:40:41	euouae	[19:10:13] Got what ?
2021-07-20 10:40:41	davean	[19:10:23] foldr' (+) 0 instead of sum sohuld fix it also
2021-07-20 10:40:41	davean	[19:11:22] (That doesn't require optimizations)
2021-07-20 10:40:41	maerwald	[19:11:36] anyone good with libarchive? Do you have a guarantee that when reading list of archive entries that the first entry is the root folder (if any)?
2021-07-20 10:40:41	davean	[19:12:31] maerwald: I certainly can make a tar that thats not true of.
2021-07-20 10:40:41	maerwald	[19:12:54] yeah... I want to strip the root folder, but libarchive API doesn't have that
2021-07-20 10:40:41	davean	[19:12:59] libarchive would have to pre-read the entire tar to avoid it, at best
2021-07-20 10:40:41	geekosaur	[19:13:27] and there are versions of tar that re-output a folder after its contents to allow the other end to more easily set mtime etc.
2021-07-20 10:40:41	maerwald	[19:14:17] the alternative is to unpack as-is, make sure you're on the same device and then do an atomic move operation, stripping the root folder away
2021-07-20 10:40:41	euouae	[19:14:24] Davean also gives me stack overflow 
2021-07-20 10:40:41	maerwald	[19:14:27] but on windows, any file operation is doomed to have locking issues
2021-07-20 10:40:41	euouae	[19:14:46] You might be able to hack libarchive 
2021-07-20 10:40:41	maerwald	[19:14:51] no time
2021-07-20 10:40:41	davean	[19:16:30] maerwald: Conceptually you'd have to do 2 passes over a tar for that, at best
2021-07-20 10:40:41	maerwald	[19:16:51] I think the idea would be to lazily read all entries... fmap over them and strip the root dir, lazily create a new tar archive from the entries and then lazily unpack it
2021-07-20 10:40:41	davean	[19:17:05] why create a new tar archive?
2021-07-20 10:40:41	euouae	[19:17:07] Man pages are outdated 
2021-07-20 10:40:41	davean	[19:17:11] why not just process them as you unpack?
2021-07-20 10:40:41	euouae	[19:17:14] Maybe read the source code 
2021-07-20 10:40:41	maerwald	[19:17:16] davean: there's no function to unpack from entries
2021-07-20 10:40:41	h98	[19:17:44] euouae did you try foldr (\x y -> (f x) + y) 0 [T x y z ....]?
2021-07-20 10:40:41	euouae	[19:18:46] Maerwald: seems related https://github.com/libarchive/libarchive/wiki/WishList#seek-in-archives
2021-07-20 10:40:41	euouae	[19:19:05] H98 would thy be better?
2021-07-20 10:40:41	maerwald	[19:19:23] euouae: the haskell bindings might not be exhaustive
2021-07-20 10:40:41	euouae	[19:19:53] Yeah you’d have to make that but even then I’m painting to the fact that it’s on a wishlist maereald 
2021-07-20 10:40:41	maerwald	[19:20:11] I'd have to write my own version of `toDisk :: Entry FilePath ByteString -> IO ()`
2021-07-20 10:40:41	maerwald	[19:20:19] which sounds trivial, but isn't
2021-07-20 10:40:41	euouae	[19:20:39] Go for a solution that isn’t efficient but works?
2021-07-20 10:40:41	maerwald	[19:20:46] hardlinks, softlinks, preserving file properties
2021-07-20 10:40:41	euouae	[19:21:34] H98 also gives stack overflow 
2021-07-20 10:40:41	euouae	[19:27:21] So the issue is ghci being silly right 
2021-07-20 10:40:41	h98	[19:29:49] yeah I think so
2021-07-20 10:40:41	h98	[19:29:52] I tried this: https://paste.tomsmeding.com/QVCoWxOz
2021-07-20 10:40:41	h98	[19:30:14] if I compile and run it i get 6467616768 after a few seconds
2021-07-20 10:40:41	h98	[19:30:26] if I call test in ghci I get a stack overflow
2021-07-20 10:40:41	h98	[19:30:30] version 8.10.4
2021-07-20 10:40:41	euouae	[19:32:16] Thank you !
2021-07-20 10:40:41	euouae	[19:32:27] Did you have to enable optimizations ?
2021-07-20 10:40:41	h98	[19:33:13] I have no idea how, so I don't think so
2021-07-20 10:40:41	euouae	[19:34:14] Thanks 
2021-07-20 10:40:41	geekosaur	[19:34:22] ghci can't do optimizations except in very recent versions
2021-07-20 10:40:41	h98	[19:38:00] oh but foldl' works
2021-07-20 10:40:41	h98	[19:38:38] https://paste.tomsmeding.com/dLbV73r1 same thing, but no overflow in ghci
2021-07-20 10:40:41	h98	[19:39:35] RWH p. 97 talks about this
2021-07-20 10:40:41	dsal	[19:42:52] why is `sum` bad?  Is this one of those things where fixing it breaks something probably nobody cares about?
2021-07-20 10:40:41	monochrom	[19:46:08] I compiled with -O, no stack overflow, in fact immediate answer.
2021-07-20 10:40:41	monochrom	[19:46:47] main = print (let xs = [1..256] in sum [ x+y+z | x <- xs, y <- xs, z <- xs ])
2021-07-20 10:40:41	geekosaur	[19:46:58] dsal, there was a whole discussion on -cafe about various things using foldl instead of foldl'
2021-07-20 10:40:41	geekosaur	[19:47:15] and thereby being prone to stack overflows
2021-07-20 10:40:41	geekosaur	[19:47:28] sum being the prime example
2021-07-20 10:40:41	_73	[19:47:35] what is the right abstraction to avoid explicit recursion on a function using a monadic action. I tried to write it as a foldr but wasn't able to succeed. Here is my code that does use explicit recursion: http://dpaste.com/2SKMBLTA8
2021-07-20 10:40:41	dsal	[19:48:32] :t foldM
2021-07-20 10:40:41	lambdabot	[19:48:33] (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m b
2021-07-20 10:40:41	geekosaur	[19:48:48] I think it comes down to nobody thought about it and the original Prelude was written for comprehensibility by newcomers rather than performance
2021-07-20 10:40:41	dsal	[19:49:05] @src sum
2021-07-20 10:40:41	lambdabot	[19:49:06] sum = foldl (+) 0
2021-07-20 10:40:41	monochrom	[19:49:22] Oh don't worry about @src, it's independently handwritten.
2021-07-20 10:40:41	monochrom	[19:49:28] Hell, s/worry/trust/
2021-07-20 10:40:41	dsal	[19:49:39] Yeah.  I just tend to assume it's a simplification for understanding.
2021-07-20 10:40:41	monochrom	[19:50:10] Yeah, great educational tool.
2021-07-20 10:40:41	geekosaur	[19:50:44] and @src is mostly lifted from the Report, and is similarly intended for reading rather than running
2021-07-20 10:40:41	_73	[19:52:55] I got it work with foldM thanks
2021-07-20 10:40:41	euouae	[20:00:53] Heh I got “killed” after I run ghc 
2021-07-20 10:40:41	euouae	[20:01:14] What does that mean ?
2021-07-20 10:40:41	geekosaur	[20:01:29] the OOM killer got you
2021-07-20 10:40:41	geekosaur	[20:01:57] i.e. the Linux kernel decided your process was eating too much memory and nuked it
2021-07-20 10:40:41	geekosaur	[20:03:39] (or similar for OS X, etc.; only Windows will differ but it has its own way of dealing with that)
2021-07-20 10:40:41	euouae	[20:04:39] Hmm alright the oom reaper 
2021-07-20 10:40:41	ddb	[20:16:07] geekosaur: is that discussion about things using foldl instead of foldl' logged or archived anywhere?
2021-07-20 10:40:41	maerwald	[20:17:23] can you have extaustiveness check with NamedFieldPuns?
2021-07-20 10:40:41	maerwald	[20:18:25] let's say you have Foo = Foo { foo1 :: String, foo2 :: String, foo3 :: String } and you want to pattern match on it without relying on the order, but also make sure you don't miss something when a new record is added
2021-07-20 10:40:41	maerwald	[20:19:49] Relying on order is shitty when all the records are of the same type
2021-07-20 10:40:41	geekosaur	[20:22:19] ddb, somewhere on the haskell-cafe mailing list archives
2021-07-20 10:40:41	hseg	[21:01:02] feels like this can be expressed in standard terms, any ideas? http://ix.io/3tsp
2021-07-20 10:40:41	hseg	[21:02:17] idea is to sum a list, then if possible without changing the sign, replace the last element by its difference from the sum so it all sums to 0
2021-07-20 10:40:41	hseg	[21:02:46] (need to maintain signs, and the list is sorted by absolute value)
2021-07-20 10:40:41	dsal	[21:07:50] > let xs = init [1, 2, 3] in xs <> [0 - sum xs]   -- hseg like this?  I'm a bit confused by your specification.
2021-07-20 10:40:41	lambdabot	[21:07:51]  [1,2,-3]
2021-07-20 10:40:41	hseg	[21:08:49] spec is: (assuming output is Just): ((==) `on` compare 0) xs (fixSum xs), sum (fixSum xs) == 0
2021-07-20 10:40:41	hseg	[21:09:35] and I'm choosing to limit the cases i'm fixing to those (==) `on` init
2021-07-20 10:40:41	hseg	[21:10:37] hrm. your code is probably clearer -- just need to compose with a guard to make sure it satisfies spec
2021-07-20 10:40:41	hseg	[21:10:54] though if there were some way of avoiding the append, that would be nice
2021-07-20 10:40:41	EvanR	[21:13:59] you want to change the last element of a list?
2021-07-20 10:40:41	hseg	[21:14:03] y
2021-07-20 10:40:41	EvanR	[21:14:07] oof
2021-07-20 10:40:41	hseg	[21:14:53] could fix it so it's correct-by-construction, but that makes my generator code very ugly
2021-07-20 10:40:41	EvanR	[21:14:57] can you designate the first element the element that needs to be changed
2021-07-20 10:40:41	hseg	[21:15:28] nope -- sorted ascending by absolute value
2021-07-20 10:40:41	EvanR	[21:15:44] how about descending
2021-07-20 10:40:41	hseg	[21:15:58] and there's enough stuff depending on this already that I'd rather not push that redesign
2021-07-20 10:40:41	hseg	[21:16:46] should just take the l and continue -- probably not going to be significant enough to matter
2021-07-20 10:40:41	hseg	[21:16:51] (lists will be short)
2021-07-20 10:40:41	hseg	[21:17:09] at least it's O(n) vs O(1), not O(n) vs O(n^k)
2021-07-20 10:40:41	EvanR	[21:17:10] i like to split things up into steps rather than code golfing
2021-07-20 10:40:41	hseg	[21:17:30] ?
2021-07-20 10:40:41	hseg	[21:17:44] where are you seeing golfing in my code?
2021-07-20 10:40:41	EvanR	[21:17:49] or in this case, perhaps write a combinator that traverses a list and uses a function argument to decide how to modify the last element
2021-07-20 10:40:41	EvanR	[21:18:02] i only saw 1 line of code, so it seems like golf xD
2021-07-20 10:40:41	hseg	[21:18:10] :)
2021-07-20 10:40:41	hseg	[21:18:44] posted code earlier, but that could work
2021-07-20 10:40:41	hseg	[21:19:42] k, not bad enough to matter
2021-07-20 10:40:41	EvanR	[21:19:43] a combination fold and specialized list reconstructor. And scanl may already be that
2021-07-20 10:40:41	davean	[21:20:42] hseg: how does this handle the singleton list?
2021-07-20 10:40:41	hseg	[21:21:04] [0] -> Just [0], [x] -> Nothing
2021-07-20 10:40:41	EvanR	[21:21:31] oh failure, nvm
2021-07-20 10:40:41	davean	[21:21:41] Oh damn, thats ... ok
2021-07-20 10:40:41	EvanR	[21:22:26] if you're changing the last element wouldn't [x] |-> Just [0]
2021-07-20 10:40:41	davean	[21:22:36] EvanR: Thats why I asked!
2021-07-20 10:40:41	davean	[21:23:11] I had suspicions about the spec
2021-07-20 10:40:41	hseg	[21:23:13] no, because i need elementwise (==) `on` compare 0
2021-07-20 10:40:41	hseg	[21:23:37] which is more important to me than success fixing the sum
2021-07-20 10:40:41	EvanR	[21:24:30] less a spec and more a would be nice list xD
2021-07-20 10:40:41	davean	[21:24:44] Yah, I think you need to think about your actual problem space hseg 
2021-07-20 10:40:41	davean	[21:24:52] I suspect you haven't come to understanding of your actual goals
2021-07-20 10:40:41	hseg	[21:25:26] am writing a quickcheck generator. all I need is that it generate enough correct values quickly
2021-07-20 10:40:41	davean	[21:25:42] No, thats not what you need for good quickchecks
2021-07-20 10:40:41	davean	[21:25:54] Thats what you need for invalid quickchecks
2021-07-20 10:40:41	hseg	[21:26:09] because I also need a good shrink?
2021-07-20 10:40:41	hseg	[21:26:18] (need one regardless (: )
2021-07-20 10:40:41	davean	[21:26:19] No, shrink is secondary and never required
2021-07-20 10:40:41	davean	[21:26:41] Quickcheck generators have to cover the domain, or at least the preimage
2021-07-20 10:40:41	hseg	[21:26:54] basically all I'm using this for is for randomly sampling the domain
2021-07-20 10:40:41	davean	[21:27:11] But you've just described NOT sampling the domain
2021-07-20 10:40:41	davean	[21:27:28] you'd just described sampling a particular subdomain of the domain
2021-07-20 10:40:41	davean	[21:28:03] And even suggested it isn't the preimage
2021-07-20 10:40:41	davean	[21:28:07] (strongly)
2021-07-20 10:40:41	davean	[21:28:36] Making the quickcheck results close to meaingless
2021-07-20 10:40:41	hseg	[21:29:01] perhaps. am not using the full power of quickcheck, regardless
2021-07-20 10:40:41	davean	[21:29:11] This isn't about power, this is about validity
2021-07-20 10:40:41	hseg	[21:29:38] yes? so I know I will get false positives/negatives
2021-07-20 10:40:41	davean	[21:30:03] So whats the point of running this code at all? You know as much before it runs as after
2021-07-20 10:40:41	hseg	[21:30:08] as long as I'm still having recognizable true negatives, I'm not worried about it
2021-07-20 10:40:41	hseg	[21:31:02] I'm testing a hypothesis that an invariant I have in mind is fine enough to predict the value of a function
2021-07-20 10:40:41	hseg	[21:31:29] so as long as my samplings show it isn't, I don't care that I haven't sampled the entire space
2021-07-20 10:40:41	EvanR	[21:31:43] maybe this is a probabalistic application
2021-07-20 10:40:41	hseg	[21:31:53] not probabilistic. hypothesis testing
2021-07-20 10:40:41	EvanR	[21:32:08] counterexample finding?
2021-07-20 10:40:41	hseg	[21:32:16] exactly
2021-07-20 10:40:41	EvanR	[21:32:20] cool
2021-07-20 10:40:41	EvanR	[21:32:29] it only takes 1 xD
2021-07-20 10:40:41	hseg	[21:32:34] exactly
2021-07-20 10:40:41	hseg	[21:32:46] and unfortunately, I have >>>1
2021-07-20 10:40:41	hseg	[21:33:37] so I need to refine the invariant I'm using
2021-07-20 10:40:41	hseg	[21:33:52] not clear how, though
2021-07-20 10:40:41	hseg	[21:34:29] welp. that's what research is for, ig
2021-07-20 10:40:41	EvanR	[21:34:31] eventually you will not find any counterexamples
2021-07-20 10:40:41	hseg	[21:34:54] yeah. am hoping that by then, will have actual proof that my invariant works
2021-07-20 10:40:41	hseg	[21:36:12] especially considering this is trying to give a closed form for a recursive formula, have high hopes it is possible
2021-07-20 10:40:41	bpv	[21:59:00] How is it going?
2021-07-20 10:40:41	nova	[23:34:03] I am currently using arch with ghcup and cabal, but cabal takes SO long to install packages that it is simply not usable. I am about to try nixos or gentoo, and I was wondering if anyone here uses their respective package managers to manager haskell packages (pandoc, pandoc-citeproc [this takes forever to recompile pandoc], xmonad, xmobar, etc). If so, does one hold an edge over the other?
2021-07-20 10:40:41	nova	[23:37:24] I was using pacman, but I had to remove all of my haskell packages because it was even worse than ghcup (but at least it was fast)
2021-07-20 10:40:41	sclv	[23:39:30] we’re developers here mainly. compile times are what they are
2021-07-20 10:40:41	dsal	[23:41:16] nova: I'm a pretty big fan of nixos.  Nonetheless, first compilation can take a bit.
2021-07-20 10:40:41	davean	[23:41:29] You compile things once and you're done, meh?
2021-07-20 10:40:41	nova	[23:42:35] what about upgrades
2021-07-20 10:40:41	dsal	[23:43:12] Upgrades of what?
2021-07-20 10:40:41	yin[m]	[23:43:46] any way we can avoid having to add `Show a =>` to a bunch of type signatures when "No instance for (Show a) arising from a use of ..." just for a quick Debug.trace?
2021-07-20 10:40:41	dsal	[23:43:53] I do nix updates all the time because I like giving my computer busy work.  heh.  They're reversible, though.  If things go wrong, I can undo them.
2021-07-20 10:40:41	dsal	[23:44:17] yin[m]: You need some way to represent the values you're tracing.
2021-07-20 10:40:41	davean	[23:44:49] nova: uh, upgrades do the amount of work in the delta of the packages changed?
2021-07-20 10:40:41	nova	[23:45:22] does nix have to rebuild after downloading deltas?
2021-07-20 10:40:41	dsal	[23:45:44] nix can use binaries if they're available.  It'll build if they're not.
2021-07-20 10:40:41	davean	[23:45:45] If it doesn't have the builds cached
2021-07-20 10:40:41	yin[m]	[23:46:50] sure, and I know they are, but ghc complains that if what I'm trying to show is an a and the funcion I'm in doesn't have the Show constraint in it, i cant see it. are my only options to comment all the relevant type signatures or add the Show constraint everywhere? isn't there something like an unsafeShow?
2021-07-20 10:40:41	yin[m]	[23:47:19] i just want a quick print for debugging purposes
2021-07-20 10:40:41	yin[m]	[23:47:48] * sure, and I know they are, but ghc complains that if what I'm trying to show is an a and the funcion I'm in doesn't have the Show a => constraint in it, i cant see it. are my only options to comment all the relevant type signatures or add the Show constraint everywhere? isn't there something like an unsafeShow?
2021-07-20 10:40:41	geekosaur	[23:51:41] yin[m]: absent a Show constraint there may not even be code to do the Show
2021-07-20 10:40:41	geekosaur	[23:54:02] more correctly, without that constraint ghc doesn't know that the type involved has the code to do Show — and more to the point, doesn't have access to that code
2021-07-20 10:40:41	geekosaur	[23:54:20] (as ghc implements constraints)
2021-07-20 10:40:41	geekosaur	[23:56:52] a theoretical unsafeShow would still require some way to get access to the Show code for the type. in particular if it knows the type only at runtime, it would have to be passed in via a dictionary still
2021-07-20 10:40:41	davean	[23:59:31] geekosaur: how dirty should I be in answering how to do that?
2021-07-20 10:40:41	geekosaur	[00:03:38] oh brother
2021-07-20 10:40:41	amesgen[m]	[00:03:49] yin: you might be interested in `anythingToString`: https://hackage.haskell.org/package/recover-rtti-0.4.0.0/docs/Debug-RecoverRTTI.html
2021-07-20 10:40:41	davean	[00:04:03] geekosaur: ok, ok I won't break out my dirty tricks
2021-07-20 10:40:41	geekosaur	[00:04:23] I'm not surprised there's some kind of hack but I'm not sure handing out hacks is the best idea here
2021-07-20 10:40:41	davean	[00:04:38] Oh, its an actively bad idea
2021-07-20 10:40:41	zzz	[00:12:48] bow im curious
2021-07-20 10:40:41	zzz	[00:12:56] s/bow/now
2021-07-20 10:40:41	yin[m]	[00:13:07] inpromise I'll ignore it
2021-07-20 10:40:41	geekosaur	[00:13:26] there are some evil ways to manufacture dictionaries on the fly
2021-07-20 10:40:41	oso	[01:10:29] what's this arcane error i'm getting while trying to build and how can i fix it? i've tried a few things like explicitly  denoting types but can't get around it https://paste.tomsmeding.com/SIas3Dgn
2021-07-20 10:40:41	dsal	[01:11:13] You could use type applications.
2021-07-20 10:40:41	dsal	[01:11:15] Or ignore it.
2021-07-20 10:40:41	geekosaur	[01:12:03] and stop using -Werrorl or at least turn it off for defaulting
2021-07-20 10:40:41	geekosaur	[01:12:28] where it's kinda obnoxious because defaulting basically exists for this use case
2021-07-20 10:40:41	dsal	[01:12:51] Most of the time where I've had defaulting warnings, I've not cared.
2021-07-20 10:40:41	oso	[01:13:41] looking into defaulting, thanks
2021-07-20 10:40:41	geekosaur	[01:14:18] the problem is that there are cases where you pretty much can't specify the type
2021-07-20 10:40:41	geekosaur	[01:15:50] although here you could, you just have to annotate almost everything with a type
2021-07-20 10:40:41	oso	[01:16:10] i only had to annotate the 100 as a double, actually, that got rid of the warning
2021-07-20 10:40:41	oso	[01:18:08] thanks for pointing me in the right direction
2021-07-20 10:40:41	h98	[01:59:15] I love how GHC gets confused by numbers in instance resolution....is "1" a Word32 or a Ptr a -> Ptr b -> IO Word32? Who knows what he meant!
2021-07-20 10:40:41	Boarders	[03:51:19] does GHC have standalone kind signatures now?
2021-07-20 10:40:41	Boarders	[03:52:14] I can't seem to find it in the user guide so I must be looking in the wrong places
2021-07-20 10:40:41	justsomeguy	[04:05:38] In the book I'm reading, it says "Functional programming languages are all based on lambda calculus." Isn't this wrong? -- Lisp (non-scheme, older versions only), I think, was based on McCarthy's recursive function notation. I've also encountered some quotes about ALGOL 68 being described partly in lambda calculus, which leads me to ask -- what does it mean for a language to be based on lambda
2021-07-20 10:40:41	justsomeguy	[04:05:40] calculus in the first place?
2021-07-20 10:40:41	Boarders	[04:06:54] lisp was definitely based on the lambda calculus even if mccarthy made improvements to it as a programming language
2021-07-20 10:40:41	justsomeguy	[04:07:50] There's a quote in this article by McCarthy saying otherwise ... https://danielsz.github.io/blog/2019-08-05T21_14.html
2021-07-20 10:40:41	justsomeguy	[04:08:30] Or, err, a quote by McCarthy in this article by Danielsz.
2021-07-20 10:40:41	justsomeguy	[04:08:47] (Words are hard, sometimes.)
2021-07-20 10:40:41	Boarders	[04:09:16] everyone else involved in lisp seemed to think it was "based on" the lambda calculus so I wouldn't take what McCarthy's quote means too seriously
2021-07-20 10:40:41	Boarders	[04:09:33] especially for instance the writers of scheme
2021-07-20 10:40:41	Boarders	[04:10:05] who wrote a whole series of papers explaining how to encode various programming language construct in lambda calculus
2021-07-20 10:40:41	justsomeguy	[04:10:27] Hmm... ok.
2021-07-20 10:40:41	Boarders	[04:11:17] this is a relevant paper: https://dspace.mit.edu/handle/1721.1/6091
2021-07-20 10:40:41	justsomeguy	[04:12:05] I'm still not sure the calculus matters. If a PL was developed that is based on SKI combinator calculus, and had functional features (referential transparency, first-class functions) would you consider that a functional language?
2021-07-20 10:40:41	 *	justsomeguy [04:12:18] is checking out the paper now
2021-07-20 10:40:41	justsomeguy	[04:13:36] But I think I'm probably taking that quote from the book too literally.
2021-07-20 10:40:41	lechner	[04:14:06] which book?
2021-07-20 10:40:41	justsomeguy	[04:14:21] Haskell programming from first princpiles (haskellbook.com)
2021-07-20 10:40:41	justsomeguy	[04:15:21] I'm, uhh, currently over-analysing the first chapter as part of a strange procrastination ritual.
2021-07-20 10:40:41	lechner	[04:16:49] sometimes it's worthwhile to get your bearings right
2021-07-20 10:40:41	justsomeguy	[04:17:42] Well, at least I'm still learning new things from it.
2021-07-20 10:40:41	dsal	[04:31:36] It's a great book. Depends on what you need to get out of it, though.  I didn't care much about that particular bit of theory.
2021-07-20 10:40:41	justsomeguy	[04:45:07] I've been developing a love hate relationship with it. I like the order that it teaches things in, and also how it leaves a lot of breadcrumbs to explore further. On the other hand, I often wish it to be more explcit about what the learning objectives for each chapter are, and have better code examples of where a newly introduced abstraction will be useful. It's also just too long, and not
2021-07-20 10:40:41	justsomeguy	[04:45:09] structured well enough to keep track of things (section names aren't descriptive enough, no figure numbers).
2021-07-20 10:40:41	justsomeguy	[04:45:36] But part of that is also just me learning how to read a big book.
2021-07-20 10:40:41	 *	justsomeguy [04:46:48] hasn't attempted to read a large non-fiction book where he can't "keep it all in his head" at once before this.
2021-07-20 10:40:41	dsal	[05:09:27] Well, the lambda calculus thing is the first chapter, so like, I'm not sure how you got such a judgment.  :)
2021-07-20 10:40:41	dsal	[05:09:39] But it mostly just walks you through building a lot of the fundamentals.
2021-07-20 10:40:41	***	Playback Complete.
2021-07-20 10:40:47	--	irc: disconnected from server
2021-07-20 11:28:46	-->	amanr (~therojjha@20.204.87.0) has joined #haskell
2021-07-20 11:28:46	--	Topic for #haskell is "https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org | Paste code/errors: https://paste.tomsmeding.com | tunes.org-style logging should be coming soon | Logs: https://ircbrowse.tomsmeding.com/browse/lchaskell"
2021-07-20 11:28:46	--	Topic set by geekosaur (~geekosaur@xmonad/geekosaur) on Mon, 14 Jun 2021 05:16:14
2021-07-20 11:28:46	--	Channel #haskell: 699 nicks (1 op, 0 voices, 698 normals)
2021-07-20 11:28:46	***	Buffer Playback...
2021-07-20 11:28:46	dibblego	[10:29:55] you might be thinking of traverse_
2021-07-20 11:28:46	dminuoso	[10:29:58] Then we `sequence` this, which turns `[IO Int] -> IO [Int]`
2021-07-20 11:28:46	dminuoso	[10:32:32] Imagine this to be: sequence (x:xs) = (:) <$> x <*> sequence xs; sequence [] = pure []
2021-07-20 11:28:46	dminuoso	[10:32:58] dibblego: Ah yeah. I guess that was wrong of me.
2021-07-20 11:28:46	dminuoso	[10:33:06] While I was typing the definition, I realized my mistake.
2021-07-20 11:28:46	dminuoso	[10:33:44] % mySequence (x:xs) = (:) <$> x <*> mySequence xs; mySequence [] = pure []
2021-07-20 11:28:46	yahb	[10:33:44] dminuoso: 
2021-07-20 11:28:46	dminuoso	[10:33:46] % :t mySequence
2021-07-20 11:28:46	yahb	[10:33:46] dminuoso: Applicative f => [f a] -> f [a]
2021-07-20 11:28:46	dibblego	[10:33:52] I think sequence is more obvious in the way you are trying to explain it, like this:
2021-07-20 11:28:46	dminuoso	[10:33:53] % mySequence [Just 10, Just 20, Just 30]
2021-07-20 11:28:46	yahb	[10:33:53] dminuoso: Just [10,20,30]
2021-07-20 11:28:46	dibblego	[10:34:20] (::.) = liftA2 (:); lift0 = pure; sequence (x:xs) = x ::. sequence xs; sequence [] = lift0 []
2021-07-20 11:28:46	dibblego	[10:35:56] once liftA2 is understood conceptually, then (*>) is quite simply: const id with some liftA2-ness
2021-07-20 11:28:46	albet70	[11:18:46] so could we say traverse another version of fmap which it can do earlier exit?
2021-07-20 11:28:46	[exa]	[11:21:01] "another" may be a weak label for the myriad of extra stuff it can do :]
2021-07-20 11:28:46	dminuoso	[11:28:04] albet70: Mmm, not just that.
2021-07-20 11:28:46	dminuoso	[11:28:38] albet70: Say you have a Tree of values, say of type String. For each string you want to query some database, and replace the string with some value you read from the database, say something of type User.
2021-07-20 11:28:46	dminuoso	[11:29:00] then you can do: do { userTree <- traverse fetchUserFromString stringTree; ... }
2021-07-20 11:28:46	dminuoso	[11:29:46] albet70: The key thing to realize is that Applicative/Monad encode certain.. "effects". For `Maybe/Either e` the effect is that of an exception, for IO it's outside world interaction, for list it's non-determinism, etc..
2021-07-20 11:28:46	dminuoso	[11:30:00] So we map each element to an effectful computation, and then sequence them
2021-07-20 11:28:46	dminuoso	[11:30:38] Important bit to notice, is that traverse fundamentally does not change the "shape" of that structure. So if you traverse over a tree, the shape of it remains (so you cant drop or create nodes)
2021-07-20 11:28:46	dminuoso	[11:31:44] traverse on a list for example gives us a more generalized version of effectful loops. So a Python loop in which you do say database queries can be written with `traverse`
2021-07-20 11:28:46	dminuoso	[11:31:57] But `traverse` allows us to do even more, not just database queries
2021-07-20 11:28:46	dminuoso	[11:32:03] And it works on not just lists, but also trees.
2021-07-20 11:28:46	dibblego	[12:04:11] traverse is exactly fmap, if you use Identity in place of the general Applicative 
2021-07-20 11:28:46	dibblego	[12:04:32] but it also does other Applicative things, not just Identity
2021-07-20 11:28:46	hseg	[12:45:53] hi. have this generator http://ix.io/3tqe, and I would like to generalize it so its input generators can depend on each other's results (i.e. want to be able to pass [a -> Gen a])
2021-07-20 11:28:46	hseg	[12:46:15] have tried just doing that, but it involves a lot of churn
2021-07-20 11:28:46	hseg	[12:46:30] is there a more mtl'y way of writing this that can help avoid this churn
2021-07-20 11:28:46	hseg	[12:46:33] ?
2021-07-20 11:28:46	hseg	[12:48:03] presumably, I'd want to have inputs be sth like [n a] with MonadGen n and some constraint expressing that whatever effects n gives are liftable to m 
2021-07-20 11:28:46	hseg	[12:48:43] but that looks overly involved
2021-07-20 11:28:46	zangi	[12:58:35] probably a paradox, but does having IO means haskell is impure? :)
2021-07-20 11:28:46	Axman6	[12:58:42] no
2021-07-20 11:28:46	zangi	[12:59:30] does IO itself impure? what does it mean to be "pure" in haskell sense?
2021-07-20 11:28:46	Axman6	[12:59:49] IO is pure, the execution of it may not be. dibblego is excellent at explaining why 
2021-07-20 11:28:46	 *	Axman6 [12:59:59] handballs the conversation to dibblego
2021-07-20 11:28:46	DigitalKiwi	[13:00:15] what about unsafeCoerce
2021-07-20 11:28:46	zangi	[13:00:52] who's dibblego?
2021-07-20 11:28:46	DigitalKiwi	[13:01:13] why's dibblego
2021-07-20 11:28:46	Axman6	[13:01:43] HE authored much of the NICTA/Data61/System-F FP course, where we explain why IO is pure
2021-07-20 11:28:46	Axman6	[13:01:46] He*
2021-07-20 11:28:46	zangi	[13:02:18] does he have any article about this issue?
2021-07-20 11:28:46	DigitalKiwi	[13:02:20] ofc we all know the answer to how's dibblego (by plane)
2021-07-20 11:28:46	DigitalKiwi	[13:02:35] ba dum tsch
2021-07-20 11:28:46	DigitalKiwi	[13:03:14] https://github.com/system-f/fp-course
2021-07-20 11:28:46	DigitalKiwi	[13:03:41] https://www.youtube.com/watch?v=NzIZzvbplSM&list=PLly9WMAVMrayYo2c-1E_rIRwBXG_FbLBW
2021-07-20 11:28:46	zangi	[13:04:27] DigitalKiwi++
2021-07-20 11:28:46	zangi	[13:05:09] thanks, anyway does it mean IO in haskell is different to IO in other (imperative) languages?
2021-07-20 11:28:46	[exa]	[13:07:53] zangi: haskell is pure; the ugly impure execution of the IO action recipes written in haskell is only done by computers
2021-07-20 11:28:46	kuribas	[13:08:27] [exa]: but then any language is pure?
2021-07-20 11:28:46	[exa]	[13:09:12] nah, some languages rely on that impurity
2021-07-20 11:28:46	[exa]	[13:10:27] (and some certain others are just dirty)
2021-07-20 11:28:46	DigitalKiwi	[13:15:18] i like my coffee like i like my programming languages; strong, statically typed, purely functional with type inference and lazy evaluation.
2021-07-20 11:28:46	lechner	[13:18:13] Hi, how can I use MonadFail to handle exceptions from Codec.Compression.Lzma, please?
2021-07-20 11:28:46	Boarders	[13:34:58] is there a variant combinator in megaparsec that is like: do {t <- takeWhileP Nothing (/= '\n'); char '\n'; pure t}
2021-07-20 11:28:46	tdammers	[13:40:37] https://hackage.haskell.org/package/parser-combinators-1.3.0/docs/Control-Applicative-Combinators.html#v:manyTill maybe?
2021-07-20 11:28:46	dmj`	[13:41:19] lechner: did you try using `catch`
2021-07-20 11:28:46	Boarders	[13:44:40] manyTill is very related but not quite the same
2021-07-20 11:28:46	lechner	[13:45:32] dmj`:  i'm still reading, and working on my general Haskell learning curve
2021-07-20 11:28:46	lechner	[13:51:21] dmj`: but i do have working program (which i wrote) where I could try your suggestion. how do i use catch, please?    https://salsa.debian.org/lintian/kickoff/-/blob/master/Collect.hs#L82
2021-07-20 11:28:46	tzh	[14:06:39] hey so i'm working on a haskell game; does anybody have any suggestions for an input library that would work well? previously i've used reactive-banana, which worked well enough even if its FRP nature made it a little clunky for use in a highly-interactive program. i saw some people mention using arrowized FRP libraries likes Yampa/dunai but that seems more like something to use for physics integration than for things like 'how to click on 
2021-07-20 11:28:46	tzh	[14:06:40] a menu'
2021-07-20 11:28:46	kuribas	[14:14:12] tzh: reactive-banana isn't an input library, it's a FRP library.
2021-07-20 11:28:46	kuribas	[14:14:20] You can use it with any UI library.
2021-07-20 11:28:46	maerwald	[14:15:21] SDL2?
2021-07-20 11:28:46	[exa]	[14:15:37] tzh: immediate-mode GUIs (google imgui) are priceless for games, except I don't know if we have any for haskell yet
2021-07-20 11:28:46	tzh	[14:15:51] kuribas: okay yes it's not a raw input-catching library; i'm actually using glfw for that. what i'm looking for is an input _processing_ library, to impose some order onto my input flow so it's not a bunch of ad-hoc garbage
2021-07-20 11:28:46	kuribas	[14:16:18] tzh: reactive-banana should be fine.
2021-07-20 11:28:46	tzh	[14:21:02] the main issue with reactive-banana is that it gets pretty clunky since it only runs in IO and thus can never directly run actual buffer writes... (well, okay, there are ways but that becomes a mess of running all input-processing code inside a render monad, with an unknown timing to my render loop). which means i need to have its output actions queue render actions like buffer allocations/writes, and then outside of the event loop pull 
2021-07-20 11:28:46	tzh	[14:21:03] them out so they can actually be run, which seems a little clunky and counter to the FRP experience, but i don't really see how that could be avoided given how opengl rendering works. so really i'd just like for that experience to be a bit smoother
2021-07-20 11:28:46	dmj`	[15:18:00] lechner:  do { result <- try (evaluate (decompress bytes)) :: IO (Either SomeException ByteString); case result of { Left e -> print e; Right bytes -> print (length bytes) } }
2021-07-20 11:28:46	Las[m]	[15:22:29] Question about bound threads: Will unbound threads use an OS thread created by forkOS?
2021-07-20 11:28:46	monochrom	[15:26:24] Probably in an ideal world shouldn't matter but in practice the GHC implementers wouldn't troll themselves by doing that.
2021-07-20 11:28:46	monochrom	[15:28:14] In practice there is pure Haskell code that can hold up an OS thread uninterruptible. Now what can you do when the rightful owner of the OS thread needs it?
2021-07-20 11:28:46	c_wraith	[15:30:03] honestly, that's not a very important edge case, given that the same pure code that will hold a thread uninterruptably will also block garbage collection, and therefore the entire program via stop-the-world GC
2021-07-20 11:28:46	c_wraith	[15:31:12] If you write a loop that does that, you get what you deserve whether bound threads are involved or not.
2021-07-20 11:28:46	c_wraith	[15:31:51] (this is why mueval starts new processes, not just threads)
2021-07-20 11:28:46	jumper149	[15:43:28] The diagram here: https://wiki.haskell.org/Typeclassopedia
2021-07-20 11:28:46	jumper149	[15:43:49] It is missing the superclass `Alternative` of `MonadPlus` :(
2021-07-20 11:28:46	Boarders	[15:54:34] in haddock if I want to include an example that is too long then is the thing to put definitions in a codeblock or make the example multi-line or something else?
2021-07-20 11:28:46	sm	[15:55:56] Boarders: you can have
2021-07-20 11:28:46	sm	[15:55:57] @
2021-07-20 11:28:46	sm	[15:55:57] multi line example...
2021-07-20 11:28:46	sm	[15:55:57] @
2021-07-20 11:28:46	Boarders	[15:58:40] how do you indicate with that what it should evaluate to?
2021-07-20 11:28:46	sm	[15:59:45] (maybe that got truncated. @ delimiters.)
2021-07-20 11:28:46	sm	[16:00:15] Boarders: are you asking about doctests ? the doctest doc will tell
2021-07-20 11:28:46	sm	[16:02:34] https://github.com/sol/doctest#readme
2021-07-20 11:28:46	gentauro	[16:21:01] does anybody has the link to a tweet staging: «category theory is the mathematics of mathematics»?
2021-07-20 11:28:46	gentauro	[16:21:19] I think it was from a female cs prof (I recall)
2021-07-20 11:28:46	Boarders	[16:22:56] https://twitter.com/emilyriehl/status/979375728373518336?s=20
2021-07-20 11:28:46	lechner	[16:24:55] dmj`: it compiled, but did not stop the program from terminating. i got the same message as before:  "Codec.Compression.Lzma.decompressWith: decoding error LzmaRetOK"      https://dpaste.org/FGQs#L7,84,85,86,87
2021-07-20 11:28:46	c_wraith	[16:24:57] In that tweet she credits Eugenia Cheng, which is a name I've heard before.
2021-07-20 11:28:46	lechner	[16:31:13] just make sure you pronounce it right, please    http://eugeniacheng.com/pronunciation/
2021-07-20 11:28:46	dmj`	[16:41:23] lechner: I think the issue is that you're not forking a thread to handle new clients, so your server terminates immediately, since the main thread of execution exits.. You're just blocking on a socket receive until the client exits, then your process terminates. You need to fork threads for each client and ensure the main thread of execution is running indefinitely
2021-07-20 11:28:46	lechner	[16:43:30] dmj`: without a decoding error, this does run forever   https://dpaste.org/FGQs#L105
2021-07-20 11:28:46	lechner	[16:43:47] via iterateM_
2021-07-20 11:28:46	lechner	[16:45:07] it is in fact my motivation to catch the error
2021-07-20 11:28:46	gentauro	[16:52:23] 18:22 < Boarders> https://twitter.com/emilyriehl/status/979375728373518336
2021-07-20 11:28:46	gentauro	[16:52:29] Boarders: that's the one. Thx :)
2021-07-20 11:28:46	jumper149	[17:16:10] I want to choose a Haskell formatter. Are there any nice comparisons? Maybe a blog post?
2021-07-20 11:28:46	[exa]	[17:17:00] jumper149: probably best to ask yourself why you want the formatting at first
2021-07-20 11:28:46	dsal	[17:17:07] Haskell In Depth went over them slightly, but didn't offer an opinion.
2021-07-20 11:28:46	dsal	[17:17:32] IMO, ormolu is weird and wrong, but it's the new kid and at least some people like it.
2021-07-20 11:28:46	dminuoso	[17:17:33] I chose emacs as my formatter. I can press enter, and it formats the code nicely.
2021-07-20 11:28:46	dminuoso	[17:17:49] If it does it wrong, I can change the indentation with a single keypress.
2021-07-20 11:28:46	[exa]	[17:17:55] fourmolu is kinda less bad than ormolu
2021-07-20 11:28:46	 *	geekosaur [17:18:17] formats man8ually as no formatter matches his preference
2021-07-20 11:28:46	dsal	[17:18:30] I use stylish-haskell when I remember.  It usually does OK.
2021-07-20 11:28:46	jumper149	[17:18:41] I want formatting to be consistent over a project. And I would like something that makes sense with git.
2021-07-20 11:28:46	maerwald	[17:18:48] brittany got close to my needs, but it tends to pull apart code so much that stuff becomes overly verbose
2021-07-20 11:28:46	dsal	[17:18:55] I mainly like my imports tidy.
2021-07-20 11:28:46	dminuoso	[17:18:59] jumper149: A consistent style is already a bizarre thing.
2021-07-20 11:28:46	dsal	[17:19:02] jumper149: git just stores blobs, so that's not a big deal.  :)
2021-07-20 11:28:46	dminuoso	[17:19:11] jumper149: Code formatting communicates intent and structure, its highly contextual.
2021-07-20 11:28:46	maerwald	[17:19:39] dminuoso: yes, the consistency argument is mostly nonsense imo. The "I'm too lazy argument" I can get behind
2021-07-20 11:28:46	maerwald	[17:19:42] because I am
2021-07-20 11:28:46	dsal	[17:19:43] ormolu was inspired by elm's canonical format in a lot of way and they prioritized making it easy to read diffs generated by whatever tools they happened to use.  This is a terrible mistake, IMO.
2021-07-20 11:28:46	monochrom	[17:19:45] Perhaps "makes sense with git" means "makes sense with diff".
2021-07-20 11:28:46	dminuoso	[17:19:49] It's sort of the equivalent of saying "a paragraph must always have 3 sentences". It's a stupid proposition to begin with.
2021-07-20 11:28:46	jumper149	[17:20:01] monochrom: exactly!
2021-07-20 11:28:46	dminuoso	[17:20:21] Yes, if each paragraph has 3 sentences, you have a consistent formatting of your natural language. But it really hampers readability
2021-07-20 11:28:46	dsal	[17:20:25] Most of the time when I'm reading code, I'm not reading diffs.  I'd rather prioritize the code over the diffs.
2021-07-20 11:28:46	monochrom	[17:20:32] People keep XYing their diction all the time. Remember that one time when someone said "haddock" to mean doctest?
2021-07-20 11:28:46	maerwald	[17:21:49] dsal: in a lot of PRs I've seen at work there was no way to understand anything from the diff without a walkthrough by the author. Even looking at my own PRs I don't understand anything. In some companies the author writes a walkthrough in the diff comments, but even then: diffs lie
2021-07-20 11:28:46	maerwald	[17:22:16] you don't see the code you changed, only the lines you changed
2021-07-20 11:28:46	jumper149	[17:22:26] I particularly want a formatter for stuff like same style Haddocks (-- vs {- -}), sorted imports and extensions.
2021-07-20 11:28:46	dminuoso	[17:22:43] jumper149: For import/extensions sorting, I find stylish-haskell to be agreeable.
2021-07-20 11:28:46	dminuoso	[17:22:49] (It just breaks in the presence of QQs and TH)
2021-07-20 11:28:46	maerwald	[17:22:54] and CPP
2021-07-20 11:28:46	dminuoso	[17:23:16] jumper149: But note, you should chose your tool to fit *your* style.
2021-07-20 11:28:46	dsal	[17:23:16] maerwald: yeah.  I have that problem reading diffs sometimes.  Like, cool you changed x to y... but what was x and what's y?
2021-07-20 11:28:46	maerwald	[17:23:34] also: reverse dependencies of your code
2021-07-20 11:28:46	maerwald	[17:23:57] you might need to re-read the entire codebase from a different perspective
2021-07-20 11:28:46	maerwald	[17:24:21] while the scrum master is asking why the PR is still not merged
2021-07-20 11:28:46	maerwald	[17:24:56] but hey... not everyone works in security critical code: just push and hope for the best
2021-07-20 11:28:46	monochrom	[17:25:02] "the closer you look, the less you see"
2021-07-20 11:28:46	dminuoso	[17:25:30] monochrom: Yes, that was the mentality of openssl. Distance yourself from the code and embrace Heartbleed!
2021-07-20 11:28:46	dsal	[17:25:32] These modern "diff-friendly" things take something small, clear and readable and make me have to scroll to understand what's going on.  https://www.irccloud.com/pastebin/dhodxIZ7/ok.elm
2021-07-20 11:28:46	monochrom	[17:25:42] haha
2021-07-20 11:28:46	geekosaur	[17:26:11] I somewhat regularly have to click on the extend buttons in github to understand a diff
2021-07-20 11:28:46	geekosaur	[17:26:26] which is the simple version of this
2021-07-20 11:28:46	monochrom	[17:26:54] Clearly, the logical conclusion is one token per line. >:)
2021-07-20 11:28:46	dsal	[17:27:08] There are lots of cases where formatters seem to do that.
2021-07-20 11:28:46	maerwald	[17:27:12] There is a very grumpy C coder on my LinkedIn feed, always riling about security and code correctness. Then one day he wrote why: his bug actually killed people, because it was some control system about pressure valves.
2021-07-20 11:28:46	dsal	[17:27:16] With lines between them.
2021-07-20 11:28:46	dsal	[17:28:09] monochrom: Like, imagine how hard this would be to read if that 'o' shared a line with any of the other code:  https://www.irccloud.com/pastebin/lIpmTDCu/format.elm
2021-07-20 11:28:46	maerwald	[17:28:18] but I don't know what he thinks of code formatters
2021-07-20 11:28:46	maerwald	[17:28:39] then again: that's a solved issue in C anyway
2021-07-20 11:28:46	dsal	[17:29:15] I really like tools that do static analysis and stuff in my code to tell me when I could do things better.   That's an unreasonably hard problem to solve well, though.
2021-07-20 11:28:46	maerwald	[17:34:59] I think the main question is: do you align code or just do syntactical indenting
2021-07-20 11:28:46	euouae	[17:36:50] Hello
2021-07-20 11:28:46	euouae	[17:37:15] I want to create a lazy list whose nth element is a function of its predecessor 
2021-07-20 11:28:46	monochrom	[17:37:27] iterate
2021-07-20 11:28:46	euouae	[17:37:38] What do you mean 
2021-07-20 11:28:46	monochrom	[17:37:49] Look for that function name in the standard library.
2021-07-20 11:28:46	euouae	[17:39:21] Thank you !
2021-07-20 11:28:46	maerwald	[17:39:53] @hoogle iterate
2021-07-20 11:28:46	lambdabot	[17:39:53] Prelude iterate :: (a -> a) -> a -> [a]
2021-07-20 11:28:46	lambdabot	[17:39:54] Data.List iterate :: (a -> a) -> a -> [a]
2021-07-20 11:28:46	lambdabot	[17:39:54] Data.List.NonEmpty iterate :: (a -> a) -> a -> NonEmpty a
2021-07-20 11:28:46	maerwald	[17:40:27] @where hoogle
2021-07-20 11:28:46	lambdabot	[17:40:27] http://haskell.org/hoogle http://hoogle.haskell.org http://fpcomplete.com/hoogle – See also Hayoo, which searches more packages: http://hayoo.fh-wedel.de/
2021-07-20 11:28:46	maerwald	[17:40:40] hayoo is dead no?
2021-07-20 11:28:46	maerwald	[17:41:01] and the fpcomplete link too
2021-07-20 11:28:46	monochrom	[17:41:16] yikes
2021-07-20 11:28:46	geekosaur	[17:41:44] yeh, nobody's updated that
2021-07-20 11:28:46	euouae	[17:42:39] Has anyone tried Haskell on a supercomputer?
2021-07-20 11:28:46	geekosaur	[17:42:48] @where+ hoogle https://hoogle.haskell.org see also https://haskell.org/hoogle which searches a different default set of libraries
2021-07-20 11:28:46	lambdabot	[17:42:48] I will remember.
2021-07-20 11:28:46	geekosaur	[17:43:04] define supercomputer
2021-07-20 11:28:46	maerwald	[17:43:15] for me, both links are the same
2021-07-20 11:28:46	geekosaur	[17:43:33] interesting, maybe they made the old one go away
2021-07-20 11:28:46	maerwald	[17:43:34] haskell.org/hoogle redirects to hoogle.haskell.org
2021-07-20 11:28:46	euouae	[17:43:40] Hmm I’m trying to run a lot of computations and get an answer 
2021-07-20 11:28:46	euouae	[17:43:53] for now I have like 100 cores etc 
2021-07-20 11:28:46	geekosaur	[17:43:56] @where+ hoogle https://hoogle.haskell.org
2021-07-20 11:28:46	lambdabot	[17:43:56] Nice!
2021-07-20 11:28:46	dmj`	[17:44:49] Someone should write a library for parsing XML with GHC.Generics
2021-07-20 11:28:46	geekosaur	[17:45:46] iirc ghc's performance gets worse the more cores you have :( (but maybe this has improved, that was around 7.x)
2021-07-20 11:28:46	geekosaur	[17:46:06] mostly because of stop-the-world gc, though
2021-07-20 11:28:46	euouae	[17:46:51] Okay interesting 
2021-07-20 11:28:46	davean	[17:46:59] It gets harder to make it perform well with more cores, it doesn't inhernety not perform well.
2021-07-20 11:28:46	maerwald	[17:47:06] dmj`: why are you using xml :>
2021-07-20 11:28:46	davean	[17:47:08] But no super computing task is single process
2021-07-20 11:28:46	euouae	[17:47:21] Davean my knowledge is limited 
2021-07-20 11:28:46	davean	[17:47:22] I mean if you could fit it on one system it wouldn't really be using a modern supercomputer
2021-07-20 11:28:46	euouae	[17:47:50] I am not great at Haskell and never programmed for supercomputers before
2021-07-20 11:28:46	euouae	[17:49:49] But Haskell is really attractive for math 
2021-07-20 11:28:46	davean	[17:49:52] I think I've heard of some super computer Haskell use. I'd say everything to do with super computers is pretty definitionally specialized
2021-07-20 11:28:46	euouae	[17:50:17] Yeah basically you need to be very knowledgeable in the domain davean 
2021-07-20 11:28:46	euouae	[17:50:25] And I’m just trying to get by 
2021-07-20 11:28:46	maerwald	[17:50:30] is this about bitcoin mining?
2021-07-20 11:28:46	davean	[17:50:33] The domain, but also that specific computer
2021-07-20 11:28:46	davean	[17:50:38] maerwald: I sure hope not!
2021-07-20 11:28:46	euouae	[17:50:46] No lol it’s research 
2021-07-20 11:28:46	dmj`	[17:50:50] maerwald: AWS S3 still uses XML, https://docs.aws.amazon.com/AmazonS3/latest/API/API_ListObjectsV2.html
2021-07-20 11:28:46	euouae	[17:51:17] Bitcoin stuff is so scummy o want nothing with. It
2021-07-20 11:28:46	davean	[17:52:26] maerwald: Many code bugs kill a large number of fractional people
2021-07-20 11:28:46	euouae	[17:53:01] Davean I don’t understand how situational it could be though 
2021-07-20 11:28:46	euouae	[17:53:22] what I have is some pure math computations applied to many different numbers (say)
2021-07-20 11:28:46	davean	[17:53:54] euouae: The structure of the super computers differ, and the primary issue with super computers is communication
2021-07-20 11:28:46	davean	[17:54:03] You optimize communication, not compute
2021-07-20 11:28:46	euouae	[17:54:11] For now I’m on a single node 
2021-07-20 11:28:46	davean	[17:54:14] The network structures are all different for different optimalities
2021-07-20 11:28:46	davean	[17:54:26] Yes, and theres no modern single node super computers
2021-07-20 11:28:46	euouae	[17:54:54] It’s not necessarily a supercomputer since it’s single node but I’m starting from that 
2021-07-20 11:28:46	davean	[17:54:55] even on a single processor, you have to deal with inter-core communication issues, they're just less
2021-07-20 11:28:46	euouae	[17:55:07] Inter core? 
2021-07-20 11:28:46	euouae	[17:55:22] Are you talking about worker communication?
2021-07-20 11:28:46	euouae	[17:55:28] I’m not following 
2021-07-20 11:28:46	geekosaur	[17:57:54] things like shared memory access
2021-07-20 11:28:46	euouae	[17:58:13] Why is that important ?
2021-07-20 11:28:46	euouae	[17:58:29] I think in my problem no memory is shared 
2021-07-20 11:28:46	euouae	[17:58:54] It’s like map f xs but parallel 
2021-07-20 11:28:46	geekosaur	[17:59:09] if you're handling out subproblems to different threads/cores to be worked on, then there is at least some shared memory
2021-07-20 11:28:46	euouae	[17:59:12] More or less, maybe with a stop condition
2021-07-20 11:28:46	euouae	[17:59:36] Okay but this is the most basic form of it right?
2021-07-20 11:28:46	euouae	[18:04:02] Anyway those issues are part of the algorithm right?
2021-07-20 11:28:46	euouae	[18:04:14] Not some other aspect of the peoblrm
2021-07-20 11:28:46	euouae	[18:04:20] problem*
2021-07-20 11:28:46	davean	[18:04:54] I mean your algorithm isn't determined
2021-07-20 11:28:46	davean	[18:05:02] you design one to optimize for the HW
2021-07-20 11:28:46	geekosaur	[18:05:06] you'd best hope they are, but that would mean it's been specialized to your supercomputer
2021-07-20 11:28:46	davean	[18:05:51] what alg. is best depends on what your counting, and what the various costs are
2021-07-20 11:28:46	davean	[18:06:02] along with your expected problem parameters
2021-07-20 11:28:46	euouae	[18:06:45] So it’s really hard or are you just talking about the optimal case?
2021-07-20 11:28:46	monochrom	[18:07:14] I would think "really hard" and "the optimal case" go well together.
2021-07-20 11:28:46	davean	[18:07:55] Depends on the problem
2021-07-20 11:28:46	davean	[18:08:14] if you're scaling it up past a very small case though I'm talking about what it usually takes to do a servicable job at it
2021-07-20 11:28:46	euouae	[18:08:49] Davean are you speaking from experience with industry or research 
2021-07-20 11:28:46	euouae	[18:09:12] obviously any optimization means more profit in industry I imagine it’s really right
2021-07-20 11:28:46	davean	[18:09:15] yes, though my research wasn't particularly compute intensive even if it was "AI"
2021-07-20 11:28:46	euouae	[18:09:50] But in research there can be diminishing returns because your problem isn’t computationally feasible anyway after n=10 etc
2021-07-20 11:28:46	euouae	[18:10:22] Okay… hmmm. Is it possible for me to get into this at all or am I hopeless?
2021-07-20 11:28:46	davean	[18:10:36] euouae: I mean theres a huge difference between Floyd-Warshall and A*
2021-07-20 11:28:46	davean	[18:10:43] euouae: but they both sorta solve the same problem space
2021-07-20 11:28:46	geekosaur	[18:10:44] nobody here can tell that as we don't know your problem
2021-07-20 11:28:46	euouae	[18:10:59] I don’t know those davean
2021-07-20 11:28:46	euouae	[18:11:55] Okay maybe I’ll ask again if I have something more to show 
2021-07-20 11:28:46	davean	[18:11:56] ANd oh no, Floyd-Warshall is O(|V|^3), and A* is only O(|E|)! Clearly A* is always better? Except not at all
2021-07-20 11:28:46	euouae	[18:12:45] Big constants davean?
2021-07-20 11:28:46	davean	[18:12:45] well |E| can be ~ |V|^2, and what if you want the best paths, not approximations, but you're metric isn't admissible? And you want it for all of them? Or even just one side of those?
2021-07-20 11:28:46	davean	[18:12:51] euouae: no, nothing to do with constants
2021-07-20 11:28:46	davean	[18:13:41] Algrithmicly Floyd-Warshall is the same complexity for some use cases, because while they solve the same-ish problems, they do it for different uses
2021-07-20 11:28:46	davean	[18:13:57] if you do something |V|^2 |V times, thats |V|^3
2021-07-20 11:28:46	davean	[18:14:17] But Floyd-Warshall requires more communication
2021-07-20 11:28:46	davean	[18:14:27] A* is the "embarasingly" paralleler case
2021-07-20 11:28:46	davean	[18:14:53] so if you're CPUs are very seperated, maybe you want to work more like that again, except not you can go back and plan the communication of F-W ...
2021-07-20 11:28:46	euouae	[18:16:14] Oh man I’m not following 
2021-07-20 11:28:46	euouae	[19:04:02] Hello why am I getting a stack overflow for this? sum $ map f [T x y z | x<-xs, y<-xs, z<-xs ] where xs has 256 elements 
2021-07-20 11:28:46	euouae	[19:04:22] and f calculates the area of the triangle with vertices x y and z
2021-07-20 11:28:46	Hecate	[19:04:25] euouae: stack or heap? 
2021-07-20 11:28:46	euouae	[19:04:34] Says stack on Gucci 
2021-07-20 11:28:46	euouae	[19:04:36] Ghci 
2021-07-20 11:28:46	davean	[19:05:44] 256^3?
2021-07-20 11:28:46	h98	[19:05:47] 256^3 = 16,777,216
2021-07-20 11:28:46	euouae	[19:05:57] I was hoping that it wouldn’t have to expand a 256^3 list before summing 
2021-07-20 11:28:46	geekosaur	[19:06:03] is this sum being foldl again?
2021-07-20 11:28:46	euouae	[19:06:23] Are you asking me?
2021-07-20 11:28:46	geekosaur	[19:06:30] no
2021-07-20 11:28:46	hseg	[19:07:00] hi. have this generator http://ix.io/3tqe, and I would like to generalize it so its input generators can depend on each other's results (i.e. want to be able to pass [a -> Gen a])
2021-07-20 11:28:46	Rembane	[19:07:11] euouae: What happens if you replace sum with foldr1 (+) ? 
2021-07-20 11:28:46	hseg	[19:07:20] have tried just doing that, but it involves a lot of churn
2021-07-20 11:28:46	hseg	[19:07:26] is there a more mtl'y way of writing this that can help avoid this churn
2021-07-20 11:28:46	hseg	[19:07:28] ?
2021-07-20 11:28:46	Hecate	[19:08:18] euouae: until you're on the version of GHC that has sum strict without optimisations, please enable them when you do stuff like that, otherwise space leaks will knock at your door
2021-07-20 11:28:46	geekosaur	[19:09:10] well, you also have to be on a version of ghc which allows optiimization in ghci
2021-07-20 11:28:46	euouae	[19:09:11] Okay so 8.6.5 is old 
2021-07-20 11:28:46	euouae	[19:09:45] Rembane got same thing much later 
2021-07-20 11:28:46	Rembane	[19:10:05] euouae: Got it! 
2021-07-20 11:28:46	euouae	[19:10:09] Ok I guess I have to enable optimizations 
2021-07-20 11:28:46	euouae	[19:10:13] Got what ?
2021-07-20 11:28:46	davean	[19:10:23] foldr' (+) 0 instead of sum sohuld fix it also
2021-07-20 11:28:46	davean	[19:11:22] (That doesn't require optimizations)
2021-07-20 11:28:46	maerwald	[19:11:36] anyone good with libarchive? Do you have a guarantee that when reading list of archive entries that the first entry is the root folder (if any)?
2021-07-20 11:28:46	davean	[19:12:31] maerwald: I certainly can make a tar that thats not true of.
2021-07-20 11:28:46	maerwald	[19:12:54] yeah... I want to strip the root folder, but libarchive API doesn't have that
2021-07-20 11:28:46	davean	[19:12:59] libarchive would have to pre-read the entire tar to avoid it, at best
2021-07-20 11:28:46	geekosaur	[19:13:27] and there are versions of tar that re-output a folder after its contents to allow the other end to more easily set mtime etc.
2021-07-20 11:28:46	maerwald	[19:14:17] the alternative is to unpack as-is, make sure you're on the same device and then do an atomic move operation, stripping the root folder away
2021-07-20 11:28:46	euouae	[19:14:24] Davean also gives me stack overflow 
2021-07-20 11:28:46	maerwald	[19:14:27] but on windows, any file operation is doomed to have locking issues
2021-07-20 11:28:46	euouae	[19:14:46] You might be able to hack libarchive 
2021-07-20 11:28:46	maerwald	[19:14:51] no time
2021-07-20 11:28:46	davean	[19:16:30] maerwald: Conceptually you'd have to do 2 passes over a tar for that, at best
2021-07-20 11:28:46	maerwald	[19:16:51] I think the idea would be to lazily read all entries... fmap over them and strip the root dir, lazily create a new tar archive from the entries and then lazily unpack it
2021-07-20 11:28:46	davean	[19:17:05] why create a new tar archive?
2021-07-20 11:28:46	euouae	[19:17:07] Man pages are outdated 
2021-07-20 11:28:46	davean	[19:17:11] why not just process them as you unpack?
2021-07-20 11:28:46	euouae	[19:17:14] Maybe read the source code 
2021-07-20 11:28:46	maerwald	[19:17:16] davean: there's no function to unpack from entries
2021-07-20 11:28:46	h98	[19:17:44] euouae did you try foldr (\x y -> (f x) + y) 0 [T x y z ....]?
2021-07-20 11:28:46	euouae	[19:18:46] Maerwald: seems related https://github.com/libarchive/libarchive/wiki/WishList#seek-in-archives
2021-07-20 11:28:46	euouae	[19:19:05] H98 would thy be better?
2021-07-20 11:28:46	maerwald	[19:19:23] euouae: the haskell bindings might not be exhaustive
2021-07-20 11:28:46	euouae	[19:19:53] Yeah you’d have to make that but even then I’m painting to the fact that it’s on a wishlist maereald 
2021-07-20 11:28:46	maerwald	[19:20:11] I'd have to write my own version of `toDisk :: Entry FilePath ByteString -> IO ()`
2021-07-20 11:28:46	maerwald	[19:20:19] which sounds trivial, but isn't
2021-07-20 11:28:46	euouae	[19:20:39] Go for a solution that isn’t efficient but works?
2021-07-20 11:28:46	maerwald	[19:20:46] hardlinks, softlinks, preserving file properties
2021-07-20 11:28:46	euouae	[19:21:34] H98 also gives stack overflow 
2021-07-20 11:28:46	euouae	[19:27:21] So the issue is ghci being silly right 
2021-07-20 11:28:46	h98	[19:29:49] yeah I think so
2021-07-20 11:28:46	h98	[19:29:52] I tried this: https://paste.tomsmeding.com/QVCoWxOz
2021-07-20 11:28:46	h98	[19:30:14] if I compile and run it i get 6467616768 after a few seconds
2021-07-20 11:28:46	h98	[19:30:26] if I call test in ghci I get a stack overflow
2021-07-20 11:28:46	h98	[19:30:30] version 8.10.4
2021-07-20 11:28:46	euouae	[19:32:16] Thank you !
2021-07-20 11:28:46	euouae	[19:32:27] Did you have to enable optimizations ?
2021-07-20 11:28:46	h98	[19:33:13] I have no idea how, so I don't think so
2021-07-20 11:28:46	euouae	[19:34:14] Thanks 
2021-07-20 11:28:46	geekosaur	[19:34:22] ghci can't do optimizations except in very recent versions
2021-07-20 11:28:46	h98	[19:38:00] oh but foldl' works
2021-07-20 11:28:46	h98	[19:38:38] https://paste.tomsmeding.com/dLbV73r1 same thing, but no overflow in ghci
2021-07-20 11:28:46	h98	[19:39:35] RWH p. 97 talks about this
2021-07-20 11:28:46	dsal	[19:42:52] why is `sum` bad?  Is this one of those things where fixing it breaks something probably nobody cares about?
2021-07-20 11:28:46	monochrom	[19:46:08] I compiled with -O, no stack overflow, in fact immediate answer.
2021-07-20 11:28:46	monochrom	[19:46:47] main = print (let xs = [1..256] in sum [ x+y+z | x <- xs, y <- xs, z <- xs ])
2021-07-20 11:28:46	geekosaur	[19:46:58] dsal, there was a whole discussion on -cafe about various things using foldl instead of foldl'
2021-07-20 11:28:46	geekosaur	[19:47:15] and thereby being prone to stack overflows
2021-07-20 11:28:46	geekosaur	[19:47:28] sum being the prime example
2021-07-20 11:28:46	_73	[19:47:35] what is the right abstraction to avoid explicit recursion on a function using a monadic action. I tried to write it as a foldr but wasn't able to succeed. Here is my code that does use explicit recursion: http://dpaste.com/2SKMBLTA8
2021-07-20 11:28:46	dsal	[19:48:32] :t foldM
2021-07-20 11:28:46	lambdabot	[19:48:33] (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m b
2021-07-20 11:28:46	geekosaur	[19:48:48] I think it comes down to nobody thought about it and the original Prelude was written for comprehensibility by newcomers rather than performance
2021-07-20 11:28:46	dsal	[19:49:05] @src sum
2021-07-20 11:28:46	lambdabot	[19:49:06] sum = foldl (+) 0
2021-07-20 11:28:46	monochrom	[19:49:22] Oh don't worry about @src, it's independently handwritten.
2021-07-20 11:28:46	monochrom	[19:49:28] Hell, s/worry/trust/
2021-07-20 11:28:46	dsal	[19:49:39] Yeah.  I just tend to assume it's a simplification for understanding.
2021-07-20 11:28:46	monochrom	[19:50:10] Yeah, great educational tool.
2021-07-20 11:28:46	geekosaur	[19:50:44] and @src is mostly lifted from the Report, and is similarly intended for reading rather than running
2021-07-20 11:28:46	_73	[19:52:55] I got it work with foldM thanks
2021-07-20 11:28:46	euouae	[20:00:53] Heh I got “killed” after I run ghc 
2021-07-20 11:28:46	euouae	[20:01:14] What does that mean ?
2021-07-20 11:28:46	geekosaur	[20:01:29] the OOM killer got you
2021-07-20 11:28:46	geekosaur	[20:01:57] i.e. the Linux kernel decided your process was eating too much memory and nuked it
2021-07-20 11:28:46	geekosaur	[20:03:39] (or similar for OS X, etc.; only Windows will differ but it has its own way of dealing with that)
2021-07-20 11:28:46	euouae	[20:04:39] Hmm alright the oom reaper 
2021-07-20 11:28:46	ddb	[20:16:07] geekosaur: is that discussion about things using foldl instead of foldl' logged or archived anywhere?
2021-07-20 11:28:46	maerwald	[20:17:23] can you have extaustiveness check with NamedFieldPuns?
2021-07-20 11:28:46	maerwald	[20:18:25] let's say you have Foo = Foo { foo1 :: String, foo2 :: String, foo3 :: String } and you want to pattern match on it without relying on the order, but also make sure you don't miss something when a new record is added
2021-07-20 11:28:46	maerwald	[20:19:49] Relying on order is shitty when all the records are of the same type
2021-07-20 11:28:46	geekosaur	[20:22:19] ddb, somewhere on the haskell-cafe mailing list archives
2021-07-20 11:28:46	hseg	[21:01:02] feels like this can be expressed in standard terms, any ideas? http://ix.io/3tsp
2021-07-20 11:28:46	hseg	[21:02:17] idea is to sum a list, then if possible without changing the sign, replace the last element by its difference from the sum so it all sums to 0
2021-07-20 11:28:46	hseg	[21:02:46] (need to maintain signs, and the list is sorted by absolute value)
2021-07-20 11:28:46	dsal	[21:07:50] > let xs = init [1, 2, 3] in xs <> [0 - sum xs]   -- hseg like this?  I'm a bit confused by your specification.
2021-07-20 11:28:46	lambdabot	[21:07:51]  [1,2,-3]
2021-07-20 11:28:46	hseg	[21:08:49] spec is: (assuming output is Just): ((==) `on` compare 0) xs (fixSum xs), sum (fixSum xs) == 0
2021-07-20 11:28:46	hseg	[21:09:35] and I'm choosing to limit the cases i'm fixing to those (==) `on` init
2021-07-20 11:28:46	hseg	[21:10:37] hrm. your code is probably clearer -- just need to compose with a guard to make sure it satisfies spec
2021-07-20 11:28:46	hseg	[21:10:54] though if there were some way of avoiding the append, that would be nice
2021-07-20 11:28:46	EvanR	[21:13:59] you want to change the last element of a list?
2021-07-20 11:28:46	hseg	[21:14:03] y
2021-07-20 11:28:46	EvanR	[21:14:07] oof
2021-07-20 11:28:46	hseg	[21:14:53] could fix it so it's correct-by-construction, but that makes my generator code very ugly
2021-07-20 11:28:46	EvanR	[21:14:57] can you designate the first element the element that needs to be changed
2021-07-20 11:28:46	hseg	[21:15:28] nope -- sorted ascending by absolute value
2021-07-20 11:28:46	EvanR	[21:15:44] how about descending
2021-07-20 11:28:46	hseg	[21:15:58] and there's enough stuff depending on this already that I'd rather not push that redesign
2021-07-20 11:28:46	hseg	[21:16:46] should just take the l and continue -- probably not going to be significant enough to matter
2021-07-20 11:28:46	hseg	[21:16:51] (lists will be short)
2021-07-20 11:28:46	hseg	[21:17:09] at least it's O(n) vs O(1), not O(n) vs O(n^k)
2021-07-20 11:28:46	EvanR	[21:17:10] i like to split things up into steps rather than code golfing
2021-07-20 11:28:46	hseg	[21:17:30] ?
2021-07-20 11:28:46	hseg	[21:17:44] where are you seeing golfing in my code?
2021-07-20 11:28:46	EvanR	[21:17:49] or in this case, perhaps write a combinator that traverses a list and uses a function argument to decide how to modify the last element
2021-07-20 11:28:46	EvanR	[21:18:02] i only saw 1 line of code, so it seems like golf xD
2021-07-20 11:28:46	hseg	[21:18:10] :)
2021-07-20 11:28:46	hseg	[21:18:44] posted code earlier, but that could work
2021-07-20 11:28:46	hseg	[21:19:42] k, not bad enough to matter
2021-07-20 11:28:46	EvanR	[21:19:43] a combination fold and specialized list reconstructor. And scanl may already be that
2021-07-20 11:28:46	davean	[21:20:42] hseg: how does this handle the singleton list?
2021-07-20 11:28:46	hseg	[21:21:04] [0] -> Just [0], [x] -> Nothing
2021-07-20 11:28:46	EvanR	[21:21:31] oh failure, nvm
2021-07-20 11:28:46	davean	[21:21:41] Oh damn, thats ... ok
2021-07-20 11:28:46	EvanR	[21:22:26] if you're changing the last element wouldn't [x] |-> Just [0]
2021-07-20 11:28:46	davean	[21:22:36] EvanR: Thats why I asked!
2021-07-20 11:28:46	davean	[21:23:11] I had suspicions about the spec
2021-07-20 11:28:46	hseg	[21:23:13] no, because i need elementwise (==) `on` compare 0
2021-07-20 11:28:46	hseg	[21:23:37] which is more important to me than success fixing the sum
2021-07-20 11:28:46	EvanR	[21:24:30] less a spec and more a would be nice list xD
2021-07-20 11:28:46	davean	[21:24:44] Yah, I think you need to think about your actual problem space hseg 
2021-07-20 11:28:46	davean	[21:24:52] I suspect you haven't come to understanding of your actual goals
2021-07-20 11:28:46	hseg	[21:25:26] am writing a quickcheck generator. all I need is that it generate enough correct values quickly
2021-07-20 11:28:46	davean	[21:25:42] No, thats not what you need for good quickchecks
2021-07-20 11:28:46	davean	[21:25:54] Thats what you need for invalid quickchecks
2021-07-20 11:28:46	hseg	[21:26:09] because I also need a good shrink?
2021-07-20 11:28:46	hseg	[21:26:18] (need one regardless (: )
2021-07-20 11:28:46	davean	[21:26:19] No, shrink is secondary and never required
2021-07-20 11:28:46	davean	[21:26:41] Quickcheck generators have to cover the domain, or at least the preimage
2021-07-20 11:28:46	hseg	[21:26:54] basically all I'm using this for is for randomly sampling the domain
2021-07-20 11:28:46	davean	[21:27:11] But you've just described NOT sampling the domain
2021-07-20 11:28:46	davean	[21:27:28] you'd just described sampling a particular subdomain of the domain
2021-07-20 11:28:46	davean	[21:28:03] And even suggested it isn't the preimage
2021-07-20 11:28:46	davean	[21:28:07] (strongly)
2021-07-20 11:28:46	davean	[21:28:36] Making the quickcheck results close to meaingless
2021-07-20 11:28:46	hseg	[21:29:01] perhaps. am not using the full power of quickcheck, regardless
2021-07-20 11:28:46	davean	[21:29:11] This isn't about power, this is about validity
2021-07-20 11:28:46	hseg	[21:29:38] yes? so I know I will get false positives/negatives
2021-07-20 11:28:46	davean	[21:30:03] So whats the point of running this code at all? You know as much before it runs as after
2021-07-20 11:28:46	hseg	[21:30:08] as long as I'm still having recognizable true negatives, I'm not worried about it
2021-07-20 11:28:46	hseg	[21:31:02] I'm testing a hypothesis that an invariant I have in mind is fine enough to predict the value of a function
2021-07-20 11:28:46	hseg	[21:31:29] so as long as my samplings show it isn't, I don't care that I haven't sampled the entire space
2021-07-20 11:28:46	EvanR	[21:31:43] maybe this is a probabalistic application
2021-07-20 11:28:46	hseg	[21:31:53] not probabilistic. hypothesis testing
2021-07-20 11:28:46	EvanR	[21:32:08] counterexample finding?
2021-07-20 11:28:46	hseg	[21:32:16] exactly
2021-07-20 11:28:46	EvanR	[21:32:20] cool
2021-07-20 11:28:46	EvanR	[21:32:29] it only takes 1 xD
2021-07-20 11:28:46	hseg	[21:32:34] exactly
2021-07-20 11:28:46	hseg	[21:32:46] and unfortunately, I have >>>1
2021-07-20 11:28:46	hseg	[21:33:37] so I need to refine the invariant I'm using
2021-07-20 11:28:46	hseg	[21:33:52] not clear how, though
2021-07-20 11:28:46	hseg	[21:34:29] welp. that's what research is for, ig
2021-07-20 11:28:46	EvanR	[21:34:31] eventually you will not find any counterexamples
2021-07-20 11:28:46	hseg	[21:34:54] yeah. am hoping that by then, will have actual proof that my invariant works
2021-07-20 11:28:46	hseg	[21:36:12] especially considering this is trying to give a closed form for a recursive formula, have high hopes it is possible
2021-07-20 11:28:46	bpv	[21:59:00] How is it going?
2021-07-20 11:28:46	nova	[23:34:03] I am currently using arch with ghcup and cabal, but cabal takes SO long to install packages that it is simply not usable. I am about to try nixos or gentoo, and I was wondering if anyone here uses their respective package managers to manager haskell packages (pandoc, pandoc-citeproc [this takes forever to recompile pandoc], xmonad, xmobar, etc). If so, does one hold an edge over the other?
2021-07-20 11:28:46	nova	[23:37:24] I was using pacman, but I had to remove all of my haskell packages because it was even worse than ghcup (but at least it was fast)
2021-07-20 11:28:46	sclv	[23:39:30] we’re developers here mainly. compile times are what they are
2021-07-20 11:28:46	dsal	[23:41:16] nova: I'm a pretty big fan of nixos.  Nonetheless, first compilation can take a bit.
2021-07-20 11:28:46	davean	[23:41:29] You compile things once and you're done, meh?
2021-07-20 11:28:46	nova	[23:42:35] what about upgrades
2021-07-20 11:28:46	dsal	[23:43:12] Upgrades of what?
2021-07-20 11:28:46	yin[m]	[23:43:46] any way we can avoid having to add `Show a =>` to a bunch of type signatures when "No instance for (Show a) arising from a use of ..." just for a quick Debug.trace?
2021-07-20 11:28:46	dsal	[23:43:53] I do nix updates all the time because I like giving my computer busy work.  heh.  They're reversible, though.  If things go wrong, I can undo them.
2021-07-20 11:28:46	dsal	[23:44:17] yin[m]: You need some way to represent the values you're tracing.
2021-07-20 11:28:46	davean	[23:44:49] nova: uh, upgrades do the amount of work in the delta of the packages changed?
2021-07-20 11:28:46	nova	[23:45:22] does nix have to rebuild after downloading deltas?
2021-07-20 11:28:46	dsal	[23:45:44] nix can use binaries if they're available.  It'll build if they're not.
2021-07-20 11:28:46	davean	[23:45:45] If it doesn't have the builds cached
2021-07-20 11:28:46	yin[m]	[23:46:50] sure, and I know they are, but ghc complains that if what I'm trying to show is an a and the funcion I'm in doesn't have the Show constraint in it, i cant see it. are my only options to comment all the relevant type signatures or add the Show constraint everywhere? isn't there something like an unsafeShow?
2021-07-20 11:28:46	yin[m]	[23:47:19] i just want a quick print for debugging purposes
2021-07-20 11:28:46	yin[m]	[23:47:48] * sure, and I know they are, but ghc complains that if what I'm trying to show is an a and the funcion I'm in doesn't have the Show a => constraint in it, i cant see it. are my only options to comment all the relevant type signatures or add the Show constraint everywhere? isn't there something like an unsafeShow?
2021-07-20 11:28:46	geekosaur	[23:51:41] yin[m]: absent a Show constraint there may not even be code to do the Show
2021-07-20 11:28:46	geekosaur	[23:54:02] more correctly, without that constraint ghc doesn't know that the type involved has the code to do Show — and more to the point, doesn't have access to that code
2021-07-20 11:28:46	geekosaur	[23:54:20] (as ghc implements constraints)
2021-07-20 11:28:46	geekosaur	[23:56:52] a theoretical unsafeShow would still require some way to get access to the Show code for the type. in particular if it knows the type only at runtime, it would have to be passed in via a dictionary still
2021-07-20 11:28:46	davean	[23:59:31] geekosaur: how dirty should I be in answering how to do that?
2021-07-20 11:28:46	geekosaur	[00:03:38] oh brother
2021-07-20 11:28:46	amesgen[m]	[00:03:49] yin: you might be interested in `anythingToString`: https://hackage.haskell.org/package/recover-rtti-0.4.0.0/docs/Debug-RecoverRTTI.html
2021-07-20 11:28:46	davean	[00:04:03] geekosaur: ok, ok I won't break out my dirty tricks
2021-07-20 11:28:46	geekosaur	[00:04:23] I'm not surprised there's some kind of hack but I'm not sure handing out hacks is the best idea here
2021-07-20 11:28:46	davean	[00:04:38] Oh, its an actively bad idea
2021-07-20 11:28:46	zzz	[00:12:48] bow im curious
2021-07-20 11:28:46	zzz	[00:12:56] s/bow/now
2021-07-20 11:28:46	yin[m]	[00:13:07] inpromise I'll ignore it
2021-07-20 11:28:46	geekosaur	[00:13:26] there are some evil ways to manufacture dictionaries on the fly
2021-07-20 11:28:46	oso	[01:10:29] what's this arcane error i'm getting while trying to build and how can i fix it? i've tried a few things like explicitly  denoting types but can't get around it https://paste.tomsmeding.com/SIas3Dgn
2021-07-20 11:28:46	dsal	[01:11:13] You could use type applications.
2021-07-20 11:28:46	dsal	[01:11:15] Or ignore it.
2021-07-20 11:28:46	geekosaur	[01:12:03] and stop using -Werrorl or at least turn it off for defaulting
2021-07-20 11:28:46	geekosaur	[01:12:28] where it's kinda obnoxious because defaulting basically exists for this use case
2021-07-20 11:28:46	dsal	[01:12:51] Most of the time where I've had defaulting warnings, I've not cared.
2021-07-20 11:28:46	oso	[01:13:41] looking into defaulting, thanks
2021-07-20 11:28:46	geekosaur	[01:14:18] the problem is that there are cases where you pretty much can't specify the type
2021-07-20 11:28:46	geekosaur	[01:15:50] although here you could, you just have to annotate almost everything with a type
2021-07-20 11:28:46	oso	[01:16:10] i only had to annotate the 100 as a double, actually, that got rid of the warning
2021-07-20 11:28:46	oso	[01:18:08] thanks for pointing me in the right direction
2021-07-20 11:28:46	h98	[01:59:15] I love how GHC gets confused by numbers in instance resolution....is "1" a Word32 or a Ptr a -> Ptr b -> IO Word32? Who knows what he meant!
2021-07-20 11:28:46	Boarders	[03:51:19] does GHC have standalone kind signatures now?
2021-07-20 11:28:46	Boarders	[03:52:14] I can't seem to find it in the user guide so I must be looking in the wrong places
2021-07-20 11:28:46	justsomeguy	[04:05:38] In the book I'm reading, it says "Functional programming languages are all based on lambda calculus." Isn't this wrong? -- Lisp (non-scheme, older versions only), I think, was based on McCarthy's recursive function notation. I've also encountered some quotes about ALGOL 68 being described partly in lambda calculus, which leads me to ask -- what does it mean for a language to be based on lambda
2021-07-20 11:28:46	justsomeguy	[04:05:40] calculus in the first place?
2021-07-20 11:28:46	Boarders	[04:06:54] lisp was definitely based on the lambda calculus even if mccarthy made improvements to it as a programming language
2021-07-20 11:28:46	justsomeguy	[04:07:50] There's a quote in this article by McCarthy saying otherwise ... https://danielsz.github.io/blog/2019-08-05T21_14.html
2021-07-20 11:28:46	justsomeguy	[04:08:30] Or, err, a quote by McCarthy in this article by Danielsz.
2021-07-20 11:28:46	justsomeguy	[04:08:47] (Words are hard, sometimes.)
2021-07-20 11:28:46	Boarders	[04:09:16] everyone else involved in lisp seemed to think it was "based on" the lambda calculus so I wouldn't take what McCarthy's quote means too seriously
2021-07-20 11:28:46	Boarders	[04:09:33] especially for instance the writers of scheme
2021-07-20 11:28:46	Boarders	[04:10:05] who wrote a whole series of papers explaining how to encode various programming language construct in lambda calculus
2021-07-20 11:28:46	justsomeguy	[04:10:27] Hmm... ok.
2021-07-20 11:28:46	Boarders	[04:11:17] this is a relevant paper: https://dspace.mit.edu/handle/1721.1/6091
2021-07-20 11:28:46	justsomeguy	[04:12:05] I'm still not sure the calculus matters. If a PL was developed that is based on SKI combinator calculus, and had functional features (referential transparency, first-class functions) would you consider that a functional language?
2021-07-20 11:28:46	 *	justsomeguy [04:12:18] is checking out the paper now
2021-07-20 11:28:46	justsomeguy	[04:13:36] But I think I'm probably taking that quote from the book too literally.
2021-07-20 11:28:46	lechner	[04:14:06] which book?
2021-07-20 11:28:46	justsomeguy	[04:14:21] Haskell programming from first princpiles (haskellbook.com)
2021-07-20 11:28:46	justsomeguy	[04:15:21] I'm, uhh, currently over-analysing the first chapter as part of a strange procrastination ritual.
2021-07-20 11:28:46	lechner	[04:16:49] sometimes it's worthwhile to get your bearings right
2021-07-20 11:28:46	justsomeguy	[04:17:42] Well, at least I'm still learning new things from it.
2021-07-20 11:28:46	dsal	[04:31:36] It's a great book. Depends on what you need to get out of it, though.  I didn't care much about that particular bit of theory.
2021-07-20 11:28:46	justsomeguy	[04:45:07] I've been developing a love hate relationship with it. I like the order that it teaches things in, and also how it leaves a lot of breadcrumbs to explore further. On the other hand, I often wish it to be more explcit about what the learning objectives for each chapter are, and have better code examples of where a newly introduced abstraction will be useful. It's also just too long, and not
2021-07-20 11:28:46	justsomeguy	[04:45:09] structured well enough to keep track of things (section names aren't descriptive enough, no figure numbers).
2021-07-20 11:28:46	justsomeguy	[04:45:36] But part of that is also just me learning how to read a big book.
2021-07-20 11:28:46	 *	justsomeguy [04:46:48] hasn't attempted to read a large non-fiction book where he can't "keep it all in his head" at once before this.
2021-07-20 11:28:46	dsal	[05:09:27] Well, the lambda calculus thing is the first chapter, so like, I'm not sure how you got such a judgment.  :)
2021-07-20 11:28:46	dsal	[05:09:39] But it mostly just walks you through building a lot of the fundamentals.
2021-07-20 11:28:46	dsal	[05:10:47] I had working haskell code I was working on when I read it, though.  A lot of what it did was help me understand my code and the ideas behind it better.  And dissolved some of the magic.
2021-07-20 11:28:46	justsomeguy	[05:11:30] As for how I came up with that opionion; I've read up to chapter 22, but am revisiting ch 1.
2021-07-20 11:28:46	justsomeguy	[05:15:08] Overall, I like the book a lot. Maybe I shouldn't have said so much; I got a bit frustrated with it.
2021-07-20 11:28:46	sm	[05:16:20] justsomeguy: sounds quite reasonable
2021-07-20 11:28:46	dsal	[05:31:56] Ah.  It sounded like you were just on chapter one.  heh.
2021-07-20 11:28:46	dsal	[05:32:24] It's not a *perfect* book, but I liked the pace.   I can totally understand why some people wouldn't like it.  I enjoyed forgetting I ever knew how to program and just hopping in.
2021-07-20 11:28:46	***	Playback Complete.
2021-07-20 11:28:55	--	Channel created on Sun, 25 Apr 2021 01:04:39
2021-07-20 11:28:56	--	irc: disconnected from server
2021-07-20 11:29:00	-->	amanr (~therojjha@20.204.87.0) has joined #haskell
2021-07-20 11:29:00	--	Topic for #haskell is "https://www.reddit.com/r/haskell | Admin: #haskell-ops | Offtopic: #haskell-offtopic | https://downloads.haskell.org | Paste code/errors: https://paste.tomsmeding.com | tunes.org-style logging should be coming soon | Logs: https://ircbrowse.tomsmeding.com/browse/lchaskell"
2021-07-20 11:29:00	--	Topic set by geekosaur (~geekosaur@xmonad/geekosaur) on Mon, 14 Jun 2021 05:16:14
2021-07-20 11:29:00	--	Channel #haskell: 699 nicks (1 op, 0 voices, 698 normals)
2021-07-20 11:29:00	***	Buffer Playback...
2021-07-20 11:29:00	dibblego	[10:29:55] you might be thinking of traverse_
2021-07-20 11:29:00	dminuoso	[10:29:58] Then we `sequence` this, which turns `[IO Int] -> IO [Int]`
2021-07-20 11:29:00	dminuoso	[10:32:32] Imagine this to be: sequence (x:xs) = (:) <$> x <*> sequence xs; sequence [] = pure []
2021-07-20 11:29:00	dminuoso	[10:32:58] dibblego: Ah yeah. I guess that was wrong of me.
2021-07-20 11:29:00	dminuoso	[10:33:06] While I was typing the definition, I realized my mistake.
2021-07-20 11:29:00	dminuoso	[10:33:44] % mySequence (x:xs) = (:) <$> x <*> mySequence xs; mySequence [] = pure []
2021-07-20 11:29:00	yahb	[10:33:44] dminuoso: 
2021-07-20 11:29:00	dminuoso	[10:33:46] % :t mySequence
2021-07-20 11:29:00	yahb	[10:33:46] dminuoso: Applicative f => [f a] -> f [a]
2021-07-20 11:29:00	dibblego	[10:33:52] I think sequence is more obvious in the way you are trying to explain it, like this:
2021-07-20 11:29:00	dminuoso	[10:33:53] % mySequence [Just 10, Just 20, Just 30]
2021-07-20 11:29:00	yahb	[10:33:53] dminuoso: Just [10,20,30]
2021-07-20 11:29:00	dibblego	[10:34:20] (::.) = liftA2 (:); lift0 = pure; sequence (x:xs) = x ::. sequence xs; sequence [] = lift0 []
2021-07-20 11:29:00	dibblego	[10:35:56] once liftA2 is understood conceptually, then (*>) is quite simply: const id with some liftA2-ness
2021-07-20 11:29:00	albet70	[11:18:46] so could we say traverse another version of fmap which it can do earlier exit?
2021-07-20 11:29:00	[exa]	[11:21:01] "another" may be a weak label for the myriad of extra stuff it can do :]
2021-07-20 11:29:00	dminuoso	[11:28:04] albet70: Mmm, not just that.
2021-07-20 11:29:00	dminuoso	[11:28:38] albet70: Say you have a Tree of values, say of type String. For each string you want to query some database, and replace the string with some value you read from the database, say something of type User.
2021-07-20 11:29:00	dminuoso	[11:29:00] then you can do: do { userTree <- traverse fetchUserFromString stringTree; ... }
2021-07-20 11:29:00	dminuoso	[11:29:46] albet70: The key thing to realize is that Applicative/Monad encode certain.. "effects". For `Maybe/Either e` the effect is that of an exception, for IO it's outside world interaction, for list it's non-determinism, etc..
2021-07-20 11:29:00	dminuoso	[11:30:00] So we map each element to an effectful computation, and then sequence them
2021-07-20 11:29:00	dminuoso	[11:30:38] Important bit to notice, is that traverse fundamentally does not change the "shape" of that structure. So if you traverse over a tree, the shape of it remains (so you cant drop or create nodes)
2021-07-20 11:29:00	dminuoso	[11:31:44] traverse on a list for example gives us a more generalized version of effectful loops. So a Python loop in which you do say database queries can be written with `traverse`
2021-07-20 11:29:00	dminuoso	[11:31:57] But `traverse` allows us to do even more, not just database queries
2021-07-20 11:29:00	dminuoso	[11:32:03] And it works on not just lists, but also trees.
2021-07-20 11:29:00	dibblego	[12:04:11] traverse is exactly fmap, if you use Identity in place of the general Applicative 
2021-07-20 11:29:00	dibblego	[12:04:32] but it also does other Applicative things, not just Identity
2021-07-20 11:29:00	hseg	[12:45:53] hi. have this generator http://ix.io/3tqe, and I would like to generalize it so its input generators can depend on each other's results (i.e. want to be able to pass [a -> Gen a])
2021-07-20 11:29:00	hseg	[12:46:15] have tried just doing that, but it involves a lot of churn
2021-07-20 11:29:00	hseg	[12:46:30] is there a more mtl'y way of writing this that can help avoid this churn
2021-07-20 11:29:00	hseg	[12:46:33] ?
2021-07-20 11:29:00	hseg	[12:48:03] presumably, I'd want to have inputs be sth like [n a] with MonadGen n and some constraint expressing that whatever effects n gives are liftable to m 
2021-07-20 11:29:00	hseg	[12:48:43] but that looks overly involved
2021-07-20 11:29:00	zangi	[12:58:35] probably a paradox, but does having IO means haskell is impure? :)
2021-07-20 11:29:00	Axman6	[12:58:42] no
2021-07-20 11:29:00	zangi	[12:59:30] does IO itself impure? what does it mean to be "pure" in haskell sense?
2021-07-20 11:29:00	Axman6	[12:59:49] IO is pure, the execution of it may not be. dibblego is excellent at explaining why 
2021-07-20 11:29:00	 *	Axman6 [12:59:59] handballs the conversation to dibblego
2021-07-20 11:29:00	DigitalKiwi	[13:00:15] what about unsafeCoerce
2021-07-20 11:29:00	zangi	[13:00:52] who's dibblego?
2021-07-20 11:29:00	DigitalKiwi	[13:01:13] why's dibblego
2021-07-20 11:29:00	Axman6	[13:01:43] HE authored much of the NICTA/Data61/System-F FP course, where we explain why IO is pure
2021-07-20 11:29:00	Axman6	[13:01:46] He*
2021-07-20 11:29:00	zangi	[13:02:18] does he have any article about this issue?
2021-07-20 11:29:00	DigitalKiwi	[13:02:20] ofc we all know the answer to how's dibblego (by plane)
2021-07-20 11:29:00	DigitalKiwi	[13:02:35] ba dum tsch
2021-07-20 11:29:00	DigitalKiwi	[13:03:14] https://github.com/system-f/fp-course
2021-07-20 11:29:00	DigitalKiwi	[13:03:41] https://www.youtube.com/watch?v=NzIZzvbplSM&list=PLly9WMAVMrayYo2c-1E_rIRwBXG_FbLBW
2021-07-20 11:29:00	zangi	[13:04:27] DigitalKiwi++
2021-07-20 11:29:00	zangi	[13:05:09] thanks, anyway does it mean IO in haskell is different to IO in other (imperative) languages?
2021-07-20 11:29:00	[exa]	[13:07:53] zangi: haskell is pure; the ugly impure execution of the IO action recipes written in haskell is only done by computers
2021-07-20 11:29:00	kuribas	[13:08:27] [exa]: but then any language is pure?
2021-07-20 11:29:00	[exa]	[13:09:12] nah, some languages rely on that impurity
2021-07-20 11:29:00	[exa]	[13:10:27] (and some certain others are just dirty)
2021-07-20 11:29:00	DigitalKiwi	[13:15:18] i like my coffee like i like my programming languages; strong, statically typed, purely functional with type inference and lazy evaluation.
2021-07-20 11:29:00	lechner	[13:18:13] Hi, how can I use MonadFail to handle exceptions from Codec.Compression.Lzma, please?
2021-07-20 11:29:00	Boarders	[13:34:58] is there a variant combinator in megaparsec that is like: do {t <- takeWhileP Nothing (/= '\n'); char '\n'; pure t}
2021-07-20 11:29:00	tdammers	[13:40:37] https://hackage.haskell.org/package/parser-combinators-1.3.0/docs/Control-Applicative-Combinators.html#v:manyTill maybe?
2021-07-20 11:29:00	dmj`	[13:41:19] lechner: did you try using `catch`
2021-07-20 11:29:00	Boarders	[13:44:40] manyTill is very related but not quite the same
2021-07-20 11:29:00	lechner	[13:45:32] dmj`:  i'm still reading, and working on my general Haskell learning curve
2021-07-20 11:29:00	lechner	[13:51:21] dmj`: but i do have working program (which i wrote) where I could try your suggestion. how do i use catch, please?    https://salsa.debian.org/lintian/kickoff/-/blob/master/Collect.hs#L82
2021-07-20 11:29:00	tzh	[14:06:39] hey so i'm working on a haskell game; does anybody have any suggestions for an input library that would work well? previously i've used reactive-banana, which worked well enough even if its FRP nature made it a little clunky for use in a highly-interactive program. i saw some people mention using arrowized FRP libraries likes Yampa/dunai but that seems more like something to use for physics integration than for things like 'how to click on 
2021-07-20 11:29:00	tzh	[14:06:40] a menu'
2021-07-20 11:29:00	kuribas	[14:14:12] tzh: reactive-banana isn't an input library, it's a FRP library.
2021-07-20 11:29:00	kuribas	[14:14:20] You can use it with any UI library.
2021-07-20 11:29:00	maerwald	[14:15:21] SDL2?
2021-07-20 11:29:00	[exa]	[14:15:37] tzh: immediate-mode GUIs (google imgui) are priceless for games, except I don't know if we have any for haskell yet
2021-07-20 11:29:00	tzh	[14:15:51] kuribas: okay yes it's not a raw input-catching library; i'm actually using glfw for that. what i'm looking for is an input _processing_ library, to impose some order onto my input flow so it's not a bunch of ad-hoc garbage
2021-07-20 11:29:00	kuribas	[14:16:18] tzh: reactive-banana should be fine.
2021-07-20 11:29:00	tzh	[14:21:02] the main issue with reactive-banana is that it gets pretty clunky since it only runs in IO and thus can never directly run actual buffer writes... (well, okay, there are ways but that becomes a mess of running all input-processing code inside a render monad, with an unknown timing to my render loop). which means i need to have its output actions queue render actions like buffer allocations/writes, and then outside of the event loop pull 
2021-07-20 11:29:00	tzh	[14:21:03] them out so they can actually be run, which seems a little clunky and counter to the FRP experience, but i don't really see how that could be avoided given how opengl rendering works. so really i'd just like for that experience to be a bit smoother
2021-07-20 11:29:00	dmj`	[15:18:00] lechner:  do { result <- try (evaluate (decompress bytes)) :: IO (Either SomeException ByteString); case result of { Left e -> print e; Right bytes -> print (length bytes) } }
2021-07-20 11:29:00	Las[m]	[15:22:29] Question about bound threads: Will unbound threads use an OS thread created by forkOS?
2021-07-20 11:29:00	monochrom	[15:26:24] Probably in an ideal world shouldn't matter but in practice the GHC implementers wouldn't troll themselves by doing that.
2021-07-20 11:29:00	monochrom	[15:28:14] In practice there is pure Haskell code that can hold up an OS thread uninterruptible. Now what can you do when the rightful owner of the OS thread needs it?
2021-07-20 11:29:00	c_wraith	[15:30:03] honestly, that's not a very important edge case, given that the same pure code that will hold a thread uninterruptably will also block garbage collection, and therefore the entire program via stop-the-world GC
2021-07-20 11:29:00	c_wraith	[15:31:12] If you write a loop that does that, you get what you deserve whether bound threads are involved or not.
2021-07-20 11:29:00	c_wraith	[15:31:51] (this is why mueval starts new processes, not just threads)
2021-07-20 11:29:00	jumper149	[15:43:28] The diagram here: https://wiki.haskell.org/Typeclassopedia
2021-07-20 11:29:00	jumper149	[15:43:49] It is missing the superclass `Alternative` of `MonadPlus` :(
2021-07-20 11:29:00	Boarders	[15:54:34] in haddock if I want to include an example that is too long then is the thing to put definitions in a codeblock or make the example multi-line or something else?
2021-07-20 11:29:00	sm	[15:55:56] Boarders: you can have
2021-07-20 11:29:00	sm	[15:55:57] @
2021-07-20 11:29:00	sm	[15:55:57] multi line example...
2021-07-20 11:29:00	sm	[15:55:57] @
2021-07-20 11:29:00	Boarders	[15:58:40] how do you indicate with that what it should evaluate to?
2021-07-20 11:29:00	sm	[15:59:45] (maybe that got truncated. @ delimiters.)
2021-07-20 11:29:00	sm	[16:00:15] Boarders: are you asking about doctests ? the doctest doc will tell
2021-07-20 11:29:00	sm	[16:02:34] https://github.com/sol/doctest#readme
2021-07-20 11:29:00	gentauro	[16:21:01] does anybody has the link to a tweet staging: «category theory is the mathematics of mathematics»?
2021-07-20 11:29:00	gentauro	[16:21:19] I think it was from a female cs prof (I recall)
2021-07-20 11:29:00	Boarders	[16:22:56] https://twitter.com/emilyriehl/status/979375728373518336?s=20
2021-07-20 11:29:00	lechner	[16:24:55] dmj`: it compiled, but did not stop the program from terminating. i got the same message as before:  "Codec.Compression.Lzma.decompressWith: decoding error LzmaRetOK"      https://dpaste.org/FGQs#L7,84,85,86,87
2021-07-20 11:29:00	c_wraith	[16:24:57] In that tweet she credits Eugenia Cheng, which is a name I've heard before.
2021-07-20 11:29:00	lechner	[16:31:13] just make sure you pronounce it right, please    http://eugeniacheng.com/pronunciation/
2021-07-20 11:29:00	dmj`	[16:41:23] lechner: I think the issue is that you're not forking a thread to handle new clients, so your server terminates immediately, since the main thread of execution exits.. You're just blocking on a socket receive until the client exits, then your process terminates. You need to fork threads for each client and ensure the main thread of execution is running indefinitely
2021-07-20 11:29:00	lechner	[16:43:30] dmj`: without a decoding error, this does run forever   https://dpaste.org/FGQs#L105
2021-07-20 11:29:00	lechner	[16:43:47] via iterateM_
2021-07-20 11:29:00	lechner	[16:45:07] it is in fact my motivation to catch the error
2021-07-20 11:29:00	gentauro	[16:52:23] 18:22 < Boarders> https://twitter.com/emilyriehl/status/979375728373518336
2021-07-20 11:29:00	gentauro	[16:52:29] Boarders: that's the one. Thx :)
2021-07-20 11:29:00	jumper149	[17:16:10] I want to choose a Haskell formatter. Are there any nice comparisons? Maybe a blog post?
2021-07-20 11:29:00	[exa]	[17:17:00] jumper149: probably best to ask yourself why you want the formatting at first
2021-07-20 11:29:00	dsal	[17:17:07] Haskell In Depth went over them slightly, but didn't offer an opinion.
2021-07-20 11:29:00	dsal	[17:17:32] IMO, ormolu is weird and wrong, but it's the new kid and at least some people like it.
2021-07-20 11:29:00	dminuoso	[17:17:33] I chose emacs as my formatter. I can press enter, and it formats the code nicely.
2021-07-20 11:29:00	dminuoso	[17:17:49] If it does it wrong, I can change the indentation with a single keypress.
2021-07-20 11:29:00	[exa]	[17:17:55] fourmolu is kinda less bad than ormolu
2021-07-20 11:29:00	 *	geekosaur [17:18:17] formats man8ually as no formatter matches his preference
2021-07-20 11:29:00	dsal	[17:18:30] I use stylish-haskell when I remember.  It usually does OK.
2021-07-20 11:29:00	jumper149	[17:18:41] I want formatting to be consistent over a project. And I would like something that makes sense with git.
2021-07-20 11:29:00	maerwald	[17:18:48] brittany got close to my needs, but it tends to pull apart code so much that stuff becomes overly verbose
2021-07-20 11:29:00	dsal	[17:18:55] I mainly like my imports tidy.
2021-07-20 11:29:00	dminuoso	[17:18:59] jumper149: A consistent style is already a bizarre thing.
2021-07-20 11:29:00	dsal	[17:19:02] jumper149: git just stores blobs, so that's not a big deal.  :)
2021-07-20 11:29:00	dminuoso	[17:19:11] jumper149: Code formatting communicates intent and structure, its highly contextual.
2021-07-20 11:29:00	maerwald	[17:19:39] dminuoso: yes, the consistency argument is mostly nonsense imo. The "I'm too lazy argument" I can get behind
2021-07-20 11:29:00	maerwald	[17:19:42] because I am
2021-07-20 11:29:00	dsal	[17:19:43] ormolu was inspired by elm's canonical format in a lot of way and they prioritized making it easy to read diffs generated by whatever tools they happened to use.  This is a terrible mistake, IMO.
2021-07-20 11:29:00	monochrom	[17:19:45] Perhaps "makes sense with git" means "makes sense with diff".
2021-07-20 11:29:00	dminuoso	[17:19:49] It's sort of the equivalent of saying "a paragraph must always have 3 sentences". It's a stupid proposition to begin with.
2021-07-20 11:29:00	jumper149	[17:20:01] monochrom: exactly!
2021-07-20 11:29:00	dminuoso	[17:20:21] Yes, if each paragraph has 3 sentences, you have a consistent formatting of your natural language. But it really hampers readability
2021-07-20 11:29:00	dsal	[17:20:25] Most of the time when I'm reading code, I'm not reading diffs.  I'd rather prioritize the code over the diffs.
2021-07-20 11:29:00	monochrom	[17:20:32] People keep XYing their diction all the time. Remember that one time when someone said "haddock" to mean doctest?
2021-07-20 11:29:00	maerwald	[17:21:49] dsal: in a lot of PRs I've seen at work there was no way to understand anything from the diff without a walkthrough by the author. Even looking at my own PRs I don't understand anything. In some companies the author writes a walkthrough in the diff comments, but even then: diffs lie
2021-07-20 11:29:00	maerwald	[17:22:16] you don't see the code you changed, only the lines you changed
2021-07-20 11:29:00	jumper149	[17:22:26] I particularly want a formatter for stuff like same style Haddocks (-- vs {- -}), sorted imports and extensions.
2021-07-20 11:29:00	dminuoso	[17:22:43] jumper149: For import/extensions sorting, I find stylish-haskell to be agreeable.
2021-07-20 11:29:00	dminuoso	[17:22:49] (It just breaks in the presence of QQs and TH)
2021-07-20 11:29:00	maerwald	[17:22:54] and CPP
2021-07-20 11:29:00	dminuoso	[17:23:16] jumper149: But note, you should chose your tool to fit *your* style.
2021-07-20 11:29:00	dsal	[17:23:16] maerwald: yeah.  I have that problem reading diffs sometimes.  Like, cool you changed x to y... but what was x and what's y?
2021-07-20 11:29:00	maerwald	[17:23:34] also: reverse dependencies of your code
2021-07-20 11:29:00	maerwald	[17:23:57] you might need to re-read the entire codebase from a different perspective
2021-07-20 11:29:00	maerwald	[17:24:21] while the scrum master is asking why the PR is still not merged
2021-07-20 11:29:00	maerwald	[17:24:56] but hey... not everyone works in security critical code: just push and hope for the best
2021-07-20 11:29:00	monochrom	[17:25:02] "the closer you look, the less you see"
2021-07-20 11:29:00	dminuoso	[17:25:30] monochrom: Yes, that was the mentality of openssl. Distance yourself from the code and embrace Heartbleed!
2021-07-20 11:29:00	dsal	[17:25:32] These modern "diff-friendly" things take something small, clear and readable and make me have to scroll to understand what's going on.  https://www.irccloud.com/pastebin/dhodxIZ7/ok.elm
2021-07-20 11:29:00	monochrom	[17:25:42] haha
2021-07-20 11:29:00	geekosaur	[17:26:11] I somewhat regularly have to click on the extend buttons in github to understand a diff
2021-07-20 11:29:00	geekosaur	[17:26:26] which is the simple version of this
2021-07-20 11:29:00	monochrom	[17:26:54] Clearly, the logical conclusion is one token per line. >:)
2021-07-20 11:29:00	dsal	[17:27:08] There are lots of cases where formatters seem to do that.
2021-07-20 11:29:00	maerwald	[17:27:12] There is a very grumpy C coder on my LinkedIn feed, always riling about security and code correctness. Then one day he wrote why: his bug actually killed people, because it was some control system about pressure valves.
2021-07-20 11:29:00	dsal	[17:27:16] With lines between them.
2021-07-20 11:29:00	dsal	[17:28:09] monochrom: Like, imagine how hard this would be to read if that 'o' shared a line with any of the other code:  https://www.irccloud.com/pastebin/lIpmTDCu/format.elm
2021-07-20 11:29:00	maerwald	[17:28:18] but I don't know what he thinks of code formatters
2021-07-20 11:29:00	maerwald	[17:28:39] then again: that's a solved issue in C anyway
2021-07-20 11:29:00	dsal	[17:29:15] I really like tools that do static analysis and stuff in my code to tell me when I could do things better.   That's an unreasonably hard problem to solve well, though.
2021-07-20 11:29:00	maerwald	[17:34:59] I think the main question is: do you align code or just do syntactical indenting
2021-07-20 11:29:00	euouae	[17:36:50] Hello
2021-07-20 11:29:00	euouae	[17:37:15] I want to create a lazy list whose nth element is a function of its predecessor 
2021-07-20 11:29:00	monochrom	[17:37:27] iterate
2021-07-20 11:29:00	euouae	[17:37:38] What do you mean 
2021-07-20 11:29:00	monochrom	[17:37:49] Look for that function name in the standard library.
2021-07-20 11:29:00	euouae	[17:39:21] Thank you !
2021-07-20 11:29:00	maerwald	[17:39:53] @hoogle iterate
2021-07-20 11:29:00	lambdabot	[17:39:53] Prelude iterate :: (a -> a) -> a -> [a]
2021-07-20 11:29:00	lambdabot	[17:39:54] Data.List iterate :: (a -> a) -> a -> [a]
2021-07-20 11:29:00	lambdabot	[17:39:54] Data.List.NonEmpty iterate :: (a -> a) -> a -> NonEmpty a
2021-07-20 11:29:00	maerwald	[17:40:27] @where hoogle
2021-07-20 11:29:00	lambdabot	[17:40:27] http://haskell.org/hoogle http://hoogle.haskell.org http://fpcomplete.com/hoogle – See also Hayoo, which searches more packages: http://hayoo.fh-wedel.de/
2021-07-20 11:29:00	maerwald	[17:40:40] hayoo is dead no?
2021-07-20 11:29:00	maerwald	[17:41:01] and the fpcomplete link too
2021-07-20 11:29:00	monochrom	[17:41:16] yikes
2021-07-20 11:29:00	geekosaur	[17:41:44] yeh, nobody's updated that
2021-07-20 11:29:00	euouae	[17:42:39] Has anyone tried Haskell on a supercomputer?
2021-07-20 11:29:00	geekosaur	[17:42:48] @where+ hoogle https://hoogle.haskell.org see also https://haskell.org/hoogle which searches a different default set of libraries
2021-07-20 11:29:00	lambdabot	[17:42:48] I will remember.
2021-07-20 11:29:00	geekosaur	[17:43:04] define supercomputer
2021-07-20 11:29:00	maerwald	[17:43:15] for me, both links are the same
2021-07-20 11:29:00	geekosaur	[17:43:33] interesting, maybe they made the old one go away
2021-07-20 11:29:00	maerwald	[17:43:34] haskell.org/hoogle redirects to hoogle.haskell.org
2021-07-20 11:29:00	euouae	[17:43:40] Hmm I’m trying to run a lot of computations and get an answer 
2021-07-20 11:29:00	euouae	[17:43:53] for now I have like 100 cores etc 
2021-07-20 11:29:00	geekosaur	[17:43:56] @where+ hoogle https://hoogle.haskell.org
2021-07-20 11:29:00	lambdabot	[17:43:56] Nice!
2021-07-20 11:29:00	dmj`	[17:44:49] Someone should write a library for parsing XML with GHC.Generics
2021-07-20 11:29:00	geekosaur	[17:45:46] iirc ghc's performance gets worse the more cores you have :( (but maybe this has improved, that was around 7.x)
2021-07-20 11:29:00	geekosaur	[17:46:06] mostly because of stop-the-world gc, though
2021-07-20 11:29:00	euouae	[17:46:51] Okay interesting 
2021-07-20 11:29:00	davean	[17:46:59] It gets harder to make it perform well with more cores, it doesn't inhernety not perform well.
2021-07-20 11:29:00	maerwald	[17:47:06] dmj`: why are you using xml :>
2021-07-20 11:29:00	davean	[17:47:08] But no super computing task is single process
2021-07-20 11:29:00	euouae	[17:47:21] Davean my knowledge is limited 
2021-07-20 11:29:00	davean	[17:47:22] I mean if you could fit it on one system it wouldn't really be using a modern supercomputer
2021-07-20 11:29:00	euouae	[17:47:50] I am not great at Haskell and never programmed for supercomputers before
2021-07-20 11:29:00	euouae	[17:49:49] But Haskell is really attractive for math 
2021-07-20 11:29:00	davean	[17:49:52] I think I've heard of some super computer Haskell use. I'd say everything to do with super computers is pretty definitionally specialized
2021-07-20 11:29:00	euouae	[17:50:17] Yeah basically you need to be very knowledgeable in the domain davean 
2021-07-20 11:29:00	euouae	[17:50:25] And I’m just trying to get by 
2021-07-20 11:29:00	maerwald	[17:50:30] is this about bitcoin mining?
2021-07-20 11:29:00	davean	[17:50:33] The domain, but also that specific computer
2021-07-20 11:29:00	davean	[17:50:38] maerwald: I sure hope not!
2021-07-20 11:29:00	euouae	[17:50:46] No lol it’s research 
2021-07-20 11:29:00	dmj`	[17:50:50] maerwald: AWS S3 still uses XML, https://docs.aws.amazon.com/AmazonS3/latest/API/API_ListObjectsV2.html
2021-07-20 11:29:00	euouae	[17:51:17] Bitcoin stuff is so scummy o want nothing with. It
2021-07-20 11:29:00	davean	[17:52:26] maerwald: Many code bugs kill a large number of fractional people
2021-07-20 11:29:00	euouae	[17:53:01] Davean I don’t understand how situational it could be though 
2021-07-20 11:29:00	euouae	[17:53:22] what I have is some pure math computations applied to many different numbers (say)
2021-07-20 11:29:00	davean	[17:53:54] euouae: The structure of the super computers differ, and the primary issue with super computers is communication
2021-07-20 11:29:00	davean	[17:54:03] You optimize communication, not compute
2021-07-20 11:29:00	euouae	[17:54:11] For now I’m on a single node 
2021-07-20 11:29:00	davean	[17:54:14] The network structures are all different for different optimalities
2021-07-20 11:29:00	davean	[17:54:26] Yes, and theres no modern single node super computers
2021-07-20 11:29:00	euouae	[17:54:54] It’s not necessarily a supercomputer since it’s single node but I’m starting from that 
2021-07-20 11:29:00	davean	[17:54:55] even on a single processor, you have to deal with inter-core communication issues, they're just less
2021-07-20 11:29:00	euouae	[17:55:07] Inter core? 
2021-07-20 11:29:00	euouae	[17:55:22] Are you talking about worker communication?
2021-07-20 11:29:00	euouae	[17:55:28] I’m not following 
2021-07-20 11:29:00	geekosaur	[17:57:54] things like shared memory access
2021-07-20 11:29:00	euouae	[17:58:13] Why is that important ?
2021-07-20 11:29:00	euouae	[17:58:29] I think in my problem no memory is shared 
2021-07-20 11:29:00	euouae	[17:58:54] It’s like map f xs but parallel 
2021-07-20 11:29:00	geekosaur	[17:59:09] if you're handling out subproblems to different threads/cores to be worked on, then there is at least some shared memory
2021-07-20 11:29:00	euouae	[17:59:12] More or less, maybe with a stop condition
2021-07-20 11:29:00	euouae	[17:59:36] Okay but this is the most basic form of it right?
2021-07-20 11:29:00	euouae	[18:04:02] Anyway those issues are part of the algorithm right?
2021-07-20 11:29:00	euouae	[18:04:14] Not some other aspect of the peoblrm
2021-07-20 11:29:00	euouae	[18:04:20] problem*
2021-07-20 11:29:00	davean	[18:04:54] I mean your algorithm isn't determined
2021-07-20 11:29:00	davean	[18:05:02] you design one to optimize for the HW
2021-07-20 11:29:00	geekosaur	[18:05:06] you'd best hope they are, but that would mean it's been specialized to your supercomputer
2021-07-20 11:29:00	davean	[18:05:51] what alg. is best depends on what your counting, and what the various costs are
2021-07-20 11:29:00	davean	[18:06:02] along with your expected problem parameters
2021-07-20 11:29:00	euouae	[18:06:45] So it’s really hard or are you just talking about the optimal case?
2021-07-20 11:29:00	monochrom	[18:07:14] I would think "really hard" and "the optimal case" go well together.
2021-07-20 11:29:00	davean	[18:07:55] Depends on the problem
2021-07-20 11:29:00	davean	[18:08:14] if you're scaling it up past a very small case though I'm talking about what it usually takes to do a servicable job at it
2021-07-20 11:29:00	euouae	[18:08:49] Davean are you speaking from experience with industry or research 
2021-07-20 11:29:00	euouae	[18:09:12] obviously any optimization means more profit in industry I imagine it’s really right
2021-07-20 11:29:00	davean	[18:09:15] yes, though my research wasn't particularly compute intensive even if it was "AI"
2021-07-20 11:29:00	euouae	[18:09:50] But in research there can be diminishing returns because your problem isn’t computationally feasible anyway after n=10 etc
2021-07-20 11:29:00	euouae	[18:10:22] Okay… hmmm. Is it possible for me to get into this at all or am I hopeless?
2021-07-20 11:29:00	davean	[18:10:36] euouae: I mean theres a huge difference between Floyd-Warshall and A*
2021-07-20 11:29:00	davean	[18:10:43] euouae: but they both sorta solve the same problem space
2021-07-20 11:29:00	geekosaur	[18:10:44] nobody here can tell that as we don't know your problem
2021-07-20 11:29:00	euouae	[18:10:59] I don’t know those davean
2021-07-20 11:29:00	euouae	[18:11:55] Okay maybe I’ll ask again if I have something more to show 
2021-07-20 11:29:00	davean	[18:11:56] ANd oh no, Floyd-Warshall is O(|V|^3), and A* is only O(|E|)! Clearly A* is always better? Except not at all
2021-07-20 11:29:00	euouae	[18:12:45] Big constants davean?
2021-07-20 11:29:00	davean	[18:12:45] well |E| can be ~ |V|^2, and what if you want the best paths, not approximations, but you're metric isn't admissible? And you want it for all of them? Or even just one side of those?
2021-07-20 11:29:00	davean	[18:12:51] euouae: no, nothing to do with constants
2021-07-20 11:29:00	davean	[18:13:41] Algrithmicly Floyd-Warshall is the same complexity for some use cases, because while they solve the same-ish problems, they do it for different uses
2021-07-20 11:29:00	davean	[18:13:57] if you do something |V|^2 |V times, thats |V|^3
2021-07-20 11:29:00	davean	[18:14:17] But Floyd-Warshall requires more communication
2021-07-20 11:29:00	davean	[18:14:27] A* is the "embarasingly" paralleler case
2021-07-20 11:29:00	davean	[18:14:53] so if you're CPUs are very seperated, maybe you want to work more like that again, except not you can go back and plan the communication of F-W ...
2021-07-20 11:29:00	euouae	[18:16:14] Oh man I’m not following 
2021-07-20 11:29:00	euouae	[19:04:02] Hello why am I getting a stack overflow for this? sum $ map f [T x y z | x<-xs, y<-xs, z<-xs ] where xs has 256 elements 
2021-07-20 11:29:00	euouae	[19:04:22] and f calculates the area of the triangle with vertices x y and z
2021-07-20 11:29:00	Hecate	[19:04:25] euouae: stack or heap? 
2021-07-20 11:29:00	euouae	[19:04:34] Says stack on Gucci 
2021-07-20 11:29:00	euouae	[19:04:36] Ghci 
2021-07-20 11:29:00	davean	[19:05:44] 256^3?
2021-07-20 11:29:00	h98	[19:05:47] 256^3 = 16,777,216
2021-07-20 11:29:00	euouae	[19:05:57] I was hoping that it wouldn’t have to expand a 256^3 list before summing 
2021-07-20 11:29:00	geekosaur	[19:06:03] is this sum being foldl again?
2021-07-20 11:29:00	euouae	[19:06:23] Are you asking me?
2021-07-20 11:29:00	geekosaur	[19:06:30] no
2021-07-20 11:29:00	hseg	[19:07:00] hi. have this generator http://ix.io/3tqe, and I would like to generalize it so its input generators can depend on each other's results (i.e. want to be able to pass [a -> Gen a])
2021-07-20 11:29:00	Rembane	[19:07:11] euouae: What happens if you replace sum with foldr1 (+) ? 
2021-07-20 11:29:00	hseg	[19:07:20] have tried just doing that, but it involves a lot of churn
2021-07-20 11:29:00	hseg	[19:07:26] is there a more mtl'y way of writing this that can help avoid this churn
2021-07-20 11:29:00	hseg	[19:07:28] ?
2021-07-20 11:29:00	Hecate	[19:08:18] euouae: until you're on the version of GHC that has sum strict without optimisations, please enable them when you do stuff like that, otherwise space leaks will knock at your door
2021-07-20 11:29:00	geekosaur	[19:09:10] well, you also have to be on a version of ghc which allows optiimization in ghci
2021-07-20 11:29:00	euouae	[19:09:11] Okay so 8.6.5 is old 
2021-07-20 11:29:00	euouae	[19:09:45] Rembane got same thing much later 
2021-07-20 11:29:00	Rembane	[19:10:05] euouae: Got it! 
2021-07-20 11:29:00	euouae	[19:10:09] Ok I guess I have to enable optimizations 
2021-07-20 11:29:00	euouae	[19:10:13] Got what ?
2021-07-20 11:29:00	davean	[19:10:23] foldr' (+) 0 instead of sum sohuld fix it also
2021-07-20 11:29:00	davean	[19:11:22] (That doesn't require optimizations)
2021-07-20 11:29:00	maerwald	[19:11:36] anyone good with libarchive? Do you have a guarantee that when reading list of archive entries that the first entry is the root folder (if any)?
2021-07-20 11:29:00	davean	[19:12:31] maerwald: I certainly can make a tar that thats not true of.
2021-07-20 11:29:00	maerwald	[19:12:54] yeah... I want to strip the root folder, but libarchive API doesn't have that
2021-07-20 11:29:00	davean	[19:12:59] libarchive would have to pre-read the entire tar to avoid it, at best
2021-07-20 11:29:00	geekosaur	[19:13:27] and there are versions of tar that re-output a folder after its contents to allow the other end to more easily set mtime etc.
2021-07-20 11:29:00	maerwald	[19:14:17] the alternative is to unpack as-is, make sure you're on the same device and then do an atomic move operation, stripping the root folder away
2021-07-20 11:29:00	euouae	[19:14:24] Davean also gives me stack overflow 
2021-07-20 11:29:00	maerwald	[19:14:27] but on windows, any file operation is doomed to have locking issues
2021-07-20 11:29:00	euouae	[19:14:46] You might be able to hack libarchive 
2021-07-20 11:29:00	maerwald	[19:14:51] no time
2021-07-20 11:29:00	davean	[19:16:30] maerwald: Conceptually you'd have to do 2 passes over a tar for that, at best
2021-07-20 11:29:00	maerwald	[19:16:51] I think the idea would be to lazily read all entries... fmap over them and strip the root dir, lazily create a new tar archive from the entries and then lazily unpack it
2021-07-20 11:29:00	davean	[19:17:05] why create a new tar archive?
2021-07-20 11:29:00	euouae	[19:17:07] Man pages are outdated 
2021-07-20 11:29:00	davean	[19:17:11] why not just process them as you unpack?
2021-07-20 11:29:00	euouae	[19:17:14] Maybe read the source code 
2021-07-20 11:29:00	maerwald	[19:17:16] davean: there's no function to unpack from entries
2021-07-20 11:29:00	h98	[19:17:44] euouae did you try foldr (\x y -> (f x) + y) 0 [T x y z ....]?
2021-07-20 11:29:00	euouae	[19:18:46] Maerwald: seems related https://github.com/libarchive/libarchive/wiki/WishList#seek-in-archives
2021-07-20 11:29:00	euouae	[19:19:05] H98 would thy be better?
2021-07-20 11:29:00	maerwald	[19:19:23] euouae: the haskell bindings might not be exhaustive
2021-07-20 11:29:00	euouae	[19:19:53] Yeah you’d have to make that but even then I’m painting to the fact that it’s on a wishlist maereald 
2021-07-20 11:29:00	maerwald	[19:20:11] I'd have to write my own version of `toDisk :: Entry FilePath ByteString -> IO ()`
2021-07-20 11:29:00	maerwald	[19:20:19] which sounds trivial, but isn't
2021-07-20 11:29:00	euouae	[19:20:39] Go for a solution that isn’t efficient but works?
2021-07-20 11:29:00	maerwald	[19:20:46] hardlinks, softlinks, preserving file properties
2021-07-20 11:29:00	euouae	[19:21:34] H98 also gives stack overflow 
2021-07-20 11:29:00	euouae	[19:27:21] So the issue is ghci being silly right 
2021-07-20 11:29:00	h98	[19:29:49] yeah I think so
2021-07-20 11:29:00	h98	[19:29:52] I tried this: https://paste.tomsmeding.com/QVCoWxOz
2021-07-20 11:29:00	h98	[19:30:14] if I compile and run it i get 6467616768 after a few seconds
2021-07-20 11:29:00	h98	[19:30:26] if I call test in ghci I get a stack overflow
2021-07-20 11:29:00	h98	[19:30:30] version 8.10.4
2021-07-20 11:29:00	euouae	[19:32:16] Thank you !
2021-07-20 11:29:00	euouae	[19:32:27] Did you have to enable optimizations ?
2021-07-20 11:29:00	h98	[19:33:13] I have no idea how, so I don't think so
2021-07-20 11:29:00	euouae	[19:34:14] Thanks 
2021-07-20 11:29:00	geekosaur	[19:34:22] ghci can't do optimizations except in very recent versions
2021-07-20 11:29:00	h98	[19:38:00] oh but foldl' works
2021-07-20 11:29:00	h98	[19:38:38] https://paste.tomsmeding.com/dLbV73r1 same thing, but no overflow in ghci
2021-07-20 11:29:00	h98	[19:39:35] RWH p. 97 talks about this
2021-07-20 11:29:00	dsal	[19:42:52] why is `sum` bad?  Is this one of those things where fixing it breaks something probably nobody cares about?
2021-07-20 11:29:00	monochrom	[19:46:08] I compiled with -O, no stack overflow, in fact immediate answer.
2021-07-20 11:29:00	monochrom	[19:46:47] main = print (let xs = [1..256] in sum [ x+y+z | x <- xs, y <- xs, z <- xs ])
2021-07-20 11:29:00	geekosaur	[19:46:58] dsal, there was a whole discussion on -cafe about various things using foldl instead of foldl'
2021-07-20 11:29:00	geekosaur	[19:47:15] and thereby being prone to stack overflows
2021-07-20 11:29:00	geekosaur	[19:47:28] sum being the prime example
2021-07-20 11:29:00	_73	[19:47:35] what is the right abstraction to avoid explicit recursion on a function using a monadic action. I tried to write it as a foldr but wasn't able to succeed. Here is my code that does use explicit recursion: http://dpaste.com/2SKMBLTA8
2021-07-20 11:29:00	dsal	[19:48:32] :t foldM
2021-07-20 11:29:00	lambdabot	[19:48:33] (Foldable t, Monad m) => (b -> a -> m b) -> b -> t a -> m b
2021-07-20 11:29:00	geekosaur	[19:48:48] I think it comes down to nobody thought about it and the original Prelude was written for comprehensibility by newcomers rather than performance
2021-07-20 11:29:00	dsal	[19:49:05] @src sum
2021-07-20 11:29:00	lambdabot	[19:49:06] sum = foldl (+) 0
2021-07-20 11:29:00	monochrom	[19:49:22] Oh don't worry about @src, it's independently handwritten.
2021-07-20 11:29:00	monochrom	[19:49:28] Hell, s/worry/trust/
2021-07-20 11:29:00	dsal	[19:49:39] Yeah.  I just tend to assume it's a simplification for understanding.
2021-07-20 11:29:00	monochrom	[19:50:10] Yeah, great educational tool.
2021-07-20 11:29:00	geekosaur	[19:50:44] and @src is mostly lifted from the Report, and is similarly intended for reading rather than running
2021-07-20 11:29:00	_73	[19:52:55] I got it work with foldM thanks
2021-07-20 11:29:00	euouae	[20:00:53] Heh I got “killed” after I run ghc 
2021-07-20 11:29:00	euouae	[20:01:14] What does that mean ?
2021-07-20 11:29:00	geekosaur	[20:01:29] the OOM killer got you
2021-07-20 11:29:00	geekosaur	[20:01:57] i.e. the Linux kernel decided your process was eating too much memory and nuked it
2021-07-20 11:29:00	geekosaur	[20:03:39] (or similar for OS X, etc.; only Windows will differ but it has its own way of dealing with that)
2021-07-20 11:29:00	euouae	[20:04:39] Hmm alright the oom reaper 
2021-07-20 11:29:00	ddb	[20:16:07] geekosaur: is that discussion about things using foldl instead of foldl' logged or archived anywhere?
2021-07-20 11:29:00	maerwald	[20:17:23] can you have extaustiveness check with NamedFieldPuns?
2021-07-20 11:29:00	maerwald	[20:18:25] let's say you have Foo = Foo { foo1 :: String, foo2 :: String, foo3 :: String } and you want to pattern match on it without relying on the order, but also make sure you don't miss something when a new record is added
2021-07-20 11:29:00	maerwald	[20:19:49] Relying on order is shitty when all the records are of the same type
2021-07-20 11:29:00	geekosaur	[20:22:19] ddb, somewhere on the haskell-cafe mailing list archives
2021-07-20 11:29:00	hseg	[21:01:02] feels like this can be expressed in standard terms, any ideas? http://ix.io/3tsp
2021-07-20 11:29:00	hseg	[21:02:17] idea is to sum a list, then if possible without changing the sign, replace the last element by its difference from the sum so it all sums to 0
2021-07-20 11:29:00	hseg	[21:02:46] (need to maintain signs, and the list is sorted by absolute value)
2021-07-20 11:29:00	dsal	[21:07:50] > let xs = init [1, 2, 3] in xs <> [0 - sum xs]   -- hseg like this?  I'm a bit confused by your specification.
2021-07-20 11:29:00	lambdabot	[21:07:51]  [1,2,-3]
2021-07-20 11:29:00	hseg	[21:08:49] spec is: (assuming output is Just): ((==) `on` compare 0) xs (fixSum xs), sum (fixSum xs) == 0
2021-07-20 11:29:00	hseg	[21:09:35] and I'm choosing to limit the cases i'm fixing to those (==) `on` init
2021-07-20 11:29:00	hseg	[21:10:37] hrm. your code is probably clearer -- just need to compose with a guard to make sure it satisfies spec
2021-07-20 11:29:00	hseg	[21:10:54] though if there were some way of avoiding the append, that would be nice
2021-07-20 11:29:00	EvanR	[21:13:59] you want to change the last element of a list?
2021-07-20 11:29:00	hseg	[21:14:03] y
2021-07-20 11:29:00	EvanR	[21:14:07] oof
2021-07-20 11:29:00	hseg	[21:14:53] could fix it so it's correct-by-construction, but that makes my generator code very ugly
2021-07-20 11:29:00	EvanR	[21:14:57] can you designate the first element the element that needs to be changed
2021-07-20 11:29:00	hseg	[21:15:28] nope -- sorted ascending by absolute value
2021-07-20 11:29:00	EvanR	[21:15:44] how about descending
2021-07-20 11:29:00	hseg	[21:15:58] and there's enough stuff depending on this already that I'd rather not push that redesign
2021-07-20 11:29:00	hseg	[21:16:46] should just take the l and continue -- probably not going to be significant enough to matter
2021-07-20 11:29:00	hseg	[21:16:51] (lists will be short)
2021-07-20 11:29:00	hseg	[21:17:09] at least it's O(n) vs O(1), not O(n) vs O(n^k)
2021-07-20 11:29:00	EvanR	[21:17:10] i like to split things up into steps rather than code golfing
2021-07-20 11:29:00	hseg	[21:17:30] ?
2021-07-20 11:29:00	hseg	[21:17:44] where are you seeing golfing in my code?
2021-07-20 11:29:00	EvanR	[21:17:49] or in this case, perhaps write a combinator that traverses a list and uses a function argument to decide how to modify the last element
2021-07-20 11:29:00	EvanR	[21:18:02] i only saw 1 line of code, so it seems like golf xD
2021-07-20 11:29:00	hseg	[21:18:10] :)
2021-07-20 11:29:00	hseg	[21:18:44] posted code earlier, but that could work
2021-07-20 11:29:00	hseg	[21:19:42] k, not bad enough to matter
2021-07-20 11:29:00	EvanR	[21:19:43] a combination fold and specialized list reconstructor. And scanl may already be that
2021-07-20 11:29:00	davean	[21:20:42] hseg: how does this handle the singleton list?
2021-07-20 11:29:00	hseg	[21:21:04] [0] -> Just [0], [x] -> Nothing
2021-07-20 11:29:00	EvanR	[21:21:31] oh failure, nvm
2021-07-20 11:29:00	davean	[21:21:41] Oh damn, thats ... ok
2021-07-20 11:29:00	EvanR	[21:22:26] if you're changing the last element wouldn't [x] |-> Just [0]
2021-07-20 11:29:00	davean	[21:22:36] EvanR: Thats why I asked!
2021-07-20 11:29:00	davean	[21:23:11] I had suspicions about the spec
2021-07-20 11:29:00	hseg	[21:23:13] no, because i need elementwise (==) `on` compare 0
2021-07-20 11:29:00	hseg	[21:23:37] which is more important to me than success fixing the sum
2021-07-20 11:29:00	EvanR	[21:24:30] less a spec and more a would be nice list xD
2021-07-20 11:29:00	davean	[21:24:44] Yah, I think you need to think about your actual problem space hseg 
2021-07-20 11:29:00	davean	[21:24:52] I suspect you haven't come to understanding of your actual goals
2021-07-20 11:29:00	hseg	[21:25:26] am writing a quickcheck generator. all I need is that it generate enough correct values quickly
2021-07-20 11:29:00	davean	[21:25:42] No, thats not what you need for good quickchecks
2021-07-20 11:29:00	davean	[21:25:54] Thats what you need for invalid quickchecks
2021-07-20 11:29:00	hseg	[21:26:09] because I also need a good shrink?
2021-07-20 11:29:00	hseg	[21:26:18] (need one regardless (: )
2021-07-20 11:29:00	davean	[21:26:19] No, shrink is secondary and never required
2021-07-20 11:29:00	davean	[21:26:41] Quickcheck generators have to cover the domain, or at least the preimage
2021-07-20 11:29:00	hseg	[21:26:54] basically all I'm using this for is for randomly sampling the domain
2021-07-20 11:29:00	davean	[21:27:11] But you've just described NOT sampling the domain
2021-07-20 11:29:00	davean	[21:27:28] you'd just described sampling a particular subdomain of the domain
2021-07-20 11:29:00	davean	[21:28:03] And even suggested it isn't the preimage
2021-07-20 11:29:00	davean	[21:28:07] (strongly)
2021-07-20 11:29:00	davean	[21:28:36] Making the quickcheck results close to meaingless
2021-07-20 11:29:00	hseg	[21:29:01] perhaps. am not using the full power of quickcheck, regardless
2021-07-20 11:29:00	davean	[21:29:11] This isn't about power, this is about validity
2021-07-20 11:29:00	hseg	[21:29:38] yes? so I know I will get false positives/negatives
2021-07-20 11:29:00	davean	[21:30:03] So whats the point of running this code at all? You know as much before it runs as after
2021-07-20 11:29:00	hseg	[21:30:08] as long as I'm still having recognizable true negatives, I'm not worried about it
2021-07-20 11:29:00	hseg	[21:31:02] I'm testing a hypothesis that an invariant I have in mind is fine enough to predict the value of a function
2021-07-20 11:29:00	hseg	[21:31:29] so as long as my samplings show it isn't, I don't care that I haven't sampled the entire space
2021-07-20 11:29:00	EvanR	[21:31:43] maybe this is a probabalistic application
2021-07-20 11:29:00	hseg	[21:31:53] not probabilistic. hypothesis testing
2021-07-20 11:29:00	EvanR	[21:32:08] counterexample finding?
2021-07-20 11:29:00	hseg	[21:32:16] exactly
2021-07-20 11:29:00	EvanR	[21:32:20] cool
2021-07-20 11:29:00	EvanR	[21:32:29] it only takes 1 xD
2021-07-20 11:29:00	hseg	[21:32:34] exactly
2021-07-20 11:29:00	hseg	[21:32:46] and unfortunately, I have >>>1
2021-07-20 11:29:00	hseg	[21:33:37] so I need to refine the invariant I'm using
2021-07-20 11:29:00	hseg	[21:33:52] not clear how, though
2021-07-20 11:29:00	hseg	[21:34:29] welp. that's what research is for, ig
2021-07-20 11:29:00	EvanR	[21:34:31] eventually you will not find any counterexamples
2021-07-20 11:29:00	hseg	[21:34:54] yeah. am hoping that by then, will have actual proof that my invariant works
2021-07-20 11:29:00	hseg	[21:36:12] especially considering this is trying to give a closed form for a recursive formula, have high hopes it is possible
2021-07-20 11:29:00	bpv	[21:59:00] How is it going?
2021-07-20 11:29:00	nova	[23:34:03] I am currently using arch with ghcup and cabal, but cabal takes SO long to install packages that it is simply not usable. I am about to try nixos or gentoo, and I was wondering if anyone here uses their respective package managers to manager haskell packages (pandoc, pandoc-citeproc [this takes forever to recompile pandoc], xmonad, xmobar, etc). If so, does one hold an edge over the other?
2021-07-20 11:29:00	nova	[23:37:24] I was using pacman, but I had to remove all of my haskell packages because it was even worse than ghcup (but at least it was fast)
2021-07-20 11:29:00	sclv	[23:39:30] we’re developers here mainly. compile times are what they are
2021-07-20 11:29:00	dsal	[23:41:16] nova: I'm a pretty big fan of nixos.  Nonetheless, first compilation can take a bit.
2021-07-20 11:29:00	davean	[23:41:29] You compile things once and you're done, meh?
2021-07-20 11:29:00	nova	[23:42:35] what about upgrades
2021-07-20 11:29:00	dsal	[23:43:12] Upgrades of what?
2021-07-20 11:29:00	yin[m]	[23:43:46] any way we can avoid having to add `Show a =>` to a bunch of type signatures when "No instance for (Show a) arising from a use of ..." just for a quick Debug.trace?
2021-07-20 11:29:00	dsal	[23:43:53] I do nix updates all the time because I like giving my computer busy work.  heh.  They're reversible, though.  If things go wrong, I can undo them.
2021-07-20 11:29:00	dsal	[23:44:17] yin[m]: You need some way to represent the values you're tracing.
2021-07-20 11:29:00	davean	[23:44:49] nova: uh, upgrades do the amount of work in the delta of the packages changed?
2021-07-20 11:29:00	nova	[23:45:22] does nix have to rebuild after downloading deltas?
2021-07-20 11:29:00	dsal	[23:45:44] nix can use binaries if they're available.  It'll build if they're not.
2021-07-20 11:29:00	davean	[23:45:45] If it doesn't have the builds cached
2021-07-20 11:29:00	yin[m]	[23:46:50] sure, and I know they are, but ghc complains that if what I'm trying to show is an a and the funcion I'm in doesn't have the Show constraint in it, i cant see it. are my only options to comment all the relevant type signatures or add the Show constraint everywhere? isn't there something like an unsafeShow?
2021-07-20 11:29:00	yin[m]	[23:47:19] i just want a quick print for debugging purposes
2021-07-20 11:29:00	yin[m]	[23:47:48] * sure, and I know they are, but ghc complains that if what I'm trying to show is an a and the funcion I'm in doesn't have the Show a => constraint in it, i cant see it. are my only options to comment all the relevant type signatures or add the Show constraint everywhere? isn't there something like an unsafeShow?
2021-07-20 11:29:00	geekosaur	[23:51:41] yin[m]: absent a Show constraint there may not even be code to do the Show
2021-07-20 11:29:00	geekosaur	[23:54:02] more correctly, without that constraint ghc doesn't know that the type involved has the code to do Show — and more to the point, doesn't have access to that code
2021-07-20 11:29:00	geekosaur	[23:54:20] (as ghc implements constraints)
2021-07-20 11:29:00	geekosaur	[23:56:52] a theoretical unsafeShow would still require some way to get access to the Show code for the type. in particular if it knows the type only at runtime, it would have to be passed in via a dictionary still
2021-07-20 11:29:00	davean	[23:59:31] geekosaur: how dirty should I be in answering how to do that?
2021-07-20 11:29:00	geekosaur	[00:03:38] oh brother
2021-07-20 11:29:00	amesgen[m]	[00:03:49] yin: you might be interested in `anythingToString`: https://hackage.haskell.org/package/recover-rtti-0.4.0.0/docs/Debug-RecoverRTTI.html
2021-07-20 11:29:00	davean	[00:04:03] geekosaur: ok, ok I won't break out my dirty tricks
2021-07-20 11:29:00	geekosaur	[00:04:23] I'm not surprised there's some kind of hack but I'm not sure handing out hacks is the best idea here
2021-07-20 11:29:00	davean	[00:04:38] Oh, its an actively bad idea
2021-07-20 11:29:00	zzz	[00:12:48] bow im curious
2021-07-20 11:29:00	zzz	[00:12:56] s/bow/now
2021-07-20 11:29:00	yin[m]	[00:13:07] inpromise I'll ignore it
2021-07-20 11:29:00	geekosaur	[00:13:26] there are some evil ways to manufacture dictionaries on the fly
2021-07-20 11:29:00	oso	[01:10:29] what's this arcane error i'm getting while trying to build and how can i fix it? i've tried a few things like explicitly  denoting types but can't get around it https://paste.tomsmeding.com/SIas3Dgn
2021-07-20 11:29:00	dsal	[01:11:13] You could use type applications.
2021-07-20 11:29:00	dsal	[01:11:15] Or ignore it.
2021-07-20 11:29:00	geekosaur	[01:12:03] and stop using -Werrorl or at least turn it off for defaulting
2021-07-20 11:29:00	geekosaur	[01:12:28] where it's kinda obnoxious because defaulting basically exists for this use case
2021-07-20 11:29:00	dsal	[01:12:51] Most of the time where I've had defaulting warnings, I've not cared.
2021-07-20 11:29:00	oso	[01:13:41] looking into defaulting, thanks
2021-07-20 11:29:00	geekosaur	[01:14:18] the problem is that there are cases where you pretty much can't specify the type
2021-07-20 11:29:00	geekosaur	[01:15:50] although here you could, you just have to annotate almost everything with a type
2021-07-20 11:29:00	oso	[01:16:10] i only had to annotate the 100 as a double, actually, that got rid of the warning
2021-07-20 11:29:00	oso	[01:18:08] thanks for pointing me in the right direction
2021-07-20 11:29:00	h98	[01:59:15] I love how GHC gets confused by numbers in instance resolution....is "1" a Word32 or a Ptr a -> Ptr b -> IO Word32? Who knows what he meant!
2021-07-20 11:29:00	Boarders	[03:51:19] does GHC have standalone kind signatures now?
2021-07-20 11:29:00	Boarders	[03:52:14] I can't seem to find it in the user guide so I must be looking in the wrong places
2021-07-20 11:29:00	justsomeguy	[04:05:38] In the book I'm reading, it says "Functional programming languages are all based on lambda calculus." Isn't this wrong? -- Lisp (non-scheme, older versions only), I think, was based on McCarthy's recursive function notation. I've also encountered some quotes about ALGOL 68 being described partly in lambda calculus, which leads me to ask -- what does it mean for a language to be based on lambda
2021-07-20 11:29:00	justsomeguy	[04:05:40] calculus in the first place?
2021-07-20 11:29:00	Boarders	[04:06:54] lisp was definitely based on the lambda calculus even if mccarthy made improvements to it as a programming language
2021-07-20 11:29:00	justsomeguy	[04:07:50] There's a quote in this article by McCarthy saying otherwise ... https://danielsz.github.io/blog/2019-08-05T21_14.html
2021-07-20 11:29:00	justsomeguy	[04:08:30] Or, err, a quote by McCarthy in this article by Danielsz.
2021-07-20 11:29:00	justsomeguy	[04:08:47] (Words are hard, sometimes.)
2021-07-20 11:29:00	Boarders	[04:09:16] everyone else involved in lisp seemed to think it was "based on" the lambda calculus so I wouldn't take what McCarthy's quote means too seriously
2021-07-20 11:29:00	Boarders	[04:09:33] especially for instance the writers of scheme
2021-07-20 11:29:00	Boarders	[04:10:05] who wrote a whole series of papers explaining how to encode various programming language construct in lambda calculus
2021-07-20 11:29:00	justsomeguy	[04:10:27] Hmm... ok.
2021-07-20 11:29:00	Boarders	[04:11:17] this is a relevant paper: https://dspace.mit.edu/handle/1721.1/6091
2021-07-20 11:29:00	justsomeguy	[04:12:05] I'm still not sure the calculus matters. If a PL was developed that is based on SKI combinator calculus, and had functional features (referential transparency, first-class functions) would you consider that a functional language?
2021-07-20 11:29:00	 *	justsomeguy [04:12:18] is checking out the paper now
2021-07-20 11:29:00	justsomeguy	[04:13:36] But I think I'm probably taking that quote from the book too literally.
2021-07-20 11:29:00	lechner	[04:14:06] which book?
2021-07-20 11:29:00	justsomeguy	[04:14:21] Haskell programming from first princpiles (haskellbook.com)
2021-07-20 11:29:00	justsomeguy	[04:15:21] I'm, uhh, currently over-analysing the first chapter as part of a strange procrastination ritual.
2021-07-20 11:29:00	lechner	[04:16:49] sometimes it's worthwhile to get your bearings right
2021-07-20 11:29:00	justsomeguy	[04:17:42] Well, at least I'm still learning new things from it.
2021-07-20 11:29:00	dsal	[04:31:36] It's a great book. Depends on what you need to get out of it, though.  I didn't care much about that particular bit of theory.
2021-07-20 11:29:00	justsomeguy	[04:45:07] I've been developing a love hate relationship with it. I like the order that it teaches things in, and also how it leaves a lot of breadcrumbs to explore further. On the other hand, I often wish it to be more explcit about what the learning objectives for each chapter are, and have better code examples of where a newly introduced abstraction will be useful. It's also just too long, and not
2021-07-20 11:29:00	justsomeguy	[04:45:09] structured well enough to keep track of things (section names aren't descriptive enough, no figure numbers).
2021-07-20 11:29:00	justsomeguy	[04:45:36] But part of that is also just me learning how to read a big book.
2021-07-20 11:29:00	 *	justsomeguy [04:46:48] hasn't attempted to read a large non-fiction book where he can't "keep it all in his head" at once before this.
2021-07-20 11:29:00	dsal	[05:09:27] Well, the lambda calculus thing is the first chapter, so like, I'm not sure how you got such a judgment.  :)
2021-07-20 11:29:00	dsal	[05:09:39] But it mostly just walks you through building a lot of the fundamentals.
2021-07-20 11:29:00	dsal	[05:10:47] I had working haskell code I was working on when I read it, though.  A lot of what it did was help me understand my code and the ideas behind it better.  And dissolved some of the magic.
2021-07-20 11:29:00	justsomeguy	[05:11:30] As for how I came up with that opionion; I've read up to chapter 22, but am revisiting ch 1.
2021-07-20 11:29:00	justsomeguy	[05:15:08] Overall, I like the book a lot. Maybe I shouldn't have said so much; I got a bit frustrated with it.
2021-07-20 11:29:00	sm	[05:16:20] justsomeguy: sounds quite reasonable
2021-07-20 11:29:00	dsal	[05:31:56] Ah.  It sounded like you were just on chapter one.  heh.
2021-07-20 11:29:00	dsal	[05:32:24] It's not a *perfect* book, but I liked the pace.   I can totally understand why some people wouldn't like it.  I enjoyed forgetting I ever knew how to program and just hopping in.
2021-07-20 11:29:00	***	Playback Complete.
2021-07-20 11:29:07	--	Channel created on Sun, 25 Apr 2021 01:04:39
2021-07-20 11:30:00	-->	favonia (~favonia@user/favonia) has joined #haskell
2021-07-20 11:34:51	-->	yauhsien (~yauhsien@61-231-35-149.dynamic-ip.hinet.net) has joined #haskell
2021-07-20 11:35:47	<--	shutdown_-h_now (~arjan@82-75-187-100.cable.dynamic.v4.ziggo.nl) has quit (Ping timeout: 265 seconds)
2021-07-20 11:35:51	<--	yauhsien (~yauhsien@61-231-35-149.dynamic-ip.hinet.net) has quit (Remote host closed the connection)
2021-07-20 11:36:16	<--	MQ-17J (~MQ-17J@d14-69-206-129.try.wideopenwest.com) has quit (Ping timeout: 258 seconds)
2021-07-20 11:37:32	<--	falafel (~falafel@pool-96-255-70-50.washdc.fios.verizon.net) has quit (Ping timeout: 255 seconds)
2021-07-20 11:38:34	--	irc: disconnected from server
